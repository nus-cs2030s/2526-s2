{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"CS2030<sub>s</sub>","text":""},{"location":"index.html#ay-202526-semester-2","title":"AY 2025/26 Semester 2","text":"<p>This website hosts the lecture notes, lecture slides, and other written guides about CS2030S. You can explore the links on the menu on the left, or search for keywords in the search bar above.</p>"},{"location":"index.html#other-web-resources","title":"Other Web Resources","text":"<ul> <li>Ed</li> <li>Canvas</li> <li>CS2030S Ticketing System</li> </ul>"},{"location":"00-overview.html","title":"Unit 0: Overview","text":"<p>Learning Objectives</p> <p>After this unit, students should be able to:</p> <ul> <li>explain the purpose and scope of CS2030/S within the NUS computing curriculum.</li> <li>describe the kinds of software complexity the course focuses on and why they matter.</li> <li>identify the key abstraction mechanisms\u2014functions, objects, types, and higher-order computation\u2014used to manage evolving software.</li> <li>explain how object-oriented and functional programming principles are used to support extensible, maintainable code.</li> <li>articulate how type systems and immutability help prevent bugs and reduce human reasoning cost.</li> </ul>"},{"location":"00-overview.html#what-is-this-course-about","title":"What is This Course About?","text":"<p>CS2030/S is designed for students who have gone through a typical basic programming course and have learned about problem-solving with simple programming constructs such as loops, conditions, and functions.  In a typical introductory programming course, such as CS1010 and its variants at NUS, students tend to write small programs (in the order of tens or hundreds of lines of code) to solve a programming homework problem, work alone on their code, and move on to solve the next problem once the homework is done.</p> <p>The first aim of CS2030/S is to change the students' mindset and to make them learn to write software that will continue to evolve as software requirements change and to write software that will be read and modified by other programmers (including their future selves).</p> <p>The second aim of CS2030/S is to level up the complexity of programs that the students write, from the order of hundreds of lines to thousands of lines.  CS2030/S bridges students from writing toy programs to solve specific problems in CS1010 and writing larger real-world software in their later courses, such as CS2103 Software Engineering.</p> <p>A programming language is a medium in which programmers can express their intentions and construct software and thus is critical to supporting the aims above.  With the appropriate features and tools, one can tame the complexity of software, make the code written friendlier to other programmers, and easier to evolve.  The third aim of CS2030/S is thus to expand the students' minds on different ways one can construct software and the principles behind some of the programming language constructs.  In particular, CS2030/S focuses on objects, types, and functions, as three key constructs for building programmer-friendly software.  It covers both object-oriented and functional paradigms as two different approaches to constructing software, with a strong emphasis on type safety.</p> <p>The final aim of CS2030/S is to introduce students to programming language concepts and to bridge them from introductory programming to advanced courses such as programming language design and implementation.  Part of CS2030/S introduces students to the design decisions behind some of the constraints and the workings behind the programming language compilation and execution, giving them a glimpse inside the programming system that so far has been mostly treated as a black box in introductory courses.</p> <p>If what you read so far feels abstract now, that is normal.  These ideas, along with many terms that you will read later in this unit, will be explained in detail in the subsequent units of this course.  When you re-read this unit as a recap after going through the course, everything will make sense.</p>"},{"location":"00-overview.html#the-choice-of-java","title":"The Choice of Java","text":"<p>The course is taught using a single programming language to provide continuity and focus. This requires a language that is strongly and statically typed, and that supports both object-oriented and functional programming. Java was chosen for CS2030/S because of its widespread adoption, familiar syntax, and its alignment with subsequent courses in the NUS computing curriculum.</p> <p>While Java is not the most elegant programming language when expressing programs in a functional style, we hope that students can still learn the principles of functional programming and apply them in other programming languages.  This choice is a trade-off between having to switch to a different language in the middle of a course.  </p>"},{"location":"00-overview.html#what-this-course-is-not-about","title":"What This Course is Not About","text":"<p>This is not a course on the Java language.  Instead, CS2030/S uses Java as a concrete medium to teach programming principles and constructs. We will not comprehensively cover Java syntax and features, except those relevant to the concepts we teach.  Some Java features (such as <code>var</code>) are intentionally restricted so that you can clearly see the underlying ideas, rather than relying on shortcuts.</p> <p>This is not a course on software engineering either.  Rather, this course is about the programming principles and constructs on top of which programmers can design better software.  To motivate the importance of these principles and constructs and see how they can be used, we will inevitably cover some of the software engineering design principles, such as Liskov Substitution Principle (the L in SOLID), Tell-Don't-Ask, Composition over Inheritance, etc.  However, we will not comprehensively cover object-oriented design or software design in general (e.g., we will not cover S, O, I, and D in SOLID).  Software engineering is a broad discipline on its own and deserves another course.  </p> <p>Finally, CS2030/S is not a course that focuses on computational efficiency (we have CS2040/C/S for that).  Instead, it focuses on correctness, clarity, and long-term maintainability of software.  In CS2030/S, although reducing computational cost still plays a role, this is not the only cost that matters.  CS2030/S is also concerned with the human cost of debugging or maintaining software.  In striving for simpler software that is easier to maintain and extend, we may have to sacrifice computational efficiency.</p>"},{"location":"00-overview.html#taming-complexity-in-software-development","title":"Taming Complexity in Software Development","text":"<p>An underlying theme of CS2030/S is taming complexity in software development.  There are objective metrics with which one can measure the complexity of software, but here, we will loosely define complexity as anything that increases the likelihood of bugs in a program.</p> <p>Let's start by considering a simplified view of what a software program is.  One can view a software program as a collection of data variables and instructions on how to modify these variables.  A program is generally written to meet a given requirement: given one or more input variables, the program should perform the computation to produce the output variables, in a way that meets the requirement.  Often, the program stores information in the intermediate variables while performing the computation.</p> <p>As a student who has gone through an introductory programming course such as CS1010 and its variants, you should be familiar with the view above, and you should have some experience writing a program to solve a given computational problem.  The programs you have written for these introductory courses are mostly small \"toy\" programs \u2014 they consist of only a few hundred lines and tens of variables, at most.</p> <p>Software development in the real world, however, is far more complex than what you have experienced.  A software program rarely solves a well-defined computational problem only.  It often requires multiple components, such as user interface, data storage, and business rules, intricately interacting with each other to attain a set of functionalities.  </p> <p>As the requirement of the software becomes more complex, the number of variables that need to be kept track of increases; the logic of the computation the programmer needs to maintain the variables becomes more complicated.  Further, it is often that the variables are interdependent.  For instance, updating a variable might require updating another; how a variable should be updated might depend on another variable.  As the number of variables increases, so is the number of relationships between the variables that the programmer has to keep track of.  Failure to correctly maintain the variables and the relationship between them most likely will lead to bugs.</p> <p>Further, real-world software rarely remains static.  This property is again different from what you have experienced in your introductory programming course, where once the instructors release a programming assignment, they rarely go back and change the requirements.  In the real world, software evolves \u2014 new features are added, business rules change, and better algorithms are deployed.  The code needs to be updated accordingly \u2014 adding new variables and new computation; changing how variables are updated or are dependent on each other.  Updating the code of an already-complex software program to keep up with the requirement, if not managed properly, can lead to bugs.</p> <p>Real-world software is often the product of teamwork from multiple programmers, where the software development process is unlike what you have experienced in your introductory programming course, where you solve your homework individually.  When multiple programmers work together, the interdependency between the states needs to be communicated and handled properly and consistently across the programmers.  One programmer's modification to the code should not introduce bugs into another programmer's code.  </p> <p>Since software evolves, the notion of \"multiple programmers\" actually applies even to software developed by a single lone programmer across time.  Changing one's code should not introduce new bugs to other parts of the code that were written some time ago.  </p>"},{"location":"00-overview.html#strategies-to-tame-complexity","title":"Strategies to Tame Complexity","text":""},{"location":"00-overview.html#good-software-development-practices","title":"Good Software Development Practices","text":"<p>Through your introductory programming courses, you are already be familiar with good programming practices that help to tame the complexity and reduce the likelihood of bugs.  These practices include</p> <ul> <li> <p>Commenting your code: Commenting your code provides in situ communication between you and other programmers on the team, as well as between you and your future self, on the non-obvious purpose of the states and the relationships between the states.  Such comments help to enhance the understanding of what the code is doing and to remind whoever is updating to code to modify appropriately when the requirement changes.</p> </li> <li> <p>Using a coding convention: Adhering to a coding convention helps improve code readability, reducing the cognitive barrier when one programmer reads another programmer's code and allowing the reader to understand the code more easily and thoroughly.</p> </li> </ul> <p>CS2030/S will continue to enforce these good programming practices.</p>"},{"location":"00-overview.html#functions","title":"Functions","text":"<p>You should also be taught to always break your code down into functions, each one performing a simple, specific, task.  The functions can then be composed to solve larger and more complex tasks.  Functions are an important programming structure in taming code complexity. They allow programmers to</p> <ol> <li>compartmentalize computation and its effects, reducing the number of interactions to a few well-defined ones (through arguments and return values);</li> <li>hide the implementation details so that they can be changed later without affecting other parts of the code; and</li> <li>reuse computations and thus write code that is more succinct and easier to understand/change.</li> </ol> <p>In CS2030/S, you will not only continue to break your computation into functions, but we will kick it up several notches.  A major part of CS2030/S is to introduce you to more programming paradigms and language tools that allow you to compartmentalize computations, hide details, and reduce repetition.</p>"},{"location":"00-overview.html#the-abstraction-principle","title":"The Abstraction Principle","text":"<p>The last point above about why it is important to code in small, reusable functions, follows what is called the Abstraction Principle.  The principle states that:</p> <p>\"Each significant piece of functionality in a program should be implemented in just one place in the source code. Where similar functions are carried out by distinct pieces of code, it is generally beneficial to combine them into one by abstracting out the varying parts.\" -- Benjamin C. Pierce, \"Types and Programming Languages\"</p> <p>This principle is something that we will visit over and over again in CS2030/S, applying it to different varying parts of a program. In the case of functions, the \"varying parts\" are the values on which we wish to perform the computation.  We will also apply this principle to</p> <ol> <li>types, abstracting them out as parameterized types or subtypes; and</li> <li>sub-computation, abstracting them out as first-class functions.</li> </ol> <p>These concepts: generics, subtypes, and first-class functions, underly most of the content of CS2030/S.</p>"},{"location":"00-overview.html#erecting-an-abstraction-barrier","title":"Erecting an Abstraction Barrier","text":"<p>Another important strategy for taming complexity is the abstraction barrier.  Let's separate the role of a programmer into two, in the context of writing functions: the implementer, who implements the function, and the client, who calls the function.  The implementer should compartmentalize the internal variables and the implementation of the function, hiding them behind the abstraction barrier.  The parameters and the return values are the only communication gateways across the barrier.  </p> <p>The abstraction barrier is something that we will refer to repeatedly in CS2030/S as well.  We will see how we maintain this barrier not only in the context of functions but also variables and computations on these variables together, by encapsulating them as objects and hiding details from the client through access modifiers.  These ideas form two of the core principles of object-oriented programming: encapsulation and abstraction.  </p>"},{"location":"00-overview.html#code-for-change","title":"Code for Change","text":"<p>The abstraction barrier, if erected and maintained properly, reduces code complexity.  It, however, also reduces flexibility as the software evolves.  If the client wishes to modify the computation protected by the abstraction barrier, it will need the help of the implementer.  In CS2030/S, we will see two ways we can modify the computation behind the abstraction barrier, without changing the code behind the barrier.  </p> <p>First, we will introduce the concepts of inheritance and polymorphism, the other two core principles of object-oriented programming.  These object-oriented mechanisms allow programmers to easily extend or modify the behavior of existing code.  </p> <p>Second, we will introduce closure, an abstraction to computation and its environment, that we can pass into the functions behind the abstraction barrier to perform a computation.  The second idea, if carried to the extreme in terms of flexibility, leads to the concept of monad in the functional programming paradigm.  A monad is a computational structure that allows objects to be composed and manipulated in a succinct and powerful way.</p>"},{"location":"00-overview.html#types","title":"Types","text":"<p>Allowing a programmer to change the behavior of the existing code without changing the code could lead to more bugs, if not managed properly.  To prevent this, both the programming language system and the programmers, have to adhere to certain rules when extending or modifying the behavior of the existing code.  Java and many other typed languages have type systems \u2014 a set of rules that govern how variables, expressions, and functions interact with each other.  You will learn about subtyping and the Liskov Substitution Principle, two notions that are important to constraining how inheritance and polymorphism should be used to avoid bugs.</p> <p>A type system is also an important tool to reduce the complexity of software development.  Constraining the interactions among the variables, expressions, and functions, reduces the possible interdependence between these programming constructs.  Furthermore, any attempt by programmers to break the constraint can be caught automatically by the compiler.  By utilizing the type system properly, we can detect potential bugs before they manifest themselves.</p> <p>A reason CS2030/S chooses to use Java is due to its type system.  CS2030/S will introduce the concept of types, subtypes, compile-time vs. runtime types, variants of types, parameterized types, and type inferences, in the context of Java.  We will see how we can define our own types (using classes and interfaces) and define relationships between them.  We will see how we can define parameterized types and generic functions that take in types as parameters.  These concepts apply to many other programming languages.</p>"},{"location":"00-overview.html#eliminating-side-effects","title":"Eliminating Side Effects","text":"<p>We have discussed how functions can compartmentalize computations and limit their complexity within their body.  For this approach to be effective, the function must not have any side effects \u2014 such as updating a variable that is not within the function.  Such functions are called pure functions.  Being side-effect-free is one of the key principles of the functional programming paradigm and is something that we will explore to kick off the section on functional paradigm in CS2030/S.</p> <p>A related idea in object-oriented programming we will cover in CS2030/S is immutability \u2014 once we create an object, the object cannot be changed.  In order to update an object, we need to create a new one.  With immutability and pure functions, we can guarantee that the same function invoked on the same objects will always return the same value.  This certainty can help in understanding and reasoning about the code behavior.</p>"},{"location":"01-compiler.html","title":"Unit 1: Program and Compiler","text":"<p>Learning Objectives</p> <p>After this unit, students should</p> <ul> <li>explain what a program is and why programs written in high-level languages must be translated before execution;</li> <li>distinguish between compilation and interpretation as execution strategies, and describe how modern systems (including Java) combine both;</li> <li>explain how Java programs are compiled and executed using javac, java, bytecode, and the Java Virtual Machine (JVM);</li> <li>interpret tombstone (T-) diagrams to reason about how programs, compilers, interpreters, and machines interact;</li> <li>distinguish between compile-time and runtime errors, and explain the role and limitations of the compiler in detecting errors.</li> </ul> <p>Overview</p> <p>In this course, we will spend a lot of time learning how to design programs so that errors are caught as early as possible, ideally before the program ever runs. Many of the programming constructs you will encounter in CS2030/S, such as strong static typing, generics, immutability, and functional-style programming, exist precisely to help the compiler detect mistakes early and reliably.</p> <p>To understand why these ideas matter, it is important to first understand how programs are executed. A computer\u2019s hardware can only understand instructions written in machine code, yet programmers write programs in high-level languages such as Java. Bridging this gap requires translation, and this translation process\u2014whether done by a compiler, an interpreter, or a combination of both\u2014fundamentally shapes how programs behave, how errors arise, and what kinds of mistakes can be detected automatically.</p> <p>This unit introduces the basic concepts of programs, programming languages, compilers, and interpreters, using Java as the primary example. We will examine how Java programs are compiled and executed, how different execution models can be represented using diagrams, and why the distinction between compile-time and runtime errors is so important in practice.</p> <p>By the end of this unit, you should have a clear mental model of how your Java programs move from source code to execution, and why the compiler plays such a central role in helping programmers write correct and reliable software. This mental model will serve as a foundation for everything else you learn in CS2030/S.</p>"},{"location":"01-compiler.html#software-program","title":"Software Program","text":"<p>A software program is a collection of data variables and instructions on how to modify these variables.  To dictate these instructions to the computer, programmers usually write down the instructions using a programming language, expressing their instructions in code that is made up of keywords, symbols, and names.</p> <p>A programming language is a formal language that helps programmers specify precisely what the instructions are at a higher level of abstraction (i.e., at a higher conceptual level) so that a programmer only needs to write a few lines of code to give complex instructions to the computer.</p>"},{"location":"01-compiler.html#compiled-vs-interpreted-programs","title":"Compiled vs. Interpreted Programs","text":"<p>The processing unit of a computer can only accept and understand instructions written in machine code.  A program, written in a higher-level programming language, therefore needs to be translated into machine code before execution.  There are different approaches to how such translations can be done.  The first approach uses a compiler \u2014 a software tool that reads the entire program written in a higher-level programming language and translates it into machine code.  The machine code is then saved into an executable file, which can be executed later.  <code>clang</code>, a C/C++ compiler, is an example.  The second approach uses an interpreter \u2014 software that reads in the program one statement at a time, interprets what the statement means, and executes it directly.  This is how Python and JavaScript programs are usually executed.  </p> <p>Note that whether a program is compiled or interpreted depends on how the program is executed, and not on the programming language used.  For example, Python is usually interpreted, but there are Python compilers that can compile Python programs into machine code.  Similarly, C/C++ is usually compiled, but there are C/C++ interpreters as well.</p> <p>Furthermore, modern programming systems for executing programs are more sophisticated.  V8, for instance, is an open-source engine that executes JavaScript, and it contains both an interpreter that first interprets a JavaScript program into bytecode (an intermediate, low-level representation) and its execution engine. A just-in-time compiler then reads in the bytecode and generates machine code dynamically at runtime with optimized performance. </p> <p>Java programs, on the other hand, can be executed in two ways:</p> <ol> <li>The Java program can first be compiled into bytecode.  During execution, the bytecode is interpreted and compiled on the fly by the Java Virtual Machine (JVM) into machine code.</li> <li>The Java program can be interpreted by the Java interpreter.</li> </ol> <p>To better understand this distinction, we will introduce a visual aid to describe the relationships between programs, compilers, interpreters, and machines.</p>"},{"location":"01-compiler.html#tombstone-diagrams-t-diagrams","title":"Tombstone Diagrams (T-Diagrams)","text":"<p>Tombstone Diagrams or T-diagrams consist of combinations of the following four components: </p> <ul> <li>Programs which are implemented in a particular language (i.e., <code>Java</code>, <code>Python</code>, <code>C/C++</code>)</li> <li>Language A interpreters implemented in language B</li> <li>Language A to language B Compilers which are implemented in a language C</li> <li>Physical Machines implementing a particular language (i.e., x86-64, ARM-64)</li> </ul> <p>These components are represented in T-diagrams as shown in the figure below:</p> <p>We can treat these components like \"puzzle pieces\" and build diagrams to describe various execution, compilation, or interpreted processes.  For example, in the diagram below, a Python script <code>Hello.py</code> is being interpreted by the Python interpreter running on the x86-64 architecture.</p> <p>Note: In order for the diagram to be valid, adjacent connected diagram components need to match. This can be seen in the diagram below (highlighted with blue boxes).</p> <p>T-diagrams give us a precise way to reason about where translation happens and what language each component understands, which helps avoid confusion when working with multiple tools and platforms.</p>"},{"location":"01-compiler.html#compiler","title":"Compiler","text":"<p>The compiler does more than just translate source code into machine code or bytecode.  The compiler also needs to parse the source code written and check if it follows the precise specification (i.e., the grammar) of the programming language used, and produces a syntax error if the grammar is violated.  It therefore can detect any syntax error before the program is run.</p> <p>The compiler, however, can also perform more sophisticated checks on the source code to detect other types of errors.  Much of the information a compiler uses to detect errors comes from types, which describe what kind of values variables and expressions can take.  We will vist types in the next unit.  These errors are called semantic errors.  A type error, for example, occurs when a programmer tries to perform an operation on a variable that is not allowed according to the variable's type.  For example, trying to multiply a number and a string would result in a type error in Java.</p> <p>It is much better for a programmer to detect any error in its code during compilation \u2014 since this is the phase when the program is still being developed and under the control of the programmer.  Such errors is called compile-time errors.  A runtime error, on the other hand, might occur when the customers are running the program, and so are much less desirable.  As such, we try to detect errors as much as possible during compilation.  The compiler is a powerful friend for any programmer if used properly.  This guiding principle underlies much of the concepts that we will encounter in this course.</p> <p>For instance, in Java, the statement</p> <pre><code>x &lt;- 0\n</code></pre> <p>would lead to a compile-time error, since the assignment operator in Java is <code>=</code> and not <code>&lt;-</code>.  The compiler can easily detect this syntax error without running the program.</p> <p>The power of the compiler, however, is limited.  A compiler can only read and analyze the source code without actually running it.  Without running the program, the compiler cannot always tell if a particular statement in the source code will ever be executed; it cannot always tell what values a variable will take.</p> <p>The following statement in Java, however, follows the correct syntax and would not cause a compile-time error:</p> <pre><code>int x = a / b;\n</code></pre> <p>However, if the value of <code>b</code> is zero at runtime, this statement would lead to a runtime error (division by zero).  The compiler cannot always determine whether <code>b</code> can be zero or not without actually running the program.</p> <p>To deal with this, the compiler can either be conservative, and report an error as long as there is a possibility that a particular statement is incorrect; or the compiler can be more permissive, reporting an error only if there is no possibility that a particular statement is correct.  If there is a possibility that a particular statement is correct, it does not throw an error but relies on the programmer to do the right thing.    Sometimes, the compiler may generate a compilation warning, indicating that there is a potential problem, but it does not prevent the program from being compiled.</p> <p>As you will see in CS2030/S, many Java design choices favor conservative compilation to catch errors early, even if it occasionally rejects code that \"might work.\"  We will further contrast these two behaviors later in this course.</p> <p>We will now look at the two approaches to execute a Java program in more detail (without worrying about how to write a single line of Java first).</p>"},{"location":"01-compiler.html#compiling-and-running-java-programs","title":"Compiling and Running Java Programs","text":"<p>Suppose we have a Java program called <code>Hello.java</code>.  Before we run the program, we first need to compile it.  To compile the program, we type<sup>1</sup></p> <pre><code>$ javac Hello.java\n</code></pre> <p>into the command line.  <code>javac</code> is the Java compiler.  This step will either lead to the bytecode called <code>Hello.class</code> being created or generate some errors.  This process can be seen in the figure below, where the <code>Hello.java</code> program is compiled from Java to the JVM bytecode. The Java compiler <code>javac</code> in this diagram is implemented in the x86-64 machine code.</p> <p>We can run the Java program only after it has been successfully compiled without any errors.  Assuming that there is no error in compilation, we can now run</p> <pre><code>$ java Hello\n</code></pre> <p>to invoke the JVM <code>java</code> and execute the bytecode contained in the file <code>Hello.class</code>. This can be seen in the figure below, where the <code>Hello.class</code> program is interpreted from JVM language (bytecode) to the x86-64 machine code.</p> <p>Passing in filename instead of class name</p> <p>A common mistake is to invoke <code>java</code> with the filename (including the <code>.class</code> extension) instead: <pre><code>$ java Hello.class\n</code></pre></p> <p>This will result in the following error: <pre><code>Error: Could not find or load main class Hello.class\nCaused by: java.lang.ClassNotFoundException: Hello.class\n</code></pre></p> <p>Beginners tend to confuse between <code>javac</code> and <code>java</code>, and whether to add the extension <code>.java</code> or <code>.class</code> when compiling and executing a Java program.  Remember: </p> <ul> <li><code>javac</code> compiles; <code>java</code> runs.</li> <li><code>javac</code> always takes <code>.java</code>; <code>java</code> never takes <code>.class</code>.</li> </ul> <p>java Hello.java</p> <p>To add to the confusion, Java 11 introduces a shortcut where we can run: <pre><code>$ java Hello.java\n</code></pre></p> <p>directly in certain cases.  This command causes <code>Hello.java</code> to be compiled and executed in a single step. This feature is described in more details in the document \"Launching Single-File Source-Code Programs\" from Oracle.</p> <p>We won't do this in CS2030/S (i) to avoid confusion and (ii) to show you the steps explicitly.</p>"},{"location":"01-compiler.html#interpreting-a-java-program","title":"Interpreting a Java program","text":"<p>Java (version 8 or later) comes with an interpreter called <code>jshell</code> that can read Java statements, evaluate them, and print the results<sup>2</sup>. <code>jshell</code> is useful for learning and experimenting with Java.   This can be seen in the figure below, where the <code>Hello.java</code> program is interpreted from Java directly to the x86-64 machine code. </p> <p>To run <code>jshell</code> in interactive mode, we type</p> <pre><code>$ jshell\n</code></pre> <p>on the command line, which causes an interactive prompt to appear:</p> <pre><code>$ jshell\n|  Welcome to JShell -- Version 21.0.5\n|  For an introduction type: /help intro\n\njshell&gt;\n</code></pre> <p>We can now type in Java code on <code>jshell&gt;</code>. </p> <p>Alternatively, we can also include all the Java statements that we want <code>jshell</code> to run in a file and pass it into jshell</p> <pre><code>$ jshell Hello.jsh\n</code></pre> <p>While <code>jshell</code> is a convenient way to test things out and play with new Java concepts as we learn, do keep in mind that <code>jshell</code> combines both compilation and runtime into a single step.  The error spewed out by <code>jshell</code> could be either a compile-time error or a runtime error, and this could be confusing to beginners who try to distinguish between the two phases of program execution.  A compile-time error typically starts with the line <pre><code>|  Error:\n</code></pre> while runtime error starts with the line <pre><code>| Exception ..\n</code></pre></p> <p>jsh vs java</p> <p>Files intended to be run on <code>jshell</code> typically uses <code>.jsh</code> extension while files intended to be compiled and run use <code>.java</code> extension.  However, this difference is merely a convention.  You can still interpret <code>.java</code> program on <code>jshell</code>.</p> <ol> <li> <p>The <code>$</code> represents the command prompt in a shell and you do not need to type this.\u00a0\u21a9</p> </li> <li> <p>Such a program is called REPL (Read-Evaluate-Print in a Loop) for short.\u00a0\u21a9</p> </li> </ol>"},{"location":"02-type.html","title":"Unit 2: Variable and Type","text":"<p>Learning Objectives</p> <p>After this unit, students should be able to:</p> <ul> <li>explain how variables and types act as abstractions over memory and data, and why they are necessary for writing meaningful programs.</li> <li>distinguish between static vs. dynamic typing and strong vs. weak typing, and reason about their consequences for error detection and program safety.</li> <li>identify and apply Java\u2019s primitive types, including their sizes, literal forms, and value semantics.</li> <li>reason about subtyping among Java primitive types and determine whether an assignment or parameter passing is allowed.</li> <li>apply the widening conversion rule (\\(S &lt;: T\\)) to predict and explain compile-time type errors in Java programs.</li> </ul> <p>Overview</p> <p>As programs grow in size and complexity, programmers must manage an increasing number of data values and the operations performed on them. Writing correct programs is not just about syntax\u2014it is about ensuring that operations on data are meaningful and safe.</p> <p>This unit is organised around a central question:</p> <p>How does a programming language help prevent meaningless programs involving data?</p> <p>We begin with variables, which provide an abstraction over memory locations, allowing programmers to name and manipulate data without worrying about where it is stored. </p> <p>A key goal of a programming language is safety, i.e., preventing programs from performing meaningless or invalid operations on variables during execution.  This goal can be achieved through tagging each variable with a type that describes the kind of data it holds and the operations that can be performed on it.  A type-safe language ensures that operations are only applied to values for which they are meaningful.</p> <p>Programming languages differ in how and when they enforce these restrictions. In this unit, we contrast static vs. dynamic typing and strong vs. weak typing, focusing on how Java\u2019s static and strong typing enables the compiler to detect certain errors before a program is run.</p> <p>We then examine Java\u2019s primitive types and the concept of subtyping, which allows limited flexibility while preserving safety. Subtyping explains why some assignments are allowed and others are rejected, leading to the rule of widening type conversion used by the Java compiler.</p>"},{"location":"02-type.html#data-abstraction-variable","title":"Data Abstraction: Variable","text":"<p>One of the important abstractions that are provided by a programming language is the variable.  Data are stored in some location in computer memory.  However, we should not be referring to the memory location all the time.  First, referring to something like a memory address such as <code>0xFA49130E</code> is not user-friendly; Second, the location may change.  A variable is an abstraction that allows us to give a user-friendly name to a piece of data in memory.  We use the variable name whenever we want to access the value in that location, and a pointer to the variable or reference to the variable whenever we wish to refer to the address of the location.</p>"},{"location":"02-type.html#type","title":"Type","text":"<p>As programs get more complex, the number of variables that the programmer needs to keep track of increases.  These variables might be an abstraction over different types of data: some variables might refer to a number, some to a string, some to a list of numbers, etc.  Not all operations are meaningful over all types of data.</p> <p>To help mitigate the complexity,  we can assign a type to a variable.  The type communicates to the readers what data type the variable is an abstraction over, and to the compiler/interpreter what operations are valid on this variable and how the operation behaves.  In lower-level programming languages like C, the type also informs the compiler how the bit representing the variable should be interpreted.</p> <p>As an example of how types can affect how an operation behaves, let's consider Python.  Suppose we have two variables <code>x</code> and <code>y</code>, storing the values <code>4</code> and <code>5</code> respectively and we run <code>print(x + y)</code>.</p> <ul> <li>If <code>x</code> and <code>y</code> are both strings, the output is <code>45</code>.</li> <li>If <code>x</code> and <code>y</code> are both integers, the output is <code>9</code>.</li> <li>If <code>x</code> is an integer and <code>y</code> is a string (or vice versa), you would get an error.</li> </ul> <p>In the last instance above, you see that assigning a type to each variable helps to keep the program meaningful, as the operation <code>+</code> is not defined over an integer and a string in Python.</p> <p>Java and JavaScript, however,  will implicitly convert <code>4</code> into a string and return <code>45</code>.</p>"},{"location":"02-type.html#dynamic-vs-static-type","title":"Dynamic vs. Static Type","text":"<p>Python and JavaScript are examples of dynamically typed programming languages.  The same variable can hold values of different unrelated types, and checking if the right type is used is done during run time (i.e., during the execution of the program).  Note that, the type is associated with the values, and the type of the variable changes depending on the value it holds.  For example, we can do the following:</p> JavaScriptPython Demonstration of Dynamic Typing<pre><code>let i = 4;   // i is an integer\ni = \"5\";     // ok, i is now a string\n</code></pre> Demonstration of Dynamic Typing<pre><code>i = 4        // i is an integer\ni = \"5\"      // ok, i is now a string\n</code></pre> <p>Java, on the other hand, is a statically typed language.  We need to declare every variable we use in the program and specify its type.  A variable can only hold values of the same type as the type of the variable (or its subtype, as you will see later) so we can't assign, for instance, a string to a variable of type <code>int</code>.  Once a variable is declared with a particular type, the type of the variable cannot be changed.  In other words, the variable can only hold values of that declared type.</p> Demonstration of Static Typing<pre><code>int i;   // declare a variable of type int\ni = 4;   // ok because 4 is of type int\ni = \"5\"; // error, cannot assign a string to an `int`\n</code></pre> <p>The type that a variable is assigned when we declare the variable is also known as the compile-time type, or CTT for short.  We sometimes use the notation \\(CTT(v)\\) to denote the compile-time type of a variable \\(v\\). The value stored in the variable has a runtime type.  We use the abbreviation RTT to denote runtime type, and use the notation \\(RTT(v)\\) to denote the runtime type of a variable \\(v\\).</p> <p>During the compilation, the compile-time type is the only type that the compiler is aware of.  The compiler will reason and check if the compile-time types match when it parses the variables, expressions, values, and function calls, and throw an error if there is a type mismatch.  This type-checking step helps to catch errors in the code early.</p> <p>Note that the compiler does not execute the programs it compiles, and thus it cannot reason using the runtime types of the variables.</p>"},{"location":"02-type.html#strong-typing-vs-weak-typing","title":"Strong Typing vs. Weak Typing","text":"<p>A type system of a programming language is a set of rules that governs how the types can interact with each other.</p> <p>A programming language can be strongly typed or weakly typed.  There are no formal definitions of \"strong\" vs. \"weak\" typing of a programming language, and there is a spectrum of \"strength\" between the typing discipline of a language.</p> <p>Generally, a strongly typed programming language enforces strict rules in its type system, to ensure type safety, i.e., to guarantee that operations are only applied to values of appropriate types, preventing certain classes of runtime errors.  For instance, catching an attempt at multiplying two strings.  One way to ensure type safety is to catch type errors during compile time rather than leaving it to run time.</p> <p>On the other hand, a weakly typed (or loosely typed) programming language is more permissive in terms of typing checking.  C is an example of a static, weakly typed language.  In C, the following is possible:</p> Demonstration of Weak Typing in C<pre><code>int i;        // declare a variable of type int\ni = 4;        // ok because 4 is of type int\ni = (int)\"5\"; // you want to treat a string as an int? ok, as you wish!   \n</code></pre> <p>The last line forces the C compiler to treat the string (to be more precise, the address of the string) as an integer, through typecasting.</p> <p>In contrast, if we try the following in Java:</p> Demonstration of Strong Typing in Java<pre><code>int i;        // declare a variable of type int\ni = 4;        // ok because 4 is of type int\ni = (int)\"5\"; // error\n</code></pre> <p>we will get the following compile-time error message:</p> <pre><code>|  incompatible types: java.lang.String cannot be converted to int\n</code></pre> <p>because the compiler enforces a stricter rule and allows typecasting only if it makes sense.  More specifically, we will get a compilation error if the compiler can determine with certainty that such conversion can never happen successfully.</p>"},{"location":"02-type.html#type-checking-with-a-compiler","title":"Type Checking with A Compiler","text":"<p>In addition to checking for syntax errors, the compiler can check for type compatibility according to the compile-time type, to catch possible errors as early as possible.  Such type-checking is made possible with static typing.  Consider the following Python program:</p> Dynamic Typing Leads to Runtime Error<pre><code>i = 0\nwhile (i &lt; 10):\n  # do something that takes a long time\n  i = i + 1\nprint(\"i is \" + i) // error after a long execution\n</code></pre> <p>Since Python does not allow adding a string to an integer, there is a type mismatch error on Line 5.  The type mismatch error is only caught when Line 5 is executed after the program executes for a long time.  Since the type of the variable <code>i</code> can change during run time, Python (and generally, dynamically typed languages) cannot tell if Line 5 will lead to an error until it is evaluated during run time.</p> <p>In contrast, statically typed language like Java can detect type mismatch during compile time since the compile-time type of a variable is fixed.  As you will see later, Java allows \"addition\" or string and integer, but not multiplication of a string and an integer.  If we have the following code, Java can confidently produce compilation errors without even running a program: </p> Static Typing Catches Type Mismatch Early<pre><code>int i = 0\nwhile (i &lt; 10) {\n  // do something that takes a long time\n  i = i + 1;\n}\nString s = \"i is \" * i; // error during compilation\n</code></pre>"},{"location":"02-type.html#primitive-types-in-java","title":"Primitive Types in Java","text":"<p>We now switch our focus to Java, particularly to the types supported.  There are two categories of types in Java, the primitive types and the reference types.  We will first look at primitive types in this unit.</p> <p>Primitive types are types that hold numeric values (integers, floating-point numbers) as well as boolean values (<code>true</code> and <code>false</code>).</p> <p>For storing integral values, Java provides four types, <code>byte</code>, <code>short</code>, <code>int</code>, and <code>long</code>, for storing 8-bit, 16-bit, 32-bit, and 64-bit signed integers respectively.  The type <code>char</code> stores 16-bit unsigned integers representing UTF-16 Unicode characters.</p> <p>For storing floating-point values, Java provides two types, <code>float</code> and <code>double</code>, for 32-bit and 64-bit floating-point numbers.</p> <p>Unlike reference types, which we will see later, primitive type variables never share their value with each other, i.e., if we have: <pre><code>int i = 1000;\nint j = i;\ni = i + 1;\n</code></pre></p> <p><code>i</code> and <code>j</code> each store a copy of the value <code>1000</code> after Line 2.  Changing <code>i</code> on Line 3 does not change the content of <code>j</code>.</p> Kinds Types Sizes (in bits) Boolean <code>boolean</code> JVM dependent<sup>1</sup> Character <code>char</code> 16 Integral <code>byte</code> 8 <code>short</code> 16 <code>int</code> 32 <code>long</code> 64 Floating-Point <code>float</code> 32 <code>double</code> 64 <p>Long and Float Constant</p> <p>By default, an integer literal (e.g., <code>67</code>) is assigned an <code>int</code> type. To differentiate between a <code>long</code> and an <code>int</code> constant, you can use the suffix <code>L</code> to denote that the value is expected to be of <code>long</code> type (e.g., <code>67L</code> is a <code>long</code>).  This is important for large values beyond the range of <code>int</code>.  On the other hand, if the constant is a floating-point constant (e.g., <code>20.30</code>), by default it is treated as type <code>double</code>.  You need to add the suffix <code>f</code> to indicate that the value is to be treated as a <code>float</code> type (e.g., <code>20.30f</code> is a <code>float</code>).</p>"},{"location":"02-type.html#subtypes","title":"Subtypes","text":"<p>An important concept that we will visit repeatedly in CS2030/S is the concept of subtypes.</p> <p>Let \\(S\\) and \\(T\\) be two types.  We say that \\(T\\) is a subtype of \\(S\\) if a piece of code written for variables of type \\(S\\) can also safely be used on variables of type \\(T\\).</p> <p>We use the notation \\(T &lt;: S\\) or \\(S :&gt; T\\) to denote that \\(T\\) is a subtype of \\(S\\).  The subtyping relationship in general must satisfy two properties:</p> <ol> <li>Reflexive: For any type \\(S\\), we have \\(S &lt;: S\\) (i.e., \\(S\\) is a subtype of itself).</li> <li>Transitive: If \\(S &lt;: T\\) and \\(T &lt;: U\\), then \\(S &lt;: U\\).  In other words, if \\(S\\) is a subtype of \\(T\\) and \\(T\\) is a subtype of \\(U\\), then \\(S\\) is a subtype of \\(U\\).</li> </ol> <p>Additionally, in Java, you will find that the subtyping relationship also satisfies anti-symmetry.  However, this is often omitted as it is enforced by design.</p> <ul> <li>Anti-Symmetry: If \\(S &lt;: T\\) and \\(T &lt;: S\\), then \\(S\\) must be the same type as \\(T\\).</li> </ul> <p>Related to the subtype relationship, </p> <ul> <li>We use the term supertype to denote the reversed relationship: if \\(T\\) is a subtype of \\(S\\), then \\(S\\) is a supertype of \\(T\\).</li> <li>In specific scenarios, we use the term proper subtype (or \\(&lt;\\)) to denote a stricter subtyping: if \\(T &lt;: S\\) and \\(T \\not = S\\), then \\(T\\) is a proper subtype of \\(S\\), denoted as \\(T &lt; S\\).</li> </ul>"},{"location":"02-type.html#subtyping-between-java-primitive-types","title":"Subtyping Between Java Primitive Types","text":"<p>Considering the range of values that the primitive types can take, Java defines the following subtyping relationship:</p> <ul> <li><code>byte</code> &lt;: <code>short</code> &lt;: <code>int</code> &lt;: <code>long</code> &lt;: <code>float</code> &lt;: <code>double</code></li> <li><code>char</code> &lt;: <code>int</code></li> </ul> <p>Graphically, we can draw the subtyping relationship as an arrow from subtype to supertype.  In the case of Java primitive types, we can visualise the subtyping relationship as follows:</p> <p> byte short int long float double char </p> <p>Long \\(&lt;:\\) Float?</p> <p>Why is <code>long</code> a subtype of <code>float</code>?  More specifically, <code>long</code> is 64-bit, and <code>float</code> is only 32-bit.  There are more values in <code>long</code> than in <code>float</code>.</p> <p>The resolution lies in the range of values that can be represented with <code>float</code> and <code>long</code>. <code>long</code> can represent every integer between -2<sup>63</sup> and 2<sup>63</sup>-1, a 19-digit number.  <code>float</code>, however, can represent floating point numbers as big as 38 digits in the integral part (although it can not represent every floating point number and every integer values within the range).</p> <p>Thus, a piece of code written to handle <code>float</code> can also handle <code>long</code> (since all <code>long</code> values can be represented with a <code>float</code>, albeit with possible loss of precision).</p> Code that Handles `float` can also Handle `long`<pre><code>float add(float x) {\n  return x + x;\n}\n\nlong x = 9223372036854775807L; \nfloat y = add(x); // ok\n</code></pre> <p>On the other hand, if a piece of code is written to handle <code>long</code>, then giving it a <code>float</code> value would be erroneous since the <code>float</code> value might have more than 19 digits in the integral part and cannot be represented by <code>long</code>.</p> Code that Handles `long` cannot Handle `float`<pre><code>long add(long x) {\n  return x + x;\n}\n\nfloat x = 3.4e+38f;\nlong y = add(x); // error: incompatible types: possible lossy conversion from float to long\n</code></pre> <p>Subtyping is about whether a piece of code written for one type can also be used for another type safely.  It is not about the size (in bits) of the types.</p> <p>Valid subtype relationship is part of what the Java compiler checks for when it compiles.  Consider the following example:</p> Subtyping in Assignment<pre><code>double d = 5.0;\nint i = 5;\nd = i; // ok\ni = d; // error\n</code></pre> <p>Line 4 above would lead to an error:</p> <pre><code>|  incompatible types: possible lossy conversion from double to int\n</code></pre> <p>but Line 3 is OK.</p> <p>To understand why, let's consider the compile-time type of <code>d</code> and <code>i</code>. The compile-time type of the variable <code>d</code> is <code>double</code> because that is what we declared it as.  Similarly, the compile-time type of the variable <code>i</code> is <code>int</code>.  <code>double</code> can hold a larger range of values than <code>int</code>, thus all values that can be represented by <code>i</code> can be represented by <code>d</code> (with possible loss of precision).  Using the terminology that you just learned, <code>double</code> is a supertype of <code>int</code>.  </p> <p>On Line 3, the Java compiler allows the value stored inside <code>i</code> to be copied to <code>d</code>.  The worst that could happen is that we lose a bit of precision.  On Line 4, however, we try to copy the value stored in <code>d</code> to <code>i</code>.  Since <code>d</code> is a <code>double</code>, it can store a value outside the range supported by <code>i</code> and can have order of magnitudes difference between them.  This would be a problem if the code is allowed to execute!</p> <p>This example shows how subtyping applies to type checking.  Java allows a variable of type \\(T\\) to hold a value from a variable of type \\(S\\) only if \\(S &lt;: T\\).  This step is called widening type conversion.  Such widening type conversion can happen during assignment or parameter passing.</p> <p>The term \"widening\" is easy to see for primitive types --  the subtype has a narrower range of values than the supertype. The opposite conversion is called narrowing because the range of values is narrower.</p> <p>Some of the readers might notice that, in the example above, the value of <code>d</code> is 5.0, so, we can store the value as <code>5</code> in <code>i</code>, without any loss.  Or, in Line 3, we already copied the value stored in <code>i</code> to <code>d</code>, and we are just copying it back to <code>i</code>?   Since the value in <code>d</code> now can be represented by <code>i</code>, what is wrong with copying it back?  Why doesn't the compiler allow Line 4 to proceed?</p> <p>The reason is that the compiler does not execute the code (which is when assigning 5.0 to <code>d</code> happens) and it (largely) looks at the code, statement-by-statement. Thus, the line <code>i = d</code> is considered independently from the earlier code shown in the example.  In practice, Line 4 might appear thousands of lines away from earlier lines, or may even be placed in a different source file.  The values stored in <code>d</code> might not be known until run time (e.g., it might be an input from the user).</p>"},{"location":"02-type.html#additional-readings","title":"Additional Readings","text":"<ul> <li>Java Tutorial: Primitive Data Types and other Language Basics</li> </ul> <ol> <li> <p>While a boolean conceptually represents a single bit of information, its storage size typically varies in practice due to hardware efficiency considerations.  Java specification leaves it unspecified and up to the JVM implementation.\u00a0\u21a9</p> </li> </ol>"},{"location":"03-function.html","title":"Unit 3: Functions","text":"<p>Learning Objectives</p> <p>After completing this unit, students should be able to:</p> <ul> <li>explain functions as an abstraction mechanism that separates what a computation does from how it is implemented.</li> <li>define and use functions in Java with appropriate parameters and return types, including void, to structure computation.</li> <li>reason about programs using the abstraction barrier, distinguishing the responsibilities of a client from those of an implementer.</li> <li>use functions to reduce code complexity through locality, information hiding, and reuse.</li> <li>identify violations of the abstraction barrier and explain why they lead to brittle or error-prone code.</li> </ul> <p>Overview</p> <p>As programs grow larger, complexity becomes the primary challenge.  One of the most fundamental tools for managing this complexity is the function.</p> <p>At first glance, a function may seem like nothing more than a convenient way to group statements and give them a name. But in CS2030/S, we are interested in a deeper role that functions play: functions are an abstraction over computation. They allow us to separate what a piece of code is supposed to do from how it does it.  </p> <p>This separation is crucial for two reasons. First, it allows us to reason about programs at a higher level without being overwhelmed by low-level details. Second, it enables collaboration and change. In real software systems, different programmers often work on different parts of a program. Some implement functionality, while others use it. Functions provide a clear boundary that allows these roles to be separated cleanly.</p> <p>In this unit, we will study functions as a design tool. You will learn how functions reduce complexity, enable code reuse, and support information hiding.  You will see that a function is not just a way to reuse code, but it is a promise that enables independent reasoning, change, and collaboration.  More importantly, you will begin to think explicitly in terms of two roles: the implementer, who defines how a function works, and the client, who relies only on what the function promises to do.  This way of thinking will form the foundation for later abstractions in the course. </p>"},{"location":"03-function.html#function-as-an-abstraction-over-computation","title":"Function as an Abstraction over Computation","text":"<p>An important abstraction provided by a programming language is the function (also known as method or procedure).  This abstraction allows programmers to group a set of instructions and give the group a name.  The named set of instructions may take one or more variables as input parameters, and return zero or one value.</p> <p>Like all other abstractions, defining functions allows us to think at a higher conceptual level.  By composing functions at increasingly higher levels of abstraction, we can build programs with increasing levels of complexity.</p> <p>Every function can be understood in terms of a specification: a description of what the function is supposed to do, expressed in terms of its parameters and return value.  In Java, a function is a typed abstraction.  This means that both the input parameters and the return value of a function have types associated with them.  This typing defines how the rest of the program may interact with the function.  </p> <p>Abstraction also makes programs easier to test and reason about. Because a function interacts with the rest of the program only through its parameters and return value, it can be tested independently of the rest of the system.</p>"},{"location":"03-function.html#defining-a-function-in-java","title":"Defining a Function in Java","text":"<p>Let's look at how we can define a function (or method in Java terminology) in Java.  Note that the Java examples below are not complete programs and are merely snippets.  As such, they cannot be compiled.  But, we can type them into JShell to interpret and execute them.</p> <p>The basic syntax of a function is as follows:</p> Syntax of a Java Function<pre><code>return_type function_name(param_type1 param1, param_type2 param2) {\n  function body\n}\n</code></pre> <p>Note that the return type and parameter types must be explicitly stated in Java, as they enforces the contract betwteen the caller and the function.  The caller knows what kind of inputs are allowed and what kind of results can be expected.  The function (or programmer of the function) knows what kind of assumptions can be made about the inputs and what kind of outputs must be produced.</p> <p>For example, the following function is named <code>factorial</code>.  It takes in a parameter <code>n</code> of type  <code>int</code> and returns a result of type <code>int</code>.</p> Simple Java Function<pre><code>int factorial(int n) {\n  if (n == 0) {\n    return 1;\n  } \n  return n * factorial(n - 1);\n}\n</code></pre> <p>In the case where a function does not return anything, we still need to specify the return type.  In this case, we use a type called <code>void</code><sup>1</sup>.  </p> <p>Note that, unlike Python, Java does not allow returning more than one value.</p> <p>Note that the type <code>int</code> alone does not capture all assumptions about valid inputs. For example, factorial is typically defined only for non-negative integers. Such assumptions form part of the function's specification and must be respected by the client.</p>"},{"location":"03-function.html#reducing-code-complexity-with-function","title":"Reducing Code Complexity With Function","text":"<p>Functions help us deal with complexity in a few ways.</p> <ul> <li> <p>Functions allow programmers to compartmentalize computation and its effects.  We can isolate the complexity within its body: the intermediate variables exist only as local variables that have no effect outside of the function.  A function only interacts with the rest of the code through its parameters and return value, and so, reduces the dependencies between variables to these well-defined interactions.  Such compartmentalization reduces the complexity of code.</p> </li> <li> <p>Functions allow programmers to hide how a task is performed.  The caller of the function only needs to worry about what the function does.  By hiding the details of how, we gain two powerful tools against code complexity.  First, we reduce the amount of information that we need to communicate among programmers.  A fellow programmer only needs to read the documentation to understand what the parameters are for, and what the return values are.  There is no need for a fellow programmer to know about the intermediate variables or the internal computation used to implement the functions.  Second, as the design and requirements evolve, the implementation of a function may change.  But, as long as the parameters and the return value of a function remain the same, the caller of the function does not have to update the code accordingly.  Reducing the need to change as the software evolves reduces the chances of introducing bugs accordingly.</p> </li> <li> <p>Functions allow us to reduce repetition in our code through code reuse.  If we have the same computation that we need to perform repeatedly on different values, we can construct these computations as functions by replacing the values with parameters and passing in the values as arguments to the function.  This approach reduces the amount of boiler-plate code and has two major benefits in reducing code complexity and bugs.  First, it makes the code more succinct, and therefore easier to read and understand.  Second, it reduces the number of places in our code that we need to modify as the software evolves, and therefore, decreases the chance of introducing new bugs.</p> </li> </ul> <p>Consider the example function below, which approximates \\(e^n\\) using a Taylor series.  You can ignore how the math works; focus on what the caller sees.\u201d</p> A Function to Estimate e^n<pre><code>double exp(int n) { \n  double x = 1;\n  double res = 0;\n  for (int i = 0; i &lt; 10; i += 1) {\n    res += (x/factorial(i));\n    x *= n;\n  }\n  return res;\n}\n</code></pre> <p>The computation above involves three intermediate variables, <code>i</code>, <code>x</code> and <code>res</code>.  These variables are local to the function and are not exposed to the caller of the function.  Thus, the caller has three less variables to keep track of and worry about.  The caller of the function does not know how the estimation was done -- Does it use a <code>for</code> loop or a <code>while</code> loop?   Does it calculate it recursively? How many terms in the Taylor's series are used, etc.  The caller only needs to know that the function <code>exp</code> takes an integer <code>n</code> as input and returns a <code>double</code> as output.  Finally, every time we need to estimate \\(e^n\\), we can call the function <code>exp</code> with the value of <code>n</code> as an argument, without repeatedly writing the same loop.  You can also see that <code>exp</code> reuses the function <code>factorial</code> that we defined earlier.</p>"},{"location":"03-function.html#abstraction-barrier","title":"Abstraction Barrier","text":"<p>We can imagine an abstraction barrier between the code that calls a function and the code that defines the function body.  Above the barrier, the concern is about what task a function performs, while below the barrier, the concern is about how the function performs the task.</p> <p>While many of you are used to writing a program solo, in practice, you rarely write a program with contributions from only a single person.  The abstraction barrier separates the role of the programmer into two: (i) an implementer, who provides the implementation of the function, and (ii) a client, who uses the function to perform the task.  Part of the aim of CS2030/S is to switch your mindset into thinking in terms of these two roles.  In fact, in CS2030/S, you will be both but may be restricted to just being either a client or an implementer on specific functionality.</p> <p>The abstraction barrier thus enforces a separation of concerns between the two roles.  When using a function, a programmer must act as a client.  The client does not have to care how the implementer implements the functionality.  This gives the implementer the freedom and flexibility to change how the function is implemented, without affecting the client, as long as the behavior of the function remains unchanged.  When defining a function, a programmer acts as an implementer.  The implementer is free to change the implementation at any time, as long as the specified behavior is preserved.  The implementer does not have to care how the client is using the function.</p> <p>In Java, the abstraction barrier of a function is enforced primarily through its parameter types and return type, which restrict how clients may use the function and how implementers may define it.</p> <p>The same ideas: abstraction barriers, specifications, and separation of roles, will reappear throughout the rest of the course in increasingly powerful forms.  We will see how it is used for a higher level of abstraction, classes, in the next unit.</p> <ol> <li> <p><code>void</code> in Java is like a true nothingness (unlike Python's <code>None</code> or JavaScript's <code>undefined</code>).  If a function is declared as returning a type <code>void</code>, it cannot even be used in an assignment!\u00a0\u21a9</p> </li> </ol>"},{"location":"04-encapsulation.html","title":"Unit 4: Encapsulation","text":"<p>Learning Objectives</p> <p>After this unit, students should be able to:</p> <ul> <li>explain encapsulation as the bundling of data with the methods that operate on that data, and its role in maintaining an abstraction barrier.</li> <li>define simple Java classes and objects, identifying the roles of fields and methods.</li> <li>model simple problem domains using classes, and justify basic design choices (e.g., class vs primitive or <code>String</code>).</li> <li>explain and predict the behavior of reference types in Java, including aliasing and shared mutable state.</li> <li>recognize and avoid common errors involving references, including uninitialized (<code>null</code>) references.</li> </ul> <p>Overview</p> <p>This unit introduces encapsulation, a key abstraction mechanism in object-oriented programming.  Encapsulation builds on composite data types by bundling data together with the operations that manipulate that data, forming a clear abstraction barrier between implementation and usage.</p> <p>In Java, encapsulation is realized through classes and objects, which also introduce reference semantics. Understanding encapsulation is essential not only for writing correct programs, but also for reasoning about program design, modularity, and later concepts such as immutability and interfaces.</p>"},{"location":"04-encapsulation.html#abstraction-composite-data-type","title":"Abstraction: Composite Data Type","text":"<p>Just like functions allow programmers to group instructions, give it a name, and refer to it later, a composite data type allows programmers to group primitive types together, give it a name to become a new type, and refer to it later.  This is another powerful abstraction in programming languages that helps us to think at a higher conceptual level without worrying about the details.   Commonly used examples are mathematical objects such as complex numbers, 2D data points, multi-dimensional vectors, circles, etc, or everyday objects such as a person, a product, etc.</p> <p>Defining a composite data type allows programmers to abstract away from  concerns about how a complex data type is represented.</p> <p>For instance, a circle on a 2D plane can be represented by the center (i.e., <code>x</code>, <code>y</code>) and its radius <code>r</code>, or it can be represented by the top left corner (i.e., <code>x</code>,<code>y</code>) and the width <code>w</code> of the bounding square.</p> <p>In C, we build a composite data type with <code>struct</code>.  For example,</p> A C struct to Represent a Circle<pre><code>typedef struct {\n  double x, y; // (x,y) coordinate of the center.\n  double r;    // radius\n} circle;\n</code></pre> <p>Once we have the <code>struct</code> defined, we have a new data type called <code>circle</code>.  However, we are not completely shielded from its representation, until we write a set of functions that operates on the <code>circle</code> composite type.  For instance,</p> C Functions to Operate on Circle<pre><code>double circle_area(circle c) { ... };\nbool   circle_contains_point(circle c, double x, double y) { ... };\nbool   circle_overlaps(circle c1, circle c2) { ... };\n  :\n</code></pre> <p>Implementing these functions requires knowledge of how a circle is represented.  The implementation will be different if we have a different representation of <code>circle</code> (e.g., <code>x</code> and <code>y</code> may represent the center of the circle or the top left corner of the bounding square).  But once the set of functions that operates on it is available, we can use the circle type without worrying about the internal representation.  Of course, this assumes that we will only use the functions specifically written to work on circle type.</p> <p>Additionally, the example on <code>circle_overlap</code> highlights another advantage of having a composite data type.  To see the advantage, imagine that you do not have the data type <code>circle</code>.  Then the function to check if two circles overlap would require 6 parameters.</p> <pre><code>bool circle_overlaps(double x1, double y1, double r1,\n    double x2, double y2, double r2) { ... };\n  :\n</code></pre> <p>We have used a nice numbering to clearly indicate how the parameters are related.  Those with the same suffix belong to the same circle.  But another programmer may instead write it in a different order.</p> <pre><code>bool circle_overlaps(double x1, double x2,\n    double y1, double y2, double r1, double r2) { ... };\n  :\n</code></pre> <p>Even worse, less careful programmers may even omit the suffix and make the entire code unreadable.  So the use of composite data type is like a \"glue\" that binds relevant data together.  That way, we know that all the elements that make up a circle will always be together.</p> <p>If we decide to change the representation of a circle, then only the set of functions that operate on a circle type need to be changed, but not the code that uses circles to do other things.  In other words, the representation of the circle and the set of functions that operate on and manipulate circles, should fall on the same implementer side of the abstraction barrier.</p>"},{"location":"04-encapsulation.html#abstraction-class-and-object-or-encapsulation","title":"Abstraction: Class and Object (or, Encapsulation)","text":"<p>The bundling of the composite data type and its associated functions forms another abstraction called a class.</p> <p>We call the data in the class as fields (also called states, attributes, or properties<sup>1</sup>).  The associated functions are called methods.  A well-designed class maintains the abstraction barrier, properly wraps the barrier around the internal representation and implementation, and exposes just the right method interface for others to use.</p> <p>The concept of keeping all the data and functions operating on the data related to a composite data type together within an abstraction barrier is called encapsulation.</p> <p>Let's see how we can encapsulate the fields and methods associated together, using <code>Circle</code> as an example, in Java.</p> Circle v0.1<pre><code>class Circle {\n  double x;\n  double y;\n  double r;\n\n  double getArea() {\n    return 3.141592653589793 * r * r;\n  }\n}\n</code></pre> <p>The code above defines a new class using the keyword <code>class</code>, gives it a name <code>Circle</code><sup>2</sup>, followed by a block listing the member variables (with types) and the function definitions.</p> <p>Just like we can create variables of a given type, we can create objects of a given class.  Objects are instances of a class, each allowing the same methods to be called, and each containing the same set of variables of the same types, but (possibly) storing different values.</p> <p>In Java, the keyword <code>new</code> creates an object of a given class.  For instance, to create a <code>Circle</code> object, we can use</p> Using the Circle class<pre><code>Circle c = new Circle();\nc.r = 10;    // set the radius to 10\nc.getArea(); // return 314.1592653589793\n</code></pre> <p>To access the fields and the methods, we use the <code>.</code> notation.  For example, <code>object.field</code> or <code>object.method(..)</code>.  This can be seen in Line 2 and Line 3 of the example above.  We refer to <code>object</code> as the target of the method call.</p> <p>A class is responsible for maintaining the consistency of its own data.  For instance, if the radius of a circle changes, its area should change accordingly.  Encapsulation helps to maintain this consistency by bundling the data and the methods that operate on the data together.</p>"},{"location":"04-encapsulation.html#a-bad-example","title":"A Bad Example","text":"<p>Let us take a moment to appreciate the example <code>Circle</code> v0.1 above.  This is a reasonable example as the method <code>getArea</code> is computing the area of the circle with the radius as specified in the field <code>r</code>.  So, we can clearly see that the method is associated with the data.  Let's now add another method <code>factorial</code> to <code>Circle</code>:</p> Circle v0.1a with Irrelevant Method<pre><code>class Circle {\n  double x;\n  double y;\n  double r;\n\n  double getArea() {\n    return 3.141592653589793 * r * r;\n  }\n\n  int factorial(int x) {  \n    return (x == 0) ? 1 : x * factorial(x - 1);\n  }\n}\n</code></pre> <p>The method <code>factorial</code> is irrelevant to the class <code>Circle</code>.   It is not associated with and does not utilize the fields in the class.  Furthermore, <code>factorial</code> is a useful method that can be used in a general context, not specific to the <code>Circle</code> class.  This is a bad example of encapsulation.</p> <p>As a rule of thumb, a method belongs in a class if it conceptually operates on or is responsible for the state represented by that class.  </p>"},{"location":"04-encapsulation.html#object-oriented-programming","title":"Object-Oriented Programming","text":"<p>A program written in an object-oriented language such as Java consists of classes, with one main class as the entry point.  One can view a running object-oriented (or OO) program as something that instantiates objects of different classes and orchestrates their interactions with each other by calling each other's methods.</p> <p>One could argue that an object-oriented way of writing programs is much more natural, as it mirrors our world more closely.  If we look around us, we see objects all around us, and each object has certain properties, exhibits certain behaviors, and allows certain actions.  We interact with the objects through their interfaces, and we rarely need to know the internals of the objects we use every day (unless we try to repair them)<sup>3</sup>.</p> <p>To model a problem in an object-oriented manner, we typically model the nouns as classes and objects, the properties or relationships among the classes as fields, and the verbs or actions of the corresponding objects as methods.</p> <p>Take, for example, the following partial problem description about an online airline reservation system.</p> <p>Users need to be able to make bookings from an origin to a destination airport which may comprise multiple connecting flights. We record the booking date.  Airport are identified by their airport code.</p> <p>We can identify the following from the problem description.</p> Nouns Properties Associated Verbs User Bookings made Make booking Booking Bookings date Origin airport Destination airport Airport Code <p>From here, we can try to model the problem in OOP using three classes: <code>User</code>, <code>Booking</code>, and <code>Airport</code>.  </p> Partial Modelling of the Airline Reservation System v0.1<pre><code>class User {\n  Booking booking;\n\n  void makeBooking(Airport origin, Airport destination, Date date) {\n    :\n  }\n}\n\nclass Airport {\n  String code;\n    :\n}\n\nclass Booking {\n  Date date;\n  Airport origin;\n  Airport destination;\n    :\n}\n</code></pre> <p>For each property, we encapsulate them as fields in the respective class.  For verb <code>make booking</code>, we encapsulate a method in the <code>User</code> class.</p> <p>Can the model be simplified?  Suppose that we are sure we never need to store anything more than the airport code in <code>Airport</code>, then we can simplify the model by using a <code>String</code> instead of an <code>Airport</code> class.</p> Partial Modelling of the Airline Reservation System v0.2<pre><code>class User {\n  Booking booking;\n\n  Booking makeBooking(String originAirport, String destinationAirport, Date date) {\n    :\n  }\n}\n\nclass Booking {\n  Date date;\n  String origin;\n  String destination;\n    :\n}\n</code></pre> <p>However, if we want to leave open the possibility that we may need to store more information about an airport in the future (e.g., location, name), then it is better to model it as a class even if it contains only a single property for now.</p> <p>In the discussion above, we put forward the possibility that <code>Airport</code> need not be a class.  So the question is, when should we stop modelling a noun as a class?  We may be too eager to model everything as a class, including the date to be stored as booking date.  There is also the opposite problem of too lazy to model.  For instance, we may lazily group user and booking together to form a class with 4 fields.</p> <p>There is no clear answer to this but as a general guide, you can ask the following questions:</p> <ul> <li>Is there multiple properties to be stored?<ul> <li>If so, then creating a class is good.</li> <li>In the case of airport, if there is only a single data, then we need not make a class.</li> </ul> </li> <li>Is there an action associated with the entity?<ul> <li>If so, then creating a class is good.</li> <li>In the case of user, although it only has a single property, it has an association action.</li> </ul> </li> <li>Is there a real world counterpart?<ul> <li>If so, model it based on the real world.</li> <li>In the case of user and booking, we have real world counterpart so we model them as separate classes.</li> </ul> </li> <li>Is there potential changes to the entity?<ul> <li>If so, then creating a class is good.</li> <li>For instance, if in the future we plan to store more information about an airport (e.g., the country it is located, etc), then having it as a class will minimize potential changes to other parts of the code (e.g., if we used <code>String</code> before, we now have to change all these <code>String</code> into <code>Airport</code>).</li> </ul> </li> </ul> <p>The guide above are not exhaustive.  But they are still a good starting point if this is your first attempt at modelling in OOP.</p>"},{"location":"04-encapsulation.html#reference-types-in-java","title":"Reference Types in Java","text":"<p>We mentioned in Unit 2 that there are two kinds of types in Java.  You have been introduced to the primitive types.  Everything else in Java (i.e., all objects) is a reference type.</p> <p>The <code>Circle</code> class is an example of a reference type.  Unlike primitive variables, which never share the value, a reference variable stores only the reference to the value, and therefore two reference variables can share the same value.  For instance,</p> Sharing a Circle Object<pre><code>Circle c1 = new Circle();\nCircle c2 = c1;\nSystem.out.println(c2.r); // print 0\nc1.r = 10.0;\nSystem.out.println(c2.r); // print 10.0\n</code></pre> <p>The behavior above is due to the variables <code>c1</code> and <code>c2</code> referencing the same <code>Circle</code> object in the memory.  Therefore, changing the field <code>r</code> of <code>c1</code> causes the field <code>r</code> of <code>c2</code> to change as well.</p> <p>Sharing objects through references can lead to unintended side effects, and is a major source of bugs in object-oriented programs.</p>"},{"location":"04-encapsulation.html#special-reference-value-null","title":"Special Reference Value: <code>null</code>","text":"<p>All local variables in Java must be initialized before use.  The compiler will issue an error if the code attempts to use a local variable without initalization.   For instance,</p> <p>Using Uninitialized Local Variable<pre><code>void foo() {\n  Circle c1;\n  c1.r = 10.0; // error: variable c1 might not have been initialized\n}\n</code></pre> The line <code>c1.r = 10.0;</code> will lead to a compile-time error because <code>c1</code> is a local variable that has not been initialized.</p> <p>For fields, however, Java will auto-initialize them to default values.  For primitive fields, the default values are <code>0</code> for numeric types, <code>false</code> for <code>boolean</code>, and <code>'\\u0000'</code> for <code>char</code>.  For reference fields, the default value is a special reference value <code>null</code>.</p> <p>A <code>null</code> reference means \u201cthis variable does not refer to any object\u201d.  Attempting to access fields or methods through <code>null</code> fails because there is no object to operate on.</p> <p>A common error for beginners is to declare a reference variable and try to use it without instantiating an object.  Consider the snippet below (assuming they are part of a class).</p> Using Uninitialized Reference Field<pre><code>class MyClass {\n  Circle c1;    // field in a class is initialized to null\n    :\n  void foo() {\n    c1.r = 10.0;  // changing the field lead to error\n  }\n}\n</code></pre> <p>The line <code>c1.r = 10.0;</code>  would lead to a runtime error message <pre><code>|  Exception java.lang.NullPointerException\n</code></pre></p> <p>Remember to always instantiate a reference variable before using it.</p> <p>JShell Caveat</p> <p>In JShell, reference variables declared at the top-level are automatically initialized to <code>null</code>.  This is different from local variables inside methods, which must be explicitly initialized before use.  Be aware of this difference when working in JShell.</p>"},{"location":"04-encapsulation.html#further-readings","title":"Further Readings","text":"<ul> <li>Oracle's Java Tutorial on Classes and Objects.</li> </ul> <ol> <li> <p>Computer scientists just could not decide what to call this :(\u00a0\u21a9</p> </li> <li> <p>As a convention, we use PascalCase for class names and camelCase for variable and method names in Java.\u00a0\u21a9</p> </li> <li> <p>This is a standard analogy in an OOP textbook.  In practice, however, we often have to write programs that include abstract concepts with no tangible real-world analogy as classes.\u00a0\u21a9</p> </li> </ol>"},{"location":"05-infohiding.html","title":"Unit 5: Information Hiding","text":"<p>Learning Objectives</p> <p>After taking this unit, students should be able to:</p> <ul> <li>explain how breaking the abstraction barrier creates fragile code.</li> <li>apply information hiding using <code>private</code> and <code>public</code> in Java classes.</li> <li>distinguish client code from implementation code using access modifiers.</li> <li>construct objects safely using constructors instead of direct field access.</li> <li>use <code>this</code> to disambiguate fields from parameters.</li> </ul> <p>Overview</p> <p>In Unit 3, we learned how abstraction allows us to separate what a component does from how it does it, enabling clients to use a data type without understanding its internal details. In Unit 4, we saw how encapsulation groups data and related operations into a class, establishing an abstraction barrier between clients and implementers. However, abstraction and encapsulation alone are not enough: unless the programming language actively prevents clients from accessing internal representation, this barrier can be accidentally or intentionally broken.</p> <p>In this unit, we introduce information hiding, the mechanism that enforces the abstraction barrier in practice. We will see how Java uses access modifiers to control visibility, ensuring that clients interact with a class only through its public interface. Once internal representation is hidden, we will also examine how constructors provide the only safe way to create and initialize objects, and how the this keyword helps clarify the distinction between object state and local variables. Together, these ideas show how abstraction is not just a design principle, but a property enforced by the language and the compiler.</p>"},{"location":"05-infohiding.html#breaking-the-abstraction-barrier","title":"Breaking the Abstraction Barrier","text":"<p>In the ideal case, the code above the abstraction barrier would just call the provided interface to use the composite data type.  There may, however, be cases where a programmer intentionally or accidentally break the abstraction barrier.  </p> <p>Consider the case of <code>Circle</code> in Unit 4, where we modify the radius <code>r</code> directly with <code>c.r = 10</code>.  In doing so, we, as the client to <code>Circle</code>, make an explicit assumption of how <code>Circle</code> implements a circle.  The implementation details have been leaked outside the abstraction barrier.  Assessing <code>c.r</code> turns the client into a partial implementer.  Now, if the implementer wishes to change the representation of the <code>Circle</code>, for example, to store the diameter, instead. </p> Circle v0.1b with Diameter<pre><code>class Circle {\n  double x;\n  double y;\n  double d; // diameter\n\n  double getArea() {\n    return 3.141592653589793 * d * d / 4.0;\n  }\n}\n</code></pre> <p>This small implementation change would invalidate the code that the client has written!  The line <code>c.r = 10;</code> will cause a compilation error. The client will have to carefully change all the code that makes the assumption, and modify it accordingly, increasing the chances of introducing a bug.</p>"},{"location":"05-infohiding.html#data-hiding","title":"Data Hiding","text":"<p>Many OO languages allow programmers to explicitly specify if a field or a method can be accessed from outside the abstraction barrier.  Java, for instance, supports <code>private</code> and <code>public</code> access modifiers.  A field or a method that is declared as <code>private</code> cannot be accessed from outside the class, and can only be accessed within the class.  On the other hand, as you can guess, a <code>public</code> field or method can be accessed, modified, or invoked from outside the class.  </p> <p>Such a mechanism for protecting the abstraction barrier is called data hiding or information hiding.  This protection is enforced by the compiler at compile time.</p> <p>In our original <code>Circle</code> class (v0.1) in Unit 4, we did not specify any access modifier \u2014 this amounts to using the default modifier, the meaning of which is not our concern right now<sup>1</sup>  For a start, we will explicitly indicate <code>private</code> or <code>public</code> for all our methods and fields.</p> Circle v0.2<pre><code>class Circle {\n  private double x;\n  private double y;\n  private double r;\n\n  public double getArea() {\n    return 3.141592653589793 * r * r;\n  }\n}\n</code></pre> <p>Now the fields <code>x</code>, <code>y</code>, and <code>r</code> are hidden behind the abstraction barrier of the class <code>Circle</code>.  Note that these fields are not accessible and modifiable outside of the class <code>Circle</code>, but they can be accessed and modified within <code>Circle</code> (inside the abstraction barrier), such as in the methods <code>getArea</code>.</p> <p>Breaking Python's Abstraction Barrier</p> <p>Python tries to prevent accidental access to internal representation by having a convention of prefixing the internal variables with <code>_</code> (one underscore) or <code>__</code> (two underscores).   This method, however, does not prevent a lazy programmer from directly accessing the variables and possibly planting a bug/error that will surface later.</p> <p>In summary, the two access modifiers are shown below:</p> Accessed from <code>private</code> <code>public</code> Inside the class Outside the class"},{"location":"05-infohiding.html#constructors","title":"Constructors","text":"<p>With data hiding, we completely isolate the internal representation of a class using an abstraction barrier.  But, with no way for the client of the class to modify the fields directly, how can the client initialize the fields in a class?  </p> <p>Since fields are hidden, it is often necessary for a class to provide methods to initialize these internal fields, allowing clients to create valid objects.</p> <p>A method that initializes an object is called a constructor.</p> <p>A constructor method is a special method within the class.  It cannot be called directly but is invoked automatically when an object is instantiated.   In Java, a constructor method has the same name as the class and has no return type.  A constructor can take in arguments just like other functions.  Let's add a constructor to our <code>Circle</code> class:</p> Circle v0.3<pre><code>class Circle {\n  private double x;\n  private double y;\n  private double r;\n\n  public Circle(double x, double y, double r) {\n    this.x = x;\n    this.y = y;\n    this.r = r;\n  }\n\n  public double getArea() {\n    return 3.141592653589793 * this.r * this.r;\n  }\n}\n</code></pre> <p>Now, to create a <code>Circle</code> object, we need to pass in three arguments: <pre><code>Circle c = new Circle(0.0, 0.5, 10.0);\n</code></pre></p> <p>Constructor in Python and JavaScript</p> <p>In Python, the constructor is the <code>__init__</code> method.   In JavaScript, the constructor is simply called <code>constructor</code>.</p>"},{"location":"05-infohiding.html#default-constructor","title":"Default Constructor","text":"<p>Our original <code>Circle</code> v0.1 does not have any constructor.  If there is no constructor given, then a default constructor is added automatically at compile time.  The default constructor has no parameter and has no code written for the body.  In the case of <code>Circle</code> v0.1, the default constructor would be the following:</p> <pre><code>Circle() {\n}\n</code></pre> <p>Notice the condition \"if no constructor is given at all\".  If at least one constructor is provided, Java will not provide the default constructor.</p>"},{"location":"05-infohiding.html#the-this-keyword","title":"The <code>this</code> Keyword","text":"<p>The code above also introduces the <code>this</code> keyword.  <code>this</code> is a reference variable that refers back to the calling object itself.    It can be used to distinguish between two variables of the same name.  In the example above, <code>this.x = x</code> means we want to set the field <code>x</code> of this object to the parameter <code>x</code> passed into the constructor.</p> <p>Now that you have been introduced to <code>this</code>, we have also updated the method body of <code>getArea</code> and replaced <code>r</code> with <code>this.r</code>.  Although there is nothing syntactically wrong with using just <code>r</code>, sticking to the idiom of referring to members through the <code>this</code> reference makes the code easier to understand for readers.  The <code>this</code> reference makes it explicit that the expression is referring to a field in the class, rather than a local variable or a parameter.</p> <p>As a rule of thumb, use <code>this</code> whenever you refer to a field.</p> <ol> <li> <p>The other access modifier is <code>protected</code>.  Again, we do not want to worry about this modifier for now.\u00a0\u21a9</p> </li> </ol>"},{"location":"06-tell-dont-ask.html","title":"Unit 6: Tell, Don't Ask","text":"<p>Learning Objectives</p> <p>After this unit, students should be able to:</p> <ul> <li>explain the role of accessors and mutators, and why they are not always desirable in object-oriented design</li> <li>identify how accessors and mutators can increase coupling and leak implementation details</li> <li>apply the Tell, Don\u2019t Ask principle to redesign client\u2013class interactions</li> <li>refactor client code that relies on getters into object-oriented method calls</li> <li>reason about encapsulation trade-offs when deciding whether to expose object state</li> </ul> <p>Overview</p> <p>In earlier units, we learned how to define classes with private fields and public methods, and how encapsulation helps protect an object\u2019s internal state.</p> <p>In this unit, we examine a common but subtle design mistake: exposing an object\u2019s internal state through accessors and mutators, and pushing logic into client code. Although getters and setters may seem harmless\u2014or even \u201cgood practice\u201d\u2014they can quietly weaken encapsulation and increase coupling.</p> <p>We introduce the Tell, Don\u2019t Ask principle, which encourages clients to tell objects what to do, rather than asking for their internal data and operating on it externally. This shift helps us design objects that are more robust, flexible, and easier to change.</p>"},{"location":"06-tell-dont-ask.html#accessors-and-mutators","title":"Accessors and Mutators","text":"<p>Similar to providing constructors, a class can also provide methods to retrieve or modify the properties of the object.  These methods are called the accessor (or getter) or mutator (or setter). While accessors and mutators are common, using them indiscriminately can undermine encapsulation and lead to fragile designs.</p> <p>The example below shows a <code>Circle</code> class with accessor and mutator methods for its fields.</p> Circle v0.4<pre><code>class Circle {\n  private double x;\n  private double y;\n  private double r;\n\n  public Circle(double x, double y, double r) {\n    this.x = x;\n    this.y = y;\n    this.r = r;\n  }\n\n  public double getX() {\n    return this.x;\n  }\n\n  public void setX(double x) {\n    this.x = x;\n  }\n\n  public double getY() {\n    return this.y;\n  }\n\n  public void setY(double y) {\n    this.y = y;\n  }\n\n  public double getR() {\n    return this.r;\n  }\n\n  public void setR(double r) {\n    this.r = r;\n  }\n\n  public double getArea() {\n    return 3.141592653589793 * this.r * this.r;\n  }\n}\n</code></pre> <p>In the code above, we can categorise the accessor and mutator of each field as follows.</p> Fields Accessors Mutators <code>x</code> <code>getX</code> <code>setX</code> <code>y</code> <code>getY</code> <code>setY</code> <code>r</code> <code>getR</code> <code>setR</code> <p>Do note that using the prefix <code>get</code> or <code>set</code> for accessor and mutator is optional, although it is a good practice.  For instance, we could name a mutator that sets the radius as <code>resize</code> instead of <code>setRadius</code>.</p>"},{"location":"06-tell-dont-ask.html#accessormutator-vs-public","title":"Accessor/Mutator vs Public","text":"<p>Instead of providing an accessor method and a mutator method for every private field, why don't we just declare the fields as <code>public</code> and access them directly?  </p> <p>Having both an accessor and a mutator for a private field is still better than setting the field <code>public</code>.  By having an accessor and a mutator, we are adding a layer of abstraction.  For instance, we can still rename a field without affecting the client.</p> <p>Another advantage is that we may be able to perform some checks on the mutator and prevent certain invalid values from ever being assigned to the field.  Consider the method <code>setR</code> in our <code>Circle</code> v0.4 above.  A slightly better approach is to implement it with a check to prevent setting the radius to a non-positive value.</p> <pre><code>public void setR(double r) {\n  if (r &gt; 0) {\n    this.r = r;\n  } else {\n    // Handle error here.  Code ommitted for simplicity.\n  }\n}\n</code></pre>"},{"location":"06-tell-dont-ask.html#how-accessormutator-can-be-harmful","title":"How Accessor/Mutator Can Be Harmful","text":"<p>Since having accessors and mutators is better than having public fields, does it mean that we should always provide an accessor and a mutator for every private field?</p> <p>Let's consider a slightly different version of <code>Circle</code> where the center coordinate and radius are integers, perhaps because the implementer does not have the foresight that they need to be floating-point numbers.</p> Circle v0.4a with Integer Coordinates<pre><code>class Circle {\n  private int x;\n  private int y;\n  private int r;\n\n  public Circle(int x, int y, int r) {\n    this.x = x;\n    this.y = y;\n    this.r = r;\n  }\n\n  public int getX() {\n    return this.x;\n  }\n\n  public void setX(int x) {\n    this.x = x;\n  }\n\n  public int getY() {\n    return this.y;\n  }\n\n  public void setY(int y) {\n    this.y = y;\n  }\n\n  public int getR() {\n    return this.r;\n  }\n\n  public void setR(int r) {\n    this.r = r;\n  }\n\n  public double getArea() {\n    return 3.141592653589793 * this.r * this.r;\n  }\n}\n</code></pre> <p>Suppose a client of the class wishes to check if, given a point (x,y), does it lie within the circle <code>c</code>?  One approach would be:</p> Client Code v1 (Ask)<pre><code>int cX = c.getX();\nint cY = c.getY();\nint r = c.getR();\nboolean isInCircle = ((x - cX) * (x - cX) + (y - cY) * (y - cY)) &lt;= r * r;\n</code></pre> <p>One day, the implementer realized that the coordinates and radius should be floating-point numbers and changed the fields to <code>double</code>, and revised the <code>Circle</code> implementation to v0.4 shown earlier.  The client code above will break!  Since the accessors now return <code>double</code> values, but the client assigned the returned values to <code>int</code>. </p> <p>Thus, having accessors and mutators in a class can inevitably leak some information about the class's internal representation to the client.  This is a form of coupling between the client and the class.  In the example above, the client code depends on the fact that the center coordinates and radius are represented as <code>int</code>.  Any change to the internal structure will break the client code.</p> <p>Thus, we should think carefully if an accessor or a mutator is really needed for a field, i.e., does the client really need to access or modify something that is internal to the class? </p>"},{"location":"06-tell-dont-ask.html#the-tell-dont-ask-principle","title":"The \"Tell, Don't Ask\" Principle","text":"<p>One guiding principle to whether the implementer should provide and whether the client should call the accessor and mutator is the \"Tell, Don't Ask\" principle.  This principle suggests that we should tell an object what to do, instead of asking an object for its state and then performing the task on its behalf.</p> <p>Let's revisit the example above. This time, the (disgruntled) client has updated the code to use floating-point coordinates and radius.</p> Client Code v2 (Ask)<pre><code>double cX = c.getX();\ndouble cY = c.getY();\ndouble r = c.getR();\nboolean isInCircle = ((x - cX) * (x - cX) + (y - cY) * (y - cY)) &lt;= r * r;\n</code></pre> <p>Here the client calls the accessor methods to ask for the values of the fields <code>x</code>, <code>y</code>, and <code>r</code> of the <code>Circle</code> object <code>c</code>, and then performs the computation to check if the point <code>(x,y)</code> is within the circle.  </p> <pre><code>sequenceDiagram\n    participant c as Circle\n    participant client\n    c-&gt;&gt;client: getX()\n    c-&gt;&gt;client: getY()\n    c-&gt;&gt;client: getR()\n    client-&gt;&gt;client: perform computation</code></pre> <p>Applying the \"Tell Don't Ask\" principle, a better approach would be to add a new <code>boolean</code> method in the <code>Circle</code> class,  <pre><code>boolean contains(double x, double y) {\n  return ((x - this.x) * (x - this.x) + (y - this.y) * (y - this.y)) &lt;= this.r * this.r;\n}\n</code></pre></p> <p>and let the client tell the <code>Circle</code> object to check if the point is within the circle. Client Code v3 (Tell)<pre><code>boolean isInCircle = c.contains(x, y);\n</code></pre></p> <pre><code>sequenceDiagram\n    participant c as Circle\n    participant client\n    client-&gt;&gt;c: contains(x, y)\n    c-&gt;&gt;client: answer</code></pre> <p>This better approach involves writing a few more lines of code to implement the method, but it keeps the encapsulation intact, leading to less coupling between the client and the class.  The client does not need to know the internal representation of the <code>Circle</code> class, and the <code>Circle</code> class can change its internal structure (e.g., the type of the fields) without affecting the client.</p> <p>In general, a task that is performed only on the fields of a class should be implemented in the class itself.  As a rule of thumb, if client code calls two or more accessors on the same object and combines those values to compute a result, then that computation likely belongs inside the object.</p> <p>While there are situations where we cannot avoid using an accessor or a mutator in a class, for beginner OO programmers like yourselves, relying on accessors and mutators as defaults indiscrminately can hinder the development of good OO design instinct.  Using accessors and mutators heavily often turns objects into passive data holders, shifting logic into client code. This style resembles procedural programming more than object-oriented design.  As such, you are encouraged to avoid defining accessors and modifiers to private fields, and instead focus on designing methods within the class that tell an object what task to perform, and allowing clients to simply request those tasks. </p>"},{"location":"06-tell-dont-ask.html#further-reading","title":"Further Reading","text":"<ul> <li>Tell Don't Ask by Martin Fowler</li> <li>Why getters and setters are evil by Allen Holub</li> <li>Getters and setters are evil. Period, by Yegor Bygayenko.</li> </ul>"},{"location":"07-static-field.html","title":"Unit 7: Class Fields","text":"<p>Learning Objectives</p> <p>After this unit, students should be able to:</p> <ul> <li>distinguish clearly between instance fields and class (static) fields, both conceptually and syntactically.</li> <li>explain when and why a field should be declared static, final, or both.</li> <li>define and access class fields correctly using class names.</li> <li>recognize common use cases of class fields (constants, shared configuration, precomputed values).</li> <li>refactor code to eliminate \u201cmagic numbers\u201d using appropriate class fields.</li> </ul> <p>Overview</p> <p>In earlier units, we treated objects as the fundamental building blocks of a program, each with its own state. However, not all values naturally belong to individual objects. Some values, such as mathematical constants or configuration parameters, are shared universally and remain the same across all instances.</p> <p>This unit introduces class (static) fields, which belong to a class rather than any specific object. You will learn how Java supports shared state through the <code>static</code> keyword, how this differs from instance fields, and how class fields are commonly used to define constants and utility values in well-designed programs.</p>"},{"location":"07-static-field.html#why-class-fields-exist","title":"Why Class Fields Exist","text":"<p>Let's revisit the following implementation of <code>Circle</code>. Circle v0.3<pre><code>class Circle {\n  private double x;\n  private double y;\n  private double r;\n\n  public Circle(double x, double y, double r) {\n    this.x = x;\n    this.y = y;\n    this.r = r;\n  }\n\n  public double getArea() {\n    return 3.141592653589793 * this.r * this.r;\n  }\n}\n</code></pre></p> <p>In the code above, we use the constant \\(\\pi\\) but hardcode it as 3.141592653589793.  Hardcoding such a magic number is considered poor coding style.  This constant can appear in more than one place. If we hardcode such a number and want to change its precision later, we would need to trace down and change every occurrence.  Every time we need to use \\(\\pi\\), we have to remember or look up what is the precision that we use.  Not only does this practice introduce more work, it is also likely to introduce bugs.  </p> <p>In C, we define \\(\\pi\\) as a macro constant <code>M_PI</code>.  But how should we do this in Java?  This is where the idea that a program consists of only objects with internal states that communicate with each other can feel a bit constraining.  The constant \\(\\pi\\) is universal and does not really belong to any object (the value of \\(\\pi\\) is the same for every circle!).  </p> <p>Another example is the method <code>sqrt()</code>, which computes the square root of a given number.  <code>sqrt</code> is a general function that is not associated with any object as well.  We will study such class methods in the next unit; they follow the same class-level principle as class fields.</p> <p>A solution to this is to associate these global values and functions with a class instead of with an object.  For instance, Java predefines a <code>java.lang.Math</code> class<sup>1</sup> that is populated with constants <code>PI</code> and <code>E</code> (for Euler's number \\(e\\)), along with a long list of mathematical functions.  To associate a method or a field with a class in Java, we declare them with the <code>static</code> keyword.  We can additionally add the keyword <code>final</code> to indicate that the value of the field will not change and <code>public</code> to indicate that the field is accessible from outside the class.  In short, the combination of <code>public static final</code> modifiers is used for constant values in Java.</p> <pre><code>class Math {\n  :\n  public static final double PI = 3.141592653589793;\n  :\n  :\n}\n</code></pre> <p>We call <code>static</code> fields that are associated with a class as class fields and fields that are associated with an object as instance fields.  Note that, a <code>static</code> class field needs not be <code>final</code> and it needs not be <code>public</code>.  Class fields are useful for storing pre-computed values or configuration parameters associated with a class rather than individual objects.  Because it is associated with the class rather than an instance, a <code>static</code> field has exactly one shared instance during the entire execution of the program. They introduce implicit shared state. Any method that modifies a class field affects all objects of that class.  </p> <p>Class fields are not a violation of object-oriented design. Instead, they acknowledge that some state conceptually belongs to a class as a whole, not to individual objects.  If a field\u2019s value would be identical across all instances, it is a strong candidate for being a class field.</p> <p>Caution: because class fields introduce global shared state, they can make programs harder to reason about if overused.</p>"},{"location":"07-static-field.html#using-class-fields","title":"Using Class Fields","text":"<p>A class field behaves just like a global variable and can be accessed in the code, anywhere the class can be accessed.  Since a class field is associated with a class rather than an object, we access it through its class name.  </p> <pre><code>public double getArea() {\n  return Math.PI * this.r * this.r;  // Math is the class containing PI\n}\n</code></pre> <p>Below is an example of a non-constant class field.  We introduce a class field <code>circleCount</code> to count how many <code>Circle</code> objects have been created so far.</p> Circle v0.3b<pre><code>class Circle {\n  private static int circleCount = 0; // class field to count circles\n  private double x;\n  private double y;\n  private double r;\n\n  public Circle(double x, double y, double r) {\n    this.x = x;\n    this.y = y;\n    this.r = r;\n    circleCount++; // increment the count whenever a new Circle is created\n  }\n\n  public double getArea() {\n    return Math.PI * this.r * this.r;\n  }\n\n  public int getCircleCount() {\n    return Circle.circleCount; // return the total number of Circle instances created\n  }\n}\n</code></pre> <p>Here, there is only exactly one instance of <code>circleCount</code> regardless of how many instances of <code>Circle</code> we have created.  In fact, we need not create any instance of <code>Circle</code> at all to be able to use <code>circleCount</code>.</p> Demonstrating of shared class field<pre><code>Circle c = new Circle(0, 0, 1);\nc.getCircleCount(); // returns 1\nc = new Circle(1, 1, 2);\nc.getCircleCount(); // returns 2\n</code></pre> <p>In Java, it is fine to access a class field through an instance, but it is discouraged because it can be misleading.  The following code is legal, but it is better to access <code>circleCount</code> through the class name <code>Circle</code> instead of the instance reference. Class method (invoking via instance)<pre><code>  public int getCircleCount() {\n    return this.circleCount; // return the total number of Circle instances created\n  }\n</code></pre></p> <p>Class Fields and Methods in Python</p> <p>Note that, in Python, any variable declared within a <code>class</code> block is a class field: <pre><code>class Circle:\n  x = 0\n  y = 0\n</code></pre></p> <p>In the above example, <code>x</code> and <code>y</code> are class fields, not instance fields.</p> <ol> <li> <p>The class <code>Math</code> is provided by the package <code>java.lang</code> in Java.  A package is simply a set of related classes (and interfaces, but I have not told you what is an interface yet).  The package <code>java.lang.Math</code> is automatically imported by the Java compiler.\u00a0\u21a9</p> </li> </ol>"},{"location":"08-static-method.html","title":"Unit 8: Class Methods","text":"<p>Learning Objectives</p> <p>After this unit, students should be able to:</p> <ul> <li>distinguish clearly between instance methods and class (static) methods.</li> <li>explain why class methods cannot access instance fields or use this.</li> <li>define and invoke class methods correctly using the class name.</li> <li>describe the role of the main method as the entry point of a Java program.</li> <li>identify the required modifiers, return type, and parameters of a valid main method.</li> </ul> <p>Overview</p> <p>In previous units, we focused on instance methods, which operate on the state of individual objects. However, not all behavior in a program naturally belongs to a specific object. Some operations conceptually belong to the class as a whole\u2014for example, keeping track of how many objects have been created, or providing general-purpose utility functions.</p> <p>In this unit, we introduce class methods, which are declared using the static keyword. You will learn how class methods differ from instance methods, why they cannot access instance-specific state, and how Java uses a special class method, main, as the entry point for every program.</p>"},{"location":"08-static-method.html#static-methods","title":"Static Methods","text":"<p>In the previous unit, we added a class field <code>circleCount</code> to our <code>Circle</code> class to keep track of how many <code>Circle</code> instances have been created, and we added a method <code>getCircleCount()</code> to return its value.  However, <code>getCircleCount()</code> was still defined as an instance method.  This means that we had to invoke it through a specific <code>Circle</code> instance, even when the field <code>circleCount</code> exists without an <code>Circle</code> instance.</p> <p>Since <code>getCircleCount()</code> does not depend on any particular <code>Circle</code> instance, it is more appropriate to define it as a class method.  A class method is defined with the <code>static</code> modifier.  Here is an improved version of the <code>Circle</code> class that uses a class method to return the number of circles created so far.</p> Circle v0.3b with Class Method<pre><code>class Circle {\n  private static int circleCount = 0; // class field to count circles\n  private double x;\n  private double y;\n  private double r;\n\n  public Circle(double x, double y, double r) {\n    this.x = x;\n    this.y = y;\n    this.r = r;\n    circleCount++; // increment the count whenever a new Circle is created\n  }\n\n  public double getArea() {\n    return Math.PI * this.r * this.r;\n  }\n\n  public static int getCircleCount() {\n    return Circle.circleCount; // return the total number of Circle instances created\n  }\n}\n</code></pre> <p>Similar to a class field, a class method is associated with a class, not with an instance of the class.  We can now invoke <code>getCircleCount()</code> through the class name <code>Circle</code>, without needing to create any instance of <code>Circle</code>.</p> Invoking Class Method through Class Name<pre><code>Circle.getCircleCount(); // returns 0\nnew Circle(0, 6, 7)\nnew Circle(1, 1, 2);\nCircle.getCircleCount(); // returns 2\n</code></pre> <p>Other examples of class methods include the methods provided in <code>java.lang.Math</code>: <code>sqrt</code>, <code>min</code>, etc.  These methods can be invoked through the <code>Math</code> class: e.g., <code>Math.sqrt(x)</code>.</p> <p>As a rule of thumb, use an instance method if the behavior depends on instance fields; Use a class method if the behavior conceptually belongs to the class and does not depend on any particular object.  Overusing class methods can lead to procedural-style code and should be avoided when behavior naturally belongs to objects.</p>"},{"location":"08-static-method.html#accessing-instance-fields-from-class-methods","title":"Accessing Instance Fields from Class Methods","text":"<p>Just as a class field represents shared state, a class method represents shared behavior.  Recall that for static fields (i.e., class fields), we only have exactly one instance of it throughout the lifetime of the program.  More generally, a field or method with modifier <code>static</code> belongs to the class rather than the specific instance.  In other words, they can be accessed/updated (for fields, assuming proper access modifier) or invoked (for methods, assuming proper access modifier) without even instantiating the class.</p> <p>As a consequence, if we have not instantiated a class, no instance of that class has been created.  The keyword <code>this</code> is meant to refer to the current instance, and if there is no instance, the keyword <code>this</code> is not meaningful.  Therefore, within the context of a <code>static</code> method, Java actually prevents the use of <code>this</code> from any method with the <code>static</code> modifier.</p> <p>For example, <pre><code>  public static int getCircleCount() {\n    return this.circleCount; \n  }\n</code></pre> will result in the following error.</p> <pre><code>Error: non-static variable this cannot be referenced from a static context\n    return this.circleCount;\n               ^\n</code></pre> <p>The opposite is not true.  We can access class fields from instance methods.</p>"},{"location":"08-static-method.html#the-main-method","title":"The <code>main</code> method","text":"<p>The most common class method you will use is probably the <code>main</code> method.</p> <p>Every Java program has a class method called <code>main</code>, which serves as the entry point to the program.  To run a Java program, we need to tell the JVM the class whose <code>main</code> method should be invoked first.  In the example that we have seen, <pre><code>java Hello\n</code></pre></p> <p>will invoke the <code>main</code> method defined within the class <code>Hello</code> to kick start the execution of the program.  The main method must be declared <code>static</code> because it is invoked by the JVM before any objects of the class are created.</p> <p>The <code>main</code> method must be defined in the following way: <pre><code>public static final void main(String[] args) {\n}\n</code></pre></p> <p>You have learned what <code>public</code> and <code>static</code> means.  The return type <code>void</code> indicates that <code>main</code> must not return a value.  We have discussed what <code>final</code> means on a field, but are not ready to explain what <code>final</code> means on a method yet.</p> <p>The <code>main</code> method takes in an array (<code>[]</code>) of strings as parameters.  These are the command-line arguments that we can pass in when invoking <code>java</code>.  <code>String</code> (or <code>java.lang.String</code>) is another class provided by the Java library that encapsulates a sequence of characters.</p>"},{"location":"09-composition.html","title":"Unit 9: Composition","text":"<p>Learning Objectives</p> <p>After completing this unit, students should be able to:</p> <ul> <li>explain composition as a design technique for building complex objects from simpler ones</li> <li>distinguish HAS-A (composition) relationships from IS-A (inheritance) relationships</li> <li>design classes that use composition to improve abstraction and encapsulation</li> <li>reason about aliasing and explain how shared references can lead to unintended behaviour</li> <li>evaluate design trade-offs between sharing objects, copying objects, and immutability</li> </ul> <p>Overview</p> <p>In earlier units, we built classes primarily from primitive fields and methods. While this works for simple abstractions, real software systems are rarely built this way. Instead, complex objects are constructed by combining simpler objects.</p> <p>This unit introduces composition, a core object-oriented design technique where one class is built from instances of other classes. Composition allows us to raise the level of abstraction, improve encapsulation, and model real-world \u201cHAS-A\u201d relationships more naturally.</p> <p>We will also examine a subtle but important consequence of composition: shared references. While reusing objects can reduce memory usage and duplication, it can also lead to surprising bugs due to aliasing. Understanding these trade-offs is essential for writing correct and maintainable object-oriented programs.</p>"},{"location":"09-composition.html#adding-more-abstractions","title":"Adding more Abstractions","text":"<p>Our previous implementation of <code>Circle</code> stores the center using its Cartesian coordinates \\((x,y)\\).  We have a method <code>contains</code> that takes in the Cartesian coordinate of a point.  As such, our implementation of <code>Circle</code> assumes that a 2D point is best represented using its Cartesian coordinate.  </p> <p>Recall that we wish to hide the implementation details as much as possible, protecting them with an abstraction barrier, so that the client does not have to bother about the details and it is easy for the implementer to change the details.  Let's consider an example: what if the programmer finds that it is more convenient to use polar coordinates to represent a 2D point?  We will have to change the constructor to <code>Circle</code> and the method <code>contains</code>.  If our code contains other shapes or other methods in <code>Circle</code> that similarly assume a point is represented with its Cartesian coordinates, we will have to change them as well.  It is easy for bugs to creep in.  For instance, we might pass in the polar coordinates \\((r, \\theta)\\) to a method, but the method treats the two parameters as the Cartesian \\((x,y)\\).</p> <p>We can apply the principle of abstraction and encapsulation here, and create a new class <code>Point</code>.  The details of which are omitted and left as an exercise.</p> <p>With the <code>Point</code> class, our <code>Circle</code> class looks like the following:</p> Circle v0.5 with Composition<pre><code>/**\n * A Circle object encapsulates a circle on a 2D plane.  \n */\nclass Circle {\n  private Point c;   // the center\n  private double r;  // the length of the radius\n\n  /**\n   * Create a circle centered on Point c with given radius r\n   */\n  public Circle(Point c, double r) {\n    this.c = c;\n    this.r = r;\n  }\n\n  /**\n   * Return the area of the circle.\n   */\n  public double getArea() {\n    return Math.PI * this.r * this.r;\n  }\n\n  /**\n   * Return true if the given point p is within the circle.\n   */\n  public boolean contains(Point p) {\n    // TODO: Left as an exercise\n    return false;\n  }\n}\n</code></pre> <p>This example also illustrates the concept of composition.  Our class <code>Circle</code> has been upgraded from being a bundle of primitive types and methods to a bundle that includes a reference type <code>Point</code> as well.  In OOP, composition is a basic technique to build up layers of abstractions and construct sophisticated classes.</p> <p>We have mentioned that classes model real-world entities in OOP.  The composition models the HAS-A relationship between two entities.  For instance, a circle has a point as the center.</p>"},{"location":"09-composition.html#example-cylinder","title":"Example: <code>Cylinder</code>","text":"<p>Now let's build up another layer of abstraction and construct a 3D object \u2014 a cylinder.  A cylinder has a circle as its base and has a height value.  Using composition, we can construct a <code>Cylinder</code> class:</p> Cylinder v0.1 with Composition<pre><code>class Cylinder {\n  private Circle base;\n  private double height;\n\n  public Cylinder(Circle base, double height) {\n    this.base = base;\n    this.height = height;\n  }\n\n  // other methods omitted\n}\n</code></pre>"},{"location":"09-composition.html#sharing-references-aka-aliasing","title":"Sharing References, aka Aliasing","text":"<p>Recall that, unlike primitive types, reference types may share the same reference values.  This is called aliasing.  Let's look at the subtleties of how this could affect our code and catch us by surprise.</p> <p>Consider the following, where we create two circles <code>c1</code> and <code>c2</code> centered at the origin (0, 0). <pre><code>Point p = new Point(0, 0);\nCircle c1 = new Circle(p, 1);\nCircle c2 = new Circle(p, 4);\n</code></pre></p> <p>Let's say that we want to allow a Circle to move its center.  For the sake of this example, let's allow mutators on the class <code>Point</code>.  Suppose we want to move <code>c1</code> and only <code>c1</code> to be centered at (1,1). <pre><code>p.moveTo(1, 1);\n</code></pre></p> <p>You will find that by moving <code>p</code>, we are actually moving the center of both <code>c1</code> and <code>c2</code>!  This result is due to both circles <code>c1</code> and <code>c2</code> sharing the same <code>Point</code> object. When we pass the center into the constructor, we are passing the reference instead of passing a cloned copy of the center. so, there is only one <code>Point</code> object, even though there are two circles.  </p> <p>This is a common source of bugs and we will see how we can reduce the possibilities of such bugs later in this course, but let's first consider the following attempted fix.</p> <p>Let's suppose that instead of moving <code>p</code>, we add a <code>moveTo</code> method to the <code>Circle</code> instead: Circle v0.5a with moveTo Method<pre><code>class Circle {\n  private Point c;   // the center\n  private double r;  // the length of the radius\n    :\n\n  /**\n   * move the center of this circle to the given point\n   */\n  void moveTo(Point c) {\n    this.c = c;\n  }\n\n  // other methods omitted\n}\n</code></pre></p> <p>Now, to move <code>c1</code>, <pre><code>Point p = new Point(0, 0);\nCircle c1 = new Circle(p, 1);\nCircle c2 = new Circle(p, 4);\nc1.moveTo(new Point(1, 1));\n</code></pre></p> <p>You will find that <code>c1</code> will now have a new center, but <code>c2</code>'s center remains at (0,0).  Why doesn't this solve our problem then?  Recall that we can further compose circles into other objects.  Let's say that we have two cylinders: <pre><code>Cylinder cylinder1 = new Cylinder(c1, 1);\nCylinder cylinder2 = new Cylinder(c1, 1);\n</code></pre></p> <p>that share the same base, then the same problem repeats itself! One solution is to avoid sharing references as much as possible.  For instance,</p> <pre><code>Point p1 = new Point(0, 0);\nCircle c1 = new Circle(p1, 1);\n\nPoint p2 = new Point(0, 0);\nCircle c2 = new Circle(p2, 4);\n\np1.moveTo(1, 1);\n</code></pre> <p>Without sharing references, moving <code>p1</code> only affects <code>c1</code>, so we are safe.   </p> <p>The drawback of not sharing objects with the same content is that we will have a proliferation of objects and the computational resource usage is not optimized.  This is an example of the trade-offs we mentioned in the introduction to this course: we are sacrificing the computational cost to save programmers from potential suffering.</p> <p>Another approach to address this issue is immutability.  We will cover this later in the course.</p>"},{"location":"10-heap-stack.html","title":"Unit 10: Heap and Stack","text":"<p>Learning Objectives</p> <p>After taking this unit, students should be able to:</p> <ul> <li>explain how the JVM allocates and deallocates memory on the stack and heap during program execution.</li> <li>draw and interpret stack\u2013heap diagrams for object creation, method calls, and returns.</li> <li>reason about aliasing and shared references, and predict the effects of mutations.</li> <li>trace the creation and destruction of stack frames during nested method invocations.</li> <li>explain Java\u2019s parameter passing semantics for primitive values and object references.</li> </ul> <p>Overview</p> <p>In earlier units, we focused on what objects and methods do. In this unit, we turn our attention to where and how data is stored when a Java program runs.</p> <p>Understanding the distinction between the stack and the heap is essential for reasoning about object creation, method calls, parameter passing, and side effects. Many common programming misconceptions, such as why changing an object inside a method affects the caller, but changing a primitive does not, can be resolved by carefully tracing how memory is allocated and shared.</p> <p>This unit introduces the JVM\u2019s memory model at a conceptual level and develops a systematic way to draw and reason about stack\u2013heap diagrams. These diagrams will become an important tool for explaining aliasing, debugging programs, and understanding program behaviour precisely.</p>"},{"location":"10-heap-stack.html#heap-and-stack","title":"Heap and Stack","text":"<p>The Java Virtual Machine (JVM) manages the memory of Java programs while its bytecode instructions are interpreted and executed.  Different JVM implementations may implement these differently, but typically a JVM implementation partitions the memory into several regions, including:</p> <ul> <li>method area for storing the code for the methods;</li> <li>metaspace for storing meta information about classes;</li> <li>heap for storing dynamically allocated objects;</li> <li>stack for local variables and stack frames.</li> </ul> <p>Since the concepts of heap and stack are common to all execution environments (either based on bytecode or machine code), we will focus on them here.</p> <p>The heap is the region in memory where all objects are allocated and stored, while the stack is the region where all variables (including primitive types and object references) are allocated and stored.</p>"},{"location":"10-heap-stack.html#stack","title":"Stack","text":"<p>The stack contains variables.  Please note that instance and class fields are not variables.  As such, fields are not in the stack.</p> <p>Recall that the same variable names can exist in the program as long as they are in different methods.  This means that the variables are contained within the stack frames.  Call frames are created when we invoke a method and are removed when the method completes.</p> <p>Like a \"stack of books\" where we can only take the book at the top and can only put more books at the top, the stack frames in the stack can only be added or removed from the top.  This behavior is also called Last-In First-Out (LIFO).  In other words, the last element that is inserted (i.e., Last-In) is the first element to be removed (i.e., First-Out).</p>"},{"location":"10-heap-stack.html#heap","title":"Heap","text":"<p>The heap stores dynamically allocated objects.  To put it simply, whenever you use the keyword <code>new</code>, a new object is created in the heap.</p> <p>Unlike the stack, there is no concept of LIFO.  So, an object can persist across multiple method invocations.  This also means that an object can be shared between multiple method invocations.</p> <p>An object in the heap contains the following information:</p> <ul> <li>Class name.</li> <li>Instance fields and the respective values.</li> <li>Captured variables (more on this in later units).</li> </ul> <p> ClassName field1: value1 field2: value2 </p>"},{"location":"10-heap-stack.html#examples","title":"Examples","text":""},{"location":"10-heap-stack.html#constructor","title":"Constructor","text":"<p>Consider the following two lines of code. <pre><code>Point p;\np = new Point(1, 2);\n</code></pre></p> <p>Line 1 declares a variable <code>p</code>.  When the JVM executes this line of code, it allocates some memory space for an object reference for <code>p</code>, the content is currently uninitialized  (Note: \"uninitialized\" does not mean it has the value <code>null</code>.  An uninitialized variable has no value, not even <code>null</code>)  We show uninitialized variables with the content having the symbol \u2205.  Since <code>p</code> is a variable, it resides in the stack.</p> <p>Line 2 creates a new <code>Point</code> object.  When the JVM executes this line of code, it (i) allocates some memory space for a <code>Point</code> object on the heap, (ii) invokes the constructor, and (iii) returns the reference to the newly allocated memory space back.  The returned memory address of this memory space becomes the reference of the object and is assigned to the variable <code>p</code>.</p> <p>This is shown in the figures below in three steps.  Note that we assume that the code snippet above is in the static method called <code>main</code>.  Although technically there should be a parameter in the call frame of <code>main</code> usually called <code>args</code> due to the typical main method <code>public static void main(String[] args)</code>, we will often omit this because the name and values are unknown.</p> <p>Note the crucial difference between the static method <code>main</code> and the constructor.  A static method does not have <code>this</code> in its call frame.  On the other hand, non-static methods, including constructors, have <code>this</code> in their stack frames.</p> <p>Although we mentioned that <code>this</code> is a keyword, it behaves mostly like a variable<sup>1</sup>.  As such, we have its representation in the stack.  </p> After Line 1Allocate MemoryInvoke ConstructorEnd of ConstructorReturn from Constructor <p> main p \u03d5 Stack Heap </p> <p> main p \u03d5 Point x: 0.0 y: 0.0 9048ab50 Stack Heap </p> <p> Point y x this 2.0 1.0 9048ab50 main p \u03d5 Point x: 0.0 y: 0.0 9048ab50 Stack Heap </p> <p> Point y x this 2.0 1.0 9048ab50 main p \u03d5 Point x: 1.0 y: 2.0 9048ab50 Stack Heap </p> <p> main p 9048ab50 Point x: 1.0 y: 2.0 9048ab50 Stack Heap </p> <p>Note that we use the symbol \u2205 to indicate that the variable is not yet initialized.  Java differentiates between uninitialized variables and variables initialized to <code>null</code>.  Uninitialized variables cannot be used.  Further, note that uninitialized fields have default values but not uninitialized variables.</p> <p>Also, we will often simplify the presentation.  First, we will omit the memory address (e.g., 9048ab50).  The arrow from the variable <code>p</code> containing the value 9048ab50 to an object located at 9048ab50 is already an abstraction of this.  Furthermore, we do not know where the actual address will be and it will be different on different runs.  So, we can omit both memory addresses stored in the variable and of the object.</p> <p>Secondly, we are often interested only in the snapshot of the stack and heap diagram at a particular moment.  As such, the intermediate stack frames (e.g., Point constructor) that are inserted and then removed can be omitted.  Only the final effect matters.</p> <p>Let us illustrate this further with the following code snippet.</p> <pre><code>Circle c;\nc = new Circle(new Point(1, 2), 3);\n</code></pre> <p>In this case, the <code>new Point(1, 2)</code> is evaluated first to create an object in the heap.  Then, we evaluate <code>new Circle(.., 3)</code>.  The reference to this object is then assigned to the variable <code>c</code>.  The final effect is shown below.  Note that the field <code>c</code> in the class <code>Circle</code> is an arrow to the point object in the heap.</p> <p> main c \u25cf Point x: 1.0 y: 2.0 Circle c: \u25cf r: 3.0 Stack Heap </p>"},{"location":"10-heap-stack.html#aliasing","title":"Aliasing","text":"<p>Now, let's look at an example of aliasing in the stack and heap diagram with the following example.</p> <pre><code>Circle c;\nPoint center;\ndouble radius;\nradius = 8;\ncenter = new Point(1, 1);\nc = new Circle(center, radius);\ncenter.moveto(2, 2);\n</code></pre> <p>In this example, we have three variables, <code>c</code>, <code>center</code>, and <code>radius</code>.  Lines 1-3 declare the variables, and as a result, we have three variables allocated on the stack.  Again, we assume that the code is in the static method <code>main</code>. </p> <p>Recall that object references are initialized to <code>null</code>.  Primitive type variables (e.g., <code>radius</code>) are initialized to 0.0 because it is of type <code>double</code>.  If it is an <code>int</code>, then it will be initialized to 0 instead.</p> After Lines 1-3After Lines 4-6After Line 7 <p> main radius \u03d5 center \u03d5 c \u03d5 Stack Heap </p> <p> main radius 8.0 center \u25cf c \u25cf Point x: 1.0 y: 1.0 Circle c: \u25cf r: 8.0 Stack Heap </p> <p> main radius 8.0 center \u25cf c \u25cf Point x: 2.0 y: 2.0 Circle c: \u25cf r: 8.0 Stack Heap </p> <p>There is a clear example of aliasing here.  Note that the field <code>c</code> of the Circle object referenced by the variable <code>c</code> is referencing the same object as the variable <code>center</code>.  Hence, we can say that the expression <code>c.c</code> is an alias of <code>center</code>.  In the stack and heap diagram, this is illustrated by having two different arrows pointing to the same location.</p> <p>In this case, the expression <code>c.c</code> consists of two arrows.  The first is from variable <code>c</code> to the object <code>Circle</code>.  The second is from the field <code>c</code> to the object <code>Point</code>.  On the other hand, the variable <code>center</code> is pointing directly to the object <code>Point</code>.</p> <p>We can also see that after Line 7, although the changes are done via <code>center.moveTo(..)</code>, the same object referenced by the expression <code>c.c</code> can see this change.</p>"},{"location":"10-heap-stack.html#call-stack","title":"Call Stack","text":"<p>Now, let's look at what happens when we invoke a method.  Take the <code>distanceTo</code> method in <code>Point</code> as an example:</p> <p><pre><code>class Point {\n  private double x;\n  private double y;\n\n  public Point(double x, double y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  public double distanceTo(Point q) {\n    return Math.sqrt((q.x - this.x)*(q.x - this.x)+(q.y - this.y)*(q.y - this.y));\n  }\n}\n</code></pre> and the invocation: <pre><code>Point p1 = new Point(0, 0);\nPoint p2 = new Point(1, 1);\np1.distanceTo(p2);\n</code></pre></p> <p>After declaring <code>p1</code> and <code>p2</code> and creating both objects, we have:</p> <p> main p2 \u25cf p1 \u25cf Point x: 0.0 y: 0.0 Point x: 1.0 y: 1.0 Stack Heap </p> <p>When <code>distanceTo</code> is called, the JVM creates a stack frame for this instance method call.  This stack frame is a region of memory that tentatively contains (i) the <code>this</code> reference, (ii) the method arguments, and (iii) local variables within the method, among other things<sup>2</sup><sup>3</sup>.  When a class method is called, the stack frame does not contain the <code>this</code> reference.</p> <p> main p2 \u25cf p1 \u25cf distanceTo q \u25cf this \u25cf Point x: 1.0 y: 1.0 Point x: 1.0 y: 1.0 Stack Heap </p> <p>You can see that the references to the objects <code>p1</code> and <code>p2</code> are copied onto the stack frame. <code>p1</code> and <code>this</code> point to the same object, and <code>p2</code> and <code>q</code> point to the same object. Within the method, any modification done to <code>this</code> would change the object referenced to by <code>p1</code>, and any change made to <code>q</code> would change the object referenced to by <code>p2</code> as well. After the method returns, the stack frame for that method is destroyed.</p> <p>Let's consider a new <code>move</code> method for the class <code>Point</code> that has two parameters <code>(double x, double y)</code> and moves the <code>x</code> and <code>y</code> coordinates of the <code>Point</code>.</p> <pre><code>class Point {\n  private double x;\n  private double y;\n\n  public Point(double x, double y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  public void move(double x, double y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n</code></pre> <pre><code>Point p1 = new Point(0, 0);\nPoint p2 = new Point(1, 1);\ndouble x = 5;\ndouble y = 5;\np1.move(x, y);\n</code></pre> <p>Again, we create a stack frame, copy the reference to object <code>p1</code> into <code>this</code>, copy <code>x</code> from the calling method to <code>x</code> the argument within the method, and copy <code>y</code> from the calling method to <code>y</code> the argument within the method.</p> After Lines 1-2After Lines 3-4Method Invocation at Line 5After Line 5 <p> main p2 \u25cf p1 \u25cf Point x: 0.0 y: 0.0 Point x: 1.0 y: 1.0 Stack Heap </p> <p> main y 5.0 x 5.0 p2 \u25cf p1 \u25cf Point x: 0.0 y: 0.0 Point x: 1.0 y: 1.0 Stack Heap </p> <p> main y 5.0 x 5.0 p2 \u25cf p1 \u25cf move y 5.0 x 5.0 this \u25cf Point x: 0.0 y: 0.0 Point x: 1.0 y: 1.0 Stack Heap </p> <p> main y 5.0 x 5.0 p2 \u25cf p1 \u25cf Point x: 5.0 y: 5.0 Point x: 1.0 y: 1.0 Stack Heap </p> <p>What is important here is that, as <code>x</code> and <code>y</code> are primitive types instead of references, we copy the values onto the stack.  If we change <code>x</code> or <code>y</code> within <code>move</code>, the <code>x</code> and <code>y</code> of the calling function will not change.  This behavior is the same as you would expect in C.  However, unlike in C where you can pass in a pointer to a variable, you cannot pass in a reference to a primitive type in any way in Java.  If you want to pass a variable of primitive type into a method and have its value changed, you will have to use a wrapper class.  The details of how to do this are left as an exercise.</p>"},{"location":"10-heap-stack.html#summary","title":"Summary","text":"<p>To summarize, Java uses call-by-value for primitive types, and behaves like call-by-reference for objects<sup>4</sup>.</p> <p>If we make multiple nested method calls, as we usually do, the stack frames get stacked on top of each other. </p> <p>One final note: the memory allocated on the stack is deallocated when a method returns.  The memory allocated on the heap, however, stays there as long as there is a reference to it (either from another object or from a variable in the stack).  Unlike C or C++, in Java, you do not have to free the memory allocated to objects.  The JVM runs a garbage collector that checks for unreferenced objects on the heap and cleans up the memory automatically.</p> <ol> <li> <p>It can also behave like a function/method in the sense that it can be invoked (e.g., <code>this(..)</code>).  In this case, the keyword <code>this</code> represents the constructor of the current class.  We will illustrate more of this on the topic of overloading.\u00a0\u21a9</p> </li> <li> <p>This is not that different from how an OS handles function calls in a machine code, as you will see in CS2100/CS2106.\u00a0\u21a9</p> </li> <li> <p>The other things are JVM implementation independent and not relevant to our discussion here.\u00a0\u21a9</p> </li> <li> <p>Alternatively, you can think of Java as always using call-by-value.  It's just that the value of a reference is, in fact, just a reference.\u00a0\u21a9</p> </li> </ol>"},{"location":"11-inheritance.html","title":"Unit 11: Inheritance","text":"<p>Learning Objectives</p> <p>After completing this unit, students should be able to:</p> <ul> <li>explain inheritance as a mechanism for modeling subtyping and the is-a relationship</li> <li>decide when inheritance is appropriate versus composition, and justify that choice</li> <li>use the extends and super keywords correctly to define and initialize subclasses</li> <li>reason about compile-time types versus runtime types in the presence of inheritance</li> <li>predict the behavior of code involving subtype polymorphism</li> <li>determine when narrowing type conversion (casting) is permitted and when it may fail at runtime</li> </ul> <p>Overview</p> <p>In earlier units, we learned how to build complex abstractions by composing objects, carefully preserving abstraction barriers and separating client and implementer responsibilities. Composition remains our default design tool\u2014but it is not the only one.</p> <p>In this unit, we introduce inheritance, a second mechanism for extending behavior that allows one abstraction to be treated as a more specific version of another. Inheritance is not primarily about code reuse; rather, it is about modeling subtyping\u2014when one object can safely stand in for another.</p> <p>We will examine how inheritance expresses the is-a relationship, how Java supports this via extends and super, and why careless use of inheritance can silently break program meaning. Along the way, we will sharpen an important distinction between compile-time and runtime types, a concept that underpins polymorphism in later units.</p> <p>By the end of this unit, you should not only be able to write subclasses, but also explain when you should not.</p>"},{"location":"11-inheritance.html#extension-with-composition","title":"Extension with Composition","text":"<p>We have seen how composition allows us to compose a new, more complex, class, out of existing classes, without breaking the abstraction barrier of existing classes.  Sometimes, however, composition is not the right approach.  Let's consider the following example.  Let's suppose that we, as a client, want to add color as a property to our <code>Circle</code>.</p> <p>Without penetrating the abstraction barrier of <code>Circle</code>, we can do the following: ColoredCircle v0.1 (with Composition)<pre><code>class ColoredCircle {\n  private Circle circle;\n  private Color color;\n\n  public ColoredCircle(Circle circle, Color color) {\n    this.circle = circle;\n    this.color = color;\n  }\n}\n</code></pre></p> <p>where <code>Color</code> is another abstraction representing the color of shapes.</p> <p>What should we do if we want to calculate the area of our colored circle?  Suppose we already have a <code>ColoredCircle</code> instance called <code>coloredCircle</code>. We could make <code>circle</code> public and call <code>coloredCircle.circle.getArea()</code>, or we could add an accessor and call <code>coloredCircle.getCircle().getArea()</code>.  Both of these are not ideal, since they break the abstraction barrier and reveal that the <code>ColoredCircle</code> class stores a <code>circle</code> (the latter being slightly better than the first).</p> <p>A better alternative is to let <code>ColoredCircle</code> provide its own <code>getArea()</code> method and forward its call to <code>Circle</code>.</p> ColoredCircle v0.2 (with Composition)<pre><code>class ColoredCircle {\n  private Circle circle;\n  private Color color;\n\n  public ColoredCircle(Circle circle, Color color) {\n    this.circle = circle;\n    this.color = color;\n  }\n\n  public double getArea() {\n    return circle.getArea();\n  }\n}\n</code></pre> <p>Then, the client to <code>ColoredCircle</code> can just call <code>coloredCircle.getArea()</code> without knowing how a colored circle is represented internally.  The drawback of this approach is that we might end up with many such boilerplate forwarding methods.</p>"},{"location":"11-inheritance.html#extension-with-inheritance","title":"Extension with Inheritance","text":"<p>Recall the concept of subtyping.  We say that \\(S &lt;: T\\) if any piece of code written for type \\(T\\) also works for type \\(S\\) without changing the code's intended behavior.</p> <p>Now, think about <code>ColoredCircle</code> and <code>Circle</code>.  If someone has written a piece of code that operates on <code>Circle</code> objects.  Do we expect the same code to work on <code>ColoredCircle</code>?  In this example, yes!  A <code>ColoredCircle</code> object should behave just like a circle \u2014 we can calculate its area, calculate its circumference, check if two circles intersect, check if a point falls within the circle, etc.  The only difference, or more precisely, extension, is that it has a color, and perhaps has some methods related to this additional field.  So, <code>ColoredCircle</code> is a subtype of <code>Circle</code>.</p> <p>We now show how we can introduce this subtype relationship in Java, using the <code>extends</code> keyword.  We can reimplement our <code>ColoredCircle</code> class this way:</p> ColoredCircle v0.3 (with Inheritance)<pre><code>class ColoredCircle extends Circle {\n  private Color color;\n\n  public ColoredCircle(Point center, double radius, Color color) {\n    super(center, radius);  // call the parent's constructor\n    this.color = color;\n  }\n}\n</code></pre> <p>We have just created a new type called <code>ColoredCircle</code> as a class that extends from <code>Circle</code>.  We call <code>Circle</code> the parent class or superclass of <code>ColoredCircle</code>; and <code>ColoredCircle</code> a subclass of <code>Circle</code>.  Note that if a class A is a subclass of B, A \\(&lt;:\\) B.  The converse is not true, A \\(&lt;:\\) B does not imply that A is a subclass of B (e.g., <code>int</code> is not a subclass of <code>float</code>).</p> <p>We also say that <code>ColoredCircle</code> inherits from <code>Circle</code>, since all the public fields of <code>Circle</code> (if any) and public methods (like <code>getArea()</code>) are now accessible to <code>ColoredCircle</code>.  Just like a parent-child relationship in real life, however, anything private to the parent remains inaccessible to the child.  This privacy veil maintains the abstraction barrier of the parent from the child, and creates a bit of a tricky situation \u2014 technically a child <code>ColoredCircle</code> object has a center and a radius, but it has no access to it!</p> <p>Line 6 of the code above introduces another keyword in Java: <code>super</code>.  Here, we use <code>super</code> to call the constructor of the superclass, to initialize its center and radius (since the child has no direct access to these fields that it inherited).</p> <p>If a constructor does not explicitly invoke a superclass constructor, the Java compiler automatically inserts a call to the no-argument constructor of the superclass. If the super class does not have a no-argument constructor, you will get a compile-time error. <code>Object</code> does have such a constructor, so if <code>Object</code> is the only superclass, there is no problem. The concept we have shown you is called inheritance and is one of the four pillars of OOP.  We can think of inheritance as a model for the \"is a\" relationship between two entities.</p> <p>With inheritance, we can call <code>coloredCircle.getArea()</code> without knowing how a colored circle is represented internally AND without forwarding methods.</p>"},{"location":"11-inheritance.html#when-not-to-use-inheritance","title":"When NOT to Use Inheritance","text":"<p>Inheritance tends to get overused.  In practice, we seldom use inheritance.  Let's look at some examples of how not to use inheritance, and why.</p> <p>Consider the following example:</p> <pre><code>class Point {\n  private double x;\n  private double y;\n    :\n}\n\nclass Circle extends Point {\n  private double radius;\n    :\n}\n\nclass Cylinder extends Circle {\n  private double height;\n    :\n}\n</code></pre> <p>The difference between these implementations and the one you have seen in Unit 9 is that they use inheritance rather than composition.  </p> <p><code>Circle</code> implemented like the above would have the center coordinate inherited from the parent (so it has three fields, x, y, and radius); <code>Cylinder</code> would have the fields corresponding to a circle, which is its base and height.  In terms of modeling the properties of a circle and a cylinder, we have all the right properties in the right class.</p> <p>When we start to consider methods encapsulated with each object, things start to break down. Consider a piece of code written as follows: <pre><code>void foo(Circle c, Point p) {\n  if (c.contains(p)) {\n    // do something\n  }\n}\n</code></pre></p> <p>Since <code>Cylinder</code> is a subtype of <code>Point</code> according to the implementation above, the code above should still work also if we replace <code>Point</code> with a <code>Cylinder</code> (according to the semantics of subtyping).   But it gets weird \u2014 what is the meaning of a <code>Circle</code> (in 2D) containing a Cylinder (in 3D)?  We could come up with a convoluted meaning that explains this, but it is likely not what the original implementer of <code>foo</code> expects.</p> <p>The message here is this: Use composition to model a has-a relationship; and inheritance for an is-a relationship.  Make sure inheritance preserves the meaning of subtyping.  </p>"},{"location":"11-inheritance.html#ensuring-valid-type-assignment-during-runtime","title":"Ensuring Valid Type Assignment During Runtime","text":"<p>During runtime, Java only allows a variable of compile-time type \\(T\\) to hold a value of type \\(S\\) if \\(S &lt;: T\\).   Otherwise, an error (to be precise, a <code>ClassCastException</code>) will be thrown at runtime.  To avoid this, the Java compiler conservatively enforces this rule at compile time.</p> <p>Consider the following line of code: <pre><code>Circle c = new ColoredCircle(p, 0, blue); // OK\n</code></pre></p> <p>Upon reading this line of code, the compiler determines that the right hand side has compile-time type <code>ColoredCircle</code>, while the left hand side has compile-time type <code>Circle</code>.  Since <code>ColoredCircle</code> is a subtype of <code>Circle</code>, the assignment is allowed.</p> <p>Recall that the compile-time type of a variable is the type declared for it, while the runtime type is the type of the actual value stored in that variable at runtime.  In the example above, after the assignment occured during execution, the compile-time type of <code>c</code> is <code>Circle</code>, while its runtime type is <code>ColoredCircle</code>.</p> <p>Now, consider the following line of code: <pre><code>ColoredCircle c = new Circle(p, 0); // error\n</code></pre></p> <p>Here, the compiler sees that the right hand side has compile-time type <code>Circle</code>, while the left hand side has compile-time type <code>ColoredCircle</code>.  Since <code>Circle</code> is not a subtype of <code>ColoredCircle</code>, the assignment is rejected at compile time.</p> <p>Next, consider the following code snippet: <pre><code>Circle c = new ColoredCircle(p, 0, blue);\nColoredCircle cc = c;\n</code></pre></p> <p>Here, the first line is valid, as we have seen before.  However, the second line will be rejected by the compiler, since the compile-time type of <code>c</code> is <code>Circle</code>, while the compile-time type of <code>cc</code> is <code>ColoredCircle</code>.  Since <code>Circle</code> is not a subtype of <code>ColoredCircle</code>, the assignment is rejected at compile time.  Even though, at runtime, <code>c</code> actually holds a <code>ColoredCircle</code> object, the compiler does not (and cannot) consider that, and only checks the compile-time types of the variables and expressions, line-by-line.</p>"},{"location":"11-inheritance.html#narrowing-type-conversion","title":"Narrowing Type Conversion","text":"<p>While the compiler is not able to consider the runtime types of variables, we, as human, can help it by using a type cast.  For instance, in the last example, we can be sure that <code>c</code> holds the value with runtime type of <code>ColoredCircle</code>, we can perform a type cast to help the compiler verify the assignment: <pre><code>Circle c = new ColoredCircle(p, 0, blue);\nColoredCircle cc = (ColoredCircle) c;\n</code></pre></p> <p>Here, the type cast expression <code>(ColoredCircle) c</code> tells the compiler to treat <code>c</code> as if it has compile-time type <code>ColoredCircle</code>.  This casting is known as narrowing type conversion.  </p> <p>During runtime, since <code>c</code> actually holds a value of runtime type <code>ColoredCircle</code>, the assignment will succeed when the code runs.</p> <p>Typecasting must be used with care.  Here, we are overriding the compiler and ask it to trust us that we know what we are doing and <code>c</code> actually holds a value of type <code>ColoredCircle</code>.</p> <p>Consider the example below: <pre><code>Circle c = new Circle(new Point(0, 0), 1);\nColoredCircle cc = (ColoredCircle) c;\n</code></pre></p> <p>The variable <code>c</code> would hold a value of runtime type <code>Circle</code> after initialization.  However, the programmer is forcing the compiler to treat <code>c</code> as if it has compile-time type <code>ColoredCircle</code>.  This code compiles successfully, but the assignment would fail at runtime, throwing a <code>ClassCastException</code>. </p> <p>Note that the compiler does not blindly trust the programmer.  It still checks that the type conversion is possible.  In this example, since <code>Circle</code> is a supertype of <code>ColoredCircle</code>, it is possible that <code>c</code> holds a value of runtime type <code>ColoredCircle</code>.  Therefore, the compiler allows the code to compile.  If we try to cast between two unrelated types, for example: <pre><code>Circle c = new Circle(new Point(0, 0), 1);\nString s = (String) c; // error\n</code></pre></p> <p>The compiler would reject the code, since <code>Circle</code> and <code>String</code> are unrelated types, and no subtype relationship exists between them.</p>"},{"location":"12-overriding.html","title":"Unit 12: Overriding","text":"<p>Learning Objectives</p> <p>After taking this unit, students should be able to:</p> <ul> <li>explain why every Java class implicitly inherits from Object</li> <li>describe and override Object::toString and Object::equals</li> <li>distinguish between method signature and method descriptor</li> <li>explain what method overriding is and when it occurs</li> <li>reason about compile-time and runtime rules governing overriding</li> <li>use Java annotations correctly, in particular @Override</li> <li>explain how String concatenation triggers implicit toString calls</li> </ul> <p>Overview</p> <p>In the previous units, we introduced inheritance as a mechanism for sharing code and modeling \u201cis-a\u201d relationships between classes. We have also seen that subclasses automatically inherit fields and methods from their parent classes.</p> <p>In this unit, we explore how inheritance allows not only reuse, but also customization of behavior through method overriding. We will see that every class in Java inherits from a common ancestor, Object, and that some of its methods\u2014most notably toString and equals\u2014are designed to be overridden.</p> <p>Along the way, we introduce precise terminology such as method signature and method descriptor, and we examine the rules that govern method overriding. Importantly, these rules are enforced partly during compilation and partly at runtime, illustrating once again Java\u2019s emphasis on early error detection and type safety.</p>"},{"location":"12-overriding.html#object-and-string","title":"<code>Object</code> and <code>String</code>","text":"<p>In Java, every class that does not extend another class inherits from the class <code>Object</code> implicitly.  <code>Object</code> is, therefore, the \"ancestor\" of all classes in Java and is at the root of the class hierarchy.</p> <p>The <code>Object</code> class does not encapsulate anything in particular.  It is a very general class that provides useful methods common to all objects.  Two particularly useful methods are:</p> <ul> <li><code>equals(Object obj)</code>, which checks if two objects are equal to each other, and</li> <li><code>toString()</code>, which returns a string representation of the object as a <code>String</code> object.</li> </ul> <p>Now that we have related classes as well as methods that may be inherited, we will introduce a notation that captures the essence of a method as well as where the method is implemented.  Consider the method <code>equals(Object obj)</code> in the class <code>Object</code>.  First, note that the parameter name <code>obj</code> can be renamed, so the name does not matter.  As such, we can omit them.  Secondly, we need to indicate that the implementation we are interested in is the implementation in the class <code>Object</code>.  So, we can write it simply as <code>Object::equals(Object)</code>.</p>"},{"location":"12-overriding.html#the-tostring-method","title":"The <code>toString</code> Method","text":"<p>The <code>toString</code> method is very special, as this is invoked implicitly by Java, by default, to convert a reference object to a <code>String</code> object during string concatenation using the operator <code>+</code>.</p> <p>We showed you that in Python, <code>4 + \"Hello\"</code> would result in a type mismatch error.  In Java, however, <code>4 + \"Hello\"</code> will result in the string <code>\"4Hello\"</code>.  In this example, the primitive value 4 is converted to a string before concatenation.</p> <p>A more interesting scenario is what happens if we try to concatenate, say, a <code>Circle</code> object with a string.  Let's say we have:</p> <pre><code>Circle c = new Circle(new Point(0, 0), 4.0);\nString s = \"Circle c is \" + c;\n</code></pre> <p>You will see that <code>s</code> now contains the string \"Circle c is Circle@1ce92674 \" (the seemingly unintelligible text after @ is the reference to the object so your result will be different).</p> <p>What happened here is that the <code>+</code> operator sees that one of the operands is a string but the other is not, so it converts the one that is not a string to a string by calling its <code>toString()</code> method automatically for us.  This is equivalent to<sup>1</sup> <pre><code>Circle c = new Circle(new Point(0, 0), 4.0);\nString s = \"Circle c is \" + c.toString();\n</code></pre></p> <p>Recall that in our <code>Circle</code> class (up to version 0.5) we do not have any <code>Circle::toString()</code> method.  The <code>toString</code> method that we invoked here is the <code>toString</code> method inherited from its parent <code>Object</code> (i.e., <code>Object::toString()</code>).</p> <p><code>jshell</code> and <code>toString</code></p> <p>Recall that <code>jshell</code> is a REPL tool.  After evaluating an expression, <code>jshell</code> prints the resulting value.  If the resulting value is a reference type, <code>jshell</code> will invoke <code>toString</code> to convert the reference type to a string first, before printing the string.  This behavior makes <code>toString</code> especially important during debugging.</p>"},{"location":"12-overriding.html#customizing-tostring-for-circle","title":"Customizing <code>toString</code> for <code>Circle</code>","text":"<p>The <code>Object::toString()</code> method is not very user-friendly.  Ideally, when we print a <code>Circle</code> object, say, for debugging, we want to see its center and its radius.  To do so, we can define our own <code>toString</code> method in <code>Circle</code>  (i.e., <code>Circle::toString()</code>).  Let's upgrade our <code>Circle</code> class to do this:</p> Circle v0.6, with toString<pre><code>/**\n * A Circle object encapsulates a circle on a 2D plane.  \n */\nclass Circle {\n  private Point c;   // the center\n  private double r;  // the length of the radius\n\n  /**\n   * Create a circle centered on Point c with given radius r\n   */\n  public Circle(Point c, double r) {\n    this.c = c;\n    this.r = r;\n  }\n\n  /**\n   * Return the area of the circle.\n   */\n  public double getArea() {\n    return Math.PI * this.r * this.r;\n  }\n\n  /**\n   * Return true if the given point p is within the circle.\n   */\n  public boolean contains(Point p) {\n    return false;\n    // TODO: Left as an exercise\n  }\n\n  /**\n   * Return the string representation of this circle.\n   */\n  @Override\n  public String toString() {\n    return \"{ center: \" + this.c + \", radius: \" + this.r + \" }\";\n  }\n}\n</code></pre> <p>The body of the method <code>Circle::toString()</code> simply constructs a string representation for this circle object and returns it.  With this <code>toString</code> implemented, the output will look something like this: <pre><code>Circle c is { center: (0.0, 0.0), radius: 4.0 }\n</code></pre></p> <p>Note that when the center <code>this.c</code> is converted to a string, the <code>toString</code> method of the <code>Point</code> class is invoked (i.e., <code>Point::toString()</code>).  We leave the implementation of <code>Point::toString()</code> as an exercise.</p>"},{"location":"12-overriding.html#method-signature-and-descriptor","title":"Method Signature and Descriptor","text":"<p>Let's define the method signature of a method as the method name and the number of parameters, the type of each parameter, and the order of its parameters.  We define the method descriptor as the method signature plus the return type.</p> <p>The notions of method signature and descriptor are important ones for the compilers, as they are what the compiler uses to uniquely identify a method.  </p> <p>Suppose we have the following class,</p> <pre><code>class C {\n  A foo(B1 x, B2 y) {\n  }\n}\n</code></pre> <p>Using our notation, we denote the method signature for <code>foo</code> in <code>C</code> as <code>C::foo(B1, B2)</code>.  The method descriptor for the same implementation is <code>A C::foo(B1, B2)</code>.   </p> <p>We may exclude the class names when we want to talk about the method regardless of where it is implemented.  Lastly, we may omit the parameters if we want to talk about all the methods with the given name (e.g., <code>A::foo</code> or <code>foo</code>).</p>"},{"location":"12-overriding.html#method-overriding","title":"Method Overriding","text":"<p>Coming back to our <code>Circle</code> v0.6.  What we just did when we defined <code>Circle::toString()</code> is called method overriding in OOP.  Inheritance is not only good for extending the behavior of an existing class but through method overriding, we can alter the behavior of an existing class as well.</p> <p>When a subclass defines an instance method with the same method descriptor as an instance method in the parent class, we say that the instance method in the subclass overrides the instance method in the parent class<sup>2</sup>.  In the example above, <code>Circle::toString</code> has overridden <code>Object::toString</code>.</p>"},{"location":"12-overriding.html#the-override-annotation","title":"The <code>@Override</code> Annotation","text":"<p>Line 37 in the <code>Circle</code> example above contains the symbol <code>@Override</code>.  This symbol is an example of annotation in Java.  An annotation is not part of the program and does not affect the bytecode generated.  Instead, it is a hint to the compiler.  Remember that the compiler is our friend who will do its best to help detect errors early, during compilation.  We must do our part to help the compiler help us.  Here, <code>@Override</code> is a hint to the compiler that the following method, <code>toString</code>, is intended to override the method in the parent class.  In case, there is a typo and overriding is not possible, the compiler will let us know.</p> <p>It is therefore recommended and expected that all overriding methods in your code are annotated with <code>@Override</code>.</p> <p>Using <code>super</code> To Access Overridden Methods</p> <p>After a subclass overrides a method in the superclass, the methods that have been overridden can still be called, with the <code>super</code> keyword. For instance, the following <code>Circle::toString</code> calls <code>Object::toString</code> to prefix the string representation of the circle with <code>Circle@1ce92674</code>. <pre><code>@Override\npublic String toString() {\n      return super.toString() + \" { center: \" + this.c + \", radius: \" + this.r + \" }\";\n}\n</code></pre></p> <ol> <li> <p>Calling <code>toString</code> explicitly is not wrong, but we usually omit the call to keep the code readable and succinct.\u00a0\u21a9</p> </li> <li> <p>It is possible to override a method in some cases when the return type is different.  We will discuss this during recitations.\u00a0\u21a9</p> </li> </ol>"},{"location":"13-overloading.html","title":"Unit 13: Overloading","text":"<p>Learning Objectives</p> <p>After reading this unit, students should be able to:</p> <ul> <li>explain what method overloading is and how it differs from method overriding</li> <li>identify when two methods are considered overloaded in Java</li> <li>correctly define overloaded methods and constructors by varying parameter types, order, or arity</li> <li>explain why changing only parameter names or return types does not result in overloading</li> <li>reason about which overloaded method is selected at compile time based on argument types</li> </ul> <p>Overview</p> <p>In the previous unit, we studied method overriding, which allows subclasses to replace the behavior of inherited methods at runtime. Overriding supports polymorphism, where the same method call can behave differently depending on the object\u2019s runtime type.</p> <p>In this unit, we shift focus to method overloading, which addresses a different concern: convenience and expressiveness. Overloading allows a class to provide multiple methods with the same name that operate on different kinds of inputs, while still performing conceptually similar tasks.</p> <p>Unlike overriding, overloading is resolved entirely at compile time. Understanding this distinction is essential, as it explains both what Java allows you to overload, and why some seemingly reasonable overloads are rejected by the compiler.</p>"},{"location":"13-overloading.html#method-overloading","title":"Method overloading","text":"<p>In the previous unit, we introduced method overriding \u2014 when a subclass defines an instance method with the same method descriptor as an instance method in the parent class.</p> <p>In contrast, method overloading occurs when a class has access to (either defined or inherited) two or more methods with the same name but a different method signatures. In other words, we create an overloaded method by changing the type, order, or number of parameters of the method while keeping the method name identical.</p> <p>Let's consider an <code>add</code> method which allows us to add two numbers, and returns the result. What if we would like to create an <code>add</code> method to sum up three numbers?</p> <pre><code>public int add(int x, int y) {\n  return x + y;\n}\n\npublic int add(int x, int y, int z) {\n  return x + y + z;\n}\n</code></pre> <p>In the example above, the methods <code>add(int, int)</code> and <code>add(int, int, int)</code> are overloaded. They have the same name but a different number of parameters. We can see that this allows us to write methods to handle differing inputs.</p> <p>Now let's consider our <code>Circle</code> class again. Our <code>Circle::contains(Point)</code> method allows us to check if a <code>Point</code> is within the radius of the current instance of the <code>Circle</code>. We would like to create a new method <code>Circle::contains(double, double)</code> which will allow us to check if an (<code>x</code>, <code>y</code>) coordinate (another valid representation of a point) is within our circle.</p> Circle v0.6a with Overloaded `contains` Method<pre><code>class Circle {\n  private Point c;\n  private double r;\n\n  public Circle(Point c, double r) {\n    this.c = c;\n    this.r = r;\n  }\n\n  public double getArea() {\n    return Math.PI * this.r * this.r;\n  }\n\n  public boolean contains(Point p) {\n    return false;\n    // TODO: Left as an exercise\n  }\n\n  public boolean contains(double x, double y) {\n    return false;\n    // TODO: Left as an exercise\n  }\n\n  @Override\n  public String toString() {\n    return \"{ center: \" + this.c + \", radius: \" + this.r + \" }\";\n  }\n}\n</code></pre> <p>In the above example, <code>Circle::contains(Point)</code> and <code>Circle::contains(double, double)</code> are overloaded methods.</p> <p>Recall that overloading requires changing the order, number, and/or type of parameters and says nothing about the names of the parameters. Consider the example below, where we have two <code>contains</code> methods in which we swap parameter names.</p> <pre><code>  public boolean contains(double x, double y) {\n    return false;\n    // TODO: Left as an exercise\n  }\n\n  public boolean contains(double y, double x) {\n    return false;\n    // TODO: Left as an exercise\n  }\n</code></pre> <p>Because parameter names are not part of the method signature, swapping parameter names does not produce a new method.  These two methods have the same method signature, and therefore <code>contains(double, double)</code> and <code>contains(double, double)</code> are not distinct methods.  The Java compiler will reject this code with an error indicating that the method is already defined.</p> <p>Note that the return type is part of the method descriptor, but not part of the method signature, so we cannot have two methods with the signature but different return types. For example, the following code will also be rejected by the Java compiler.</p> <pre><code>  public int add(int x, int y) {\n    return x + y;\n  }\n\n  public double add(int x, int y) {\n    return (double)(x + y);\n  }\n</code></pre> <p>On the other hand, we can have two overloaded methods with different return types:</p> <pre><code>  public int add(int x, int y) {\n    return x + y;\n  }\n\n  public double add(double x, double y) {\n    return x + y;\n  }\n</code></pre>"},{"location":"13-overloading.html#overloading-constructor","title":"Overloading Constructor","text":"<p>As a constructor is also a method, it is possible to overload the class constructor as well. As in the example below, we can see an overloaded constructor which gives us a handy way to instantiate a <code>Circle</code> object that is the unit circle.</p> Circle v0.6b with Overloading Constructor<pre><code>class Circle {\n  private Point c;\n  private double r;\n\n  public Circle(Point c, double r) {\n    this.c = c;\n    this.r = r;\n  }\n\n  // Overloaded constructor\n  public Circle() {\n    this.c = new Point(0, 0);\n    this.r = 1;\n  }\n\n  // Other methods omitted \n}\n</code></pre> <pre><code>// c1 points to a new Circle object with a center (1, 1) and a radius of 2\nCircle c1 = new Circle(new Point(1, 1), 2);\n// c2 points to a new Circle object with a center (0, 0) and a radius of 1\nCircle c2 = new Circle();\n</code></pre> <p>It is also possible to overload <code>static</code> class methods in the same way as instance methods. In the next unit, we will see how Java chooses which method implementation to execute when a method is invoked.</p> <p>Similar to <code>super</code>, the <code>this</code> keyword can be used to invoke another constructor.  While <code>super</code> is used to invoke the constructor in the superclass, <code>this</code> invokes an overloaded constructor in the same class. This is particularly useful as it allows us to avoid duplicating code. For example, we can modify our overloaded constructor in the <code>Circle</code> class to invoke the primary constructor instead of directly initializing the instance variables.</p> Circle v0.6c with Overloaded Constructor using this()<pre><code>class Circle {\n  private Point c;\n  private double r;\n\n  public Circle(Point c, double r) {\n    this.c = c;\n    this.r = r;\n  }\n\n  // Overloaded constructor\n  public Circle() {\n    this(new Point(0, 0), 1);  // call the primary constructor\n  }\n\n  // Other methods omitted \n}\n</code></pre>"},{"location":"14-polymorphism.html","title":"Unit 14: Polymorphism","text":"<p>Learning Objectives</p> <p>After reading this unit, students should be able to:</p> <ul> <li>explain polymorphism as runtime method selection based on an object\u2019s runtime type</li> <li>distinguish between compile-time type checking and runtime dynamic binding</li> <li>explain why method overriding requires an identical method signature</li> <li>correctly override equals(Object) and explain why overloading equals is insufficient</li> </ul> <p>Overview</p> <p>In the previous units, we have seen how inheritance allows one class to reuse and extend another, and how method overloading enables multiple methods with the same name to coexist based on parameter types. In this unit, we study polymorphism, which brings these ideas together by allowing the same method call to behave differently depending on the runtime type of the object. Polymorphism is what allows object-oriented programs to be extensible, reusable, and robust in the presence of new classes added in the future, often without modifying or even recompiling existing code.</p>"},{"location":"14-polymorphism.html#taking-on-many-forms","title":"Taking on Many Forms","text":"<p>Method overriding enables polymorphism, the fourth and the final pillar of OOP, and arguably the most powerful one.  It allows us to change how existing code behaves, without changing a single line of the existing code (or even having access to the code).</p> <p>Consider the function <code>say(Object)</code> below: <pre><code>void say(Object obj) {\n  System.out.println(\"Hi, I am \" + obj.toString());\n}\n</code></pre></p> <p>Note that this method receives an <code>Object</code> instance.  Since both <code>Point</code> &lt;: <code>Object</code> and <code>Circle</code> &lt;: <code>Object</code>, we can do the following: <pre><code>Point p = new Point(0, 0);\nsay(p);\nCircle c = new Circle(p, 4);\nsay(c);\n</code></pre></p> <p>When executed, <code>say</code> will first print <code>Hi, I am (0.0, 0.0)</code>, followed by <code>Hi, I am { center: (0.0, 0.0), radius: 4.0 }</code>.  We are invoking the overriding <code>Point::toString()</code> in the first call, and <code>Circle::toString()</code> in the second call.  The same method invocation <code>obj.toString()</code> causes two different methods to be called in two separate invocations!</p> <p>In biology, polymorphism means that an organism can have many different forms.  Here, the variable <code>obj</code> can have many \"forms\" as well, depending on its runtime type.  While the compiler checks whether a method call is legal based on the compile-time type, deciding which method is invoked is done by the Java runtime, during execution, as it depends on the runtime type of the <code>obj</code>.  This is called dynamic binding or late binding or dynamic dispatch.</p> <p>Before we get into this in more detail, let's consider overriding <code>Object::equals(Object)</code>.</p>"},{"location":"14-polymorphism.html#the-equals-method","title":"The <code>equals</code> method","text":"<p><code>Object::equals(Object)</code> compares if two object references referred to the same object.  Suppose we have:</p> <pre><code>Circle c0 = new Circle(new Point(0, 0), 10);\nCircle c1 = new Circle(new Point(0, 0), 10);\nCircle c2 = c1;\n</code></pre> <p><code>c2.equals(c1)</code> returns <code>true</code>, but <code>c0.equals(c1)</code> returns <code>false</code>.  Even though <code>c0</code> and <code>c1</code> are semantically the same, they refer to two different objects.</p> <p>To compare if two circles are semantically the same, we need to override this method<sup>1</sup>.  After all, Java does not know what it means for two circles to be equal, so we have to define it.</p> Circle v0.7a with Overriding equals<pre><code>/**\n * A Circle object encapsulates a circle on a 2D plane.\n */\nclass Circle {\n  private Point c;   // the center\n  private double r;  // the length of the radius\n\n  /**\n   * Create a circle centered on Point c with given radius r\n   */\n  public Circle(Point c, double r) {\n    this.c = c;\n    this.r = r;\n  }\n\n  /**\n   * Return the area of the circle.\n   */\n  public double getArea() {\n    return Math.PI * this.r * this.r;\n  }\n\n  /**\n   * Return true if the given point p is within the circle.\n   */\n  public boolean contains(Point p) {\n    return false;\n    // TODO: Left as an exercise\n  }\n\n  /**\n   * Return the string representation of this circle.\n   */\n  @Override\n  public String toString() {\n    return \"{ center: \" + this.c + \", radius: \" + this.r + \" }\";\n  }\n\n  /**\n   * Return true the object is the same circle (i.e., same center, same radius).\n   */\n  @Override\n  public boolean equals(Object obj) {\n    if (obj instanceof Circle) {\n      Circle circle = (Circle) obj;\n      return (circle.c.equals(this.c) &amp;&amp; circle.r == this.r);\n    }\n    return false;\n  }\n}\n</code></pre> <p>This is more complicated than <code>toString</code>.  There are a few new concepts involved here:</p> <ul> <li><code>equals</code> takes in a parameter of compile-time type <code>Object</code>.  It only makes sense if we compare (during runtime) a circle with another circle.  So, we first check if the runtime type of <code>obj</code> is a subtype of <code>Circle</code>.  This is done using the <code>instanceof</code> operator.  The operator returns <code>true</code> if <code>obj</code> has a runtime type that is a subtype of <code>Circle</code>.</li> <li>To compare <code>this</code> circle with the given circle, we have to access the center <code>c</code> and radius <code>r</code>.  But if we access <code>obj.c</code> or <code>obj.r</code>, the compiler will complain.  As far as the compiler is concerned, <code>obj</code> has the compile-time type <code>Object</code>, and there is no such fields <code>c</code> and <code>r</code> in the class <code>Object</code>!  This is why, after assuring that the runtime type of <code>obj</code> is a subtype of <code>Circle</code>, we assign <code>obj</code> to another variable <code>circle</code> that has the compile-time type <code>Circle</code>.  We finally check if the two centers are equal (again, <code>Point::equals</code> is left as an exercise) and if the two radii are equal<sup>2</sup>.</li> </ul> <p>All these complications would go away, however, if we define <code>Circle::equals</code> to take in a <code>Circle</code> as a parameter, like this:</p> Circle v0.7b with Overriding equals<pre><code>class Circle {\n    :\n  /**\n   * Return true the object is the same circle (i.e., same center, same radius).\n   */\n  @Override\n  public boolean equals(Circle circle) {\n    return (circle.c.equals(this.c) &amp;&amp; circle.r == this.r);\n  }\n}\n</code></pre> <p>This version of <code>equals</code>, however, does not override <code>Object::equals(Object)</code>.  Since we hinted to the compiler that we meant this to be an overriding method, using <code>@Override</code>, the compiler will give us an error.  This method is not treated as method overriding, since the method signature for <code>Circle::equals(Circle)</code> is different from <code>Object::equals(Object)</code>.</p> <p>Why then is overriding important?  Why should we override <code>Object::equals(Object)</code> with <code>Circle::equals(Object)</code> and not just overload it with <code>Circle::equals(Circle)</code>?</p>"},{"location":"14-polymorphism.html#the-power-of-polymorphism","title":"The Power of Polymorphism","text":"<p>Let's consider the following example.  Suppose we have a general <code>contains</code> method that takes in an array of objects.  The array can store any type of object: <code>Circle</code>, <code>Square</code>, <code>Rectangle</code>, <code>Point</code>, <code>String</code>, etc.  The method <code>contains</code> also takes in a target <code>obj</code> to search for, and returns true if there is an object in <code>array</code> that equals to <code>obj</code>.</p> contains v0.1 with Polymorphism<pre><code>boolean contains(Object[] array, Object obj) {\n  for (Object curr : array) {\n    if (curr.equals(obj)) {\n      return true;\n    }\n  }\n  return false;\n}\n</code></pre> <p>With overriding and polymorphism, the magic happens in Line 3 \u2014 depending on the runtime type of <code>curr</code>, the corresponding, customized version of <code>equals</code> is called to compare against <code>obj</code>.   So if the runtime type of <code>curr</code> is <code>Circle</code>, then we will invoke <code>Circle::equals(Object)</code> and if the runtime type of <code>curr</code> is <code>Point</code>, then we will invoke <code>Point::equals(Object)</code>.  This, of course, assumes that <code>Object::equals(Object)</code> is overridden in both classes.</p> <p>However, if <code>Circle::equals(Object)</code> takes in a <code>Circle</code> as the parameter, the call to <code>equals</code> inside the method <code>contains</code> would not invoke <code>Circle::equals(Circle)</code>.  It would invoke <code>Object::equals(Object)</code> instead due to the matching method signature, and we cannot search for <code>Circle</code> based on semantic equality.</p> <p>Why is this the case?  Look closely at how the method is invoked: <code>curr.equals(obj)</code>.  Here, we can see that the parameter we are passing is <code>obj</code>.  The compile-time type of <code>obj</code> is <code>Object</code> as seen from the parameter declaration at Line 2.  So at compile-time, the compiler only know that its type is <code>Object</code>, and it can only type-check calls to methods that exist in <code>Object</code>. The compiler therefore commits to the method signature <code>equals(Object)</code> before the program ever runs.</p> <p>To have a generic <code>contains</code> method without polymorphism and overriding, we will have to do something like this: contains v0.2 without Polymorphism<pre><code>boolean contains(Object[] array, Object obj) {\n  for (Object curr : array) {\n    if (obj instanceof Circle) {\n      if (curr.equals((Circle)obj)) {\n        return true;\n      }\n    } else if (obj instanceof Square) {\n      if (curr.equals((Square)obj)) {\n        return true;\n      }\n    } else if (obj instanceof Point) {\n      if (curr.equals((Point)obj)) {\n        return true;\n      }\n    }\n     :\n  }\n  return false;\n}\n</code></pre></p> <p>which is not scalable since every time we add a new class, we have to come back to this method and add a new branch to the <code>if-else</code> statement!</p> <p>As this example has shown, polymorphism allows us to write succinct code that is future-proof.  By dynamically deciding which method implementation to execute during runtime, the implementer can write short yet very general code that works for existing classes as well as new classes that might be added in the future by the client, without even the need to re-compile.</p> <p>Different Types of Polymorphism</p> <p>The term polymorphism is used in different contexts to mean different things.  In CS2030S, when we refer to the term \"polymorphism\", we are referring exclusively to, more precisely, subtype polymorphism (also known as inclusion polymorphism). </p> <p>In other literature, you may come across two other types of polymorphism.  Generics (Unit 23) is also called parametric polymorphism.  Method overloading (Unit 13) is sometimes refer to as ad-hoc polymorphism.  We don't use these terms in CS2030S.</p> <ol> <li> <p>If we override <code>equals()</code>, we should generally override <code>hashCode()</code> as well, but let's leave that for another lesson on another day.\u00a0\u21a9</p> </li> <li> <p>The right way to compare two floating-point numbers is to take their absolute difference and check if the difference is small enough.  We are sloppy here to keep the already complicated code a bit simpler.  You shouldn't do this in your code.\u00a0\u21a9</p> </li> </ol>"},{"location":"15-dynamic-binding.html","title":"Unit 15: Method Invocation","text":"<p>Learning Objectives</p> <p>After this unit, the student should be able to:</p> <ul> <li>explain the two-step method invocation process in Java (compile-time method selection and runtime method dispatch)</li> <li>predict which method implementation is executed for a given invocation, and explain why class methods are statically bound</li> </ul> <p>Overview</p> <p>In earlier units, we learned how overloading, overriding, and polymorphism allow a single method call to behave differently depending on the object it is invoked on. This enables flexible and extensible program designs, but it also raises an important question in a statically typed language like Java: If many decisions are made at compile time, how does Java support dynamic behavior at run time?</p> <p>This unit answers that question by explaining how Java resolves method invocations. We will see that method invocation is a two-step process: one step performed during compilation, and another during execution. Each step uses different information and determines different aspects of the method call.</p> <p>Understanding this process explains why overloading is resolved at compile time, why overriding supports dynamic binding, and why class methods do not participate in dynamic binding. By the end of this unit, method invocation will no longer seem magical, but a precise and predictable mechanism.</p>"},{"location":"15-dynamic-binding.html#how-does-dynamic-binding-work","title":"How does Dynamic Binding work?","text":"<p>We have seen that, with the power of dynamic binding and polymorphism, we can write succinct, future-proof code.  Recall that example below, where the magic happens in Line 4.  The method invocation <code>curr.equals(obj)</code> will call the corresponding implementation of the <code>equals</code> method depending on the runtime type of <code>curr</code>.</p> contains v0.1 with Polymorphism<pre><code>boolean contains(Object[] array, Object obj) {\n  for (Object curr : array) {\n    if (curr.equals(obj)) {\n      return true;\n    }\n  }\n  return false;\n}\n</code></pre> <p>How does dynamic binding work?  To be more precise, when the method <code>equals</code> is invoked on the target <code>curr</code>, how does Java decide which method implementation is this invocation bound to?  While we have alluded to the fact that the runtime type of the target <code>curr</code> plays a role, this is not the entire story.  Recall that we may have multiple versions of <code>equals</code> due to overloading.  So, Java also needs to decide, among the overloaded <code>equals</code>, which version of <code>equals</code> this particular invocation is bound to.</p> <p>To do so, Java splits the problem of method invocation into two separate questions:</p> <ul> <li>Which method signature is being called? (decided at compile time)</li> <li>Which class provides the implementation? (decided at run time)</li> </ul> <p>These two decisions are made independently, using different types of information.</p>"},{"location":"15-dynamic-binding.html#during-compile-time","title":"During Compile Time","text":"<p>During compilation, Java determines the method descriptor of the method invoked, using the compile-time type of the target.</p> <p>For example, in the line <pre><code>boolean same = curr.equals(obj)\n</code></pre> above, the target <code>curr</code> has the compile-time type <code>Object</code>.</p> <p>Let's generalize the compile-time type of the target to \\(C\\).  To determine the method descriptor, the compiler searches for all methods in \\(C\\) (including inherited methods) that can be correctly invoked on the given argument and the given return type.  Methods inherited from \\(C\\)'s supertypes are included in the search.</p> <p>In the example above, we look at the class <code>Object</code>, and there is only one method called <code>equals</code>.  The method can be correctly invoked with one argument of type <code>Object</code> and returns a <code>boolean</code>.  Therefore, the method descriptor <code>boolean equals(Object)</code> is chosen.</p> <p>What if more than one methods can correctly accept the argument?  In this case, we choose the most specific one.  Intuitively, a method \\(M\\) is more specific than method \\(N\\) if the arguments to \\(M\\) can be passed to \\(N\\) without compilation error.  You can also see it as preferring the ethod whose parameter types are the \"closest\" to the argument's compile-time type.  </p> <p>For example, let's say a class <code>Circle</code> implements:</p> <pre><code>boolean equals(Circle c) { .. }\n\n@Override\nboolean equals(Object c) { .. }\n</code></pre> <p>Then, <code>equals(Circle)</code> is more specific than <code>equals(Object)</code>.  Every <code>Circle</code> is an <code>Object</code>, but not every <code>Object</code> is a <code>Circle</code>. Let's try to understand this using our definition of \"more specific\" above.</p> <p>Consider the second part of the definition, \"if the arguments to \\(M\\) can be passed to \\(N\\) without compilation error\". We need to find which arguments can be accepted by the methods we wish to compare.  In the case of <code>equals(Circle)</code>, it can accept an argument of compile-time type <code>Circle</code> (and all its subclasses), but not an argument of compile-time type <code>Object</code>.  On the other hand, <code>equals(Object)</code> can accept an argument of compile-time type <code>Object</code> and all its subclasses, including <code>Circle</code>.</p> <p>Therefore, since all arguments to <code>equals(Circle)</code> can be passed to <code>equals(Object)</code> without compilation error, we say <code>equals(Circle)</code> is more specific than <code>equals(Object)</code>.</p> <p>There is also the possibility that when comparing two methods, none of the two methods is more specific than the other.  For instance, given <code>S1</code> &lt;: <code>T</code> and <code>S2</code> &lt;: <code>T</code>, <code>foo(S1)</code> is not more specific than <code>foo(S2)</code> and <code>foo(S2)</code> is not more specific than <code>foo(S1)</code>.  If the Java compiler fails to determine a single most specific method, it will throw a compilation error.</p> <p>Otherwise, once the Java compiler determines the most specific method, it stores the method's descriptor (return type and signature) in the generated bytecode.  This chosen descriptor will never change during runtime, only the class that provides the implementation may change.</p> <p>In the example above, the method descriptor <code>boolean equals(Object)</code> will be stored in the generated binaries.  Note that it does not include information about the class that implements this method.  The class from which this method implementation will be taken is determined in Step 2 during run time.</p>"},{"location":"15-dynamic-binding.html#during-runtime","title":"During Runtime","text":"<p>During execution, when a method is invoked, the method descriptor from Step 1 is first retrieved.  Then, the runtime type of the target is determined.  Let the runtime type of the target be \\(R\\).  Java then looks for an accessible method with the matching descriptor in \\(R\\).  If no such method is found, the search will continue up the class hierarchy, first to the parent class of \\(R\\), then to the grand-parent class of \\(R\\), and so on, until we reach the root <code>Object</code>.  The first method implementation with a matching method descriptor found will be the one executed.</p> <p>For example, let's consider the invocation in the highlighted line below again:</p> v0.1 without Polymorphism<pre><code>boolean contains(Object[] array, Object obj) {\n  for (Object curr : array) {\n    if (curr.equals(obj)) {\n      return true;\n    }\n  }\n  return false;\n}\n</code></pre> <p>Let's say that <code>curr</code> points to a <code>Circle</code> object during runtime.  Suppose that the <code>Circle</code> class does not override the method <code>equals</code> in <code>Object</code>.  As a result, Java cannot find a matching method descriptor <code>boolean equals(Object)</code> in the method <code>Circle</code>.  It then looks for the method in the parent of <code>Circle</code>, which is the class <code>Object</code>.  It finds the method <code>boolean Object::equals(Object)</code> with a matching descriptor.  Thus, the method <code>boolean Object::equals(Object)</code> is executed.</p> <p>Now, suppose that <code>Circle</code> overrides the method <code>boolean Object::equals(Object)</code> with its own <code>boolean Circle::equals(Object)</code> method.  Since Java starts searching from the class <code>Circle</code>, it finds the method <code>boolean Circle::equals(Object)</code> that matches the descriptor.  In this case, <code>curr.target(obj)</code> will invoke the method <code>boolean Circle::equals(Object)</code> instead.</p> <p>This search works because Java guarantees that a method that overrides another must have the compatible method descriptor, ensuring that the runtime lookup is type-safe.</p>"},{"location":"15-dynamic-binding.html#invocation-of-class-methods","title":"Invocation of Class Methods","text":"<p>The description above applies to instance methods.  Class methods, on the other hand, do not support dynamic binding.  The method to invoke is resolved statically during compile time and is fixed at compie time.  The same process in Step 1 is taken, but during run time, Java will always invoke the method defined in the compile-time type of the target, ignore the runtime type.</p>"},{"location":"16-lsp.html","title":"Unit 16: Liskov Substitution Principle","text":"<p>Learning Objectives</p> <p>After completing this unit, students should be able to:</p> <ul> <li>Explain why inheritance and method overriding can introduce subtle bugs when client expectations are violated.</li> <li>State the Liskov Substitution Principle (LSP) and explain it in terms of substitutability and observable behavior.</li> <li>Identify violations of LSP by reasoning about method specifications and client assumptions.</li> <li>Relate LSP to testing, explaining why subclasses must pass all tests written for their superclasses.</li> <li>Use <code>final</code> appropriately to prevent unsafe inheritance or overriding when correctness depends on fixed behavior.</li> </ul> <p>Overview</p> <p>In the previous units, we saw how polymorphism allows code to be written against abstractions, enabling clients and implementers to evolve independently. We also learned how method overriding lets subclasses customize behavior while preserving a common interface.</p> <p>However, with this flexibility comes risk. When inheritance and overriding are used carelessly, they can silently change the behavior of existing code\u2014sometimes without causing any compilation errors. These bugs are often hard to trace, because the client code itself has not changed.</p> <p>In this unit, we study the Liskov Substitution Principle (LSP), a fundamental rule that governs when inheritance is safe to use. LSP formalizes the idea that a subclass should be usable anywhere its superclass is expected, without breaking existing assumptions. We will see how violating this principle can lead to subtle runtime bugs, how LSP relates to testing and specifications, and how Java provides tools such as <code>final</code> to help prevent unsafe inheritance.</p>"},{"location":"16-lsp.html#the-responsibility-when-using-inheritance","title":"The Responsibility When Using Inheritance","text":"<p>As you have seen in Unit 14, polymorphism is a powerful tool that allows a client to change the behavior of existing code written by the implementer, behind the abstraction barrier.</p> <p>As Ben Parker (aka Uncle Ben) said, \"With great power, comes great responsibility.\"   A developer using inheritance and method overriding must do so carefully.  Since overriding can change how existing code behaves, they can easily break existing code and introduce bugs.  Since the client may not have access to the existing code behind the abstraction barrier, it is often tricky to trace and debug.  Furthermore, the implementer would not appreciate it if their code was working perfectly until one day, someone overriding a method causes their code to fail, even without the implementer changing anything in their code.</p> <p>Unfortunately, this responsibility cannot be fully enforced by the compiler. It thus becomes a developer's responsibility to ensure that any inheritance with method overriding does not introduce bugs to existing code.  This brings us to the Liskov Substitution Principle (LSP), which says: \"Let \\(\\phi(x)\\) be a property provable about objects \\(x\\) of type \\(T\\). Then \\(\\phi(y)\\) should be true for objects \\(y\\) of type \\(S\\) where \\(S &lt;: T\\).\"</p> <p>This is consistent with the definition of subtyping, \\(S &lt;: T\\), but spelled out more formally.</p> <p>Let's consider the following example method, <code>Course::marksToGrade</code>, which takes in the marks of a student and returns the grade 'A', 'B', 'C', or 'F' as a <code>char</code>.  How <code>Course::marksToGrade</code> is implemented is not important.  Let's look at how it is used.</p> <pre><code>void displayGrade(Course c, double marks) {\n  char grade = c.marksToGrade(marks);\n  if (grade == 'A')) {\n    System.out.println(\"well done\");\n  else if (grade == 'B') {\n    System.out.println(\"good\");\n  else if (grade == 'C') {\n    System.out.println(\"ok\");\n  } else {\n    System.out.println(\"retake again\");\n  }\n}\n</code></pre> <p>Now, suppose that one day, someone comes along and creates a new class <code>CSCUCourse</code> that inherits from <code>Course</code>, and overrides <code>marksToGrade</code> so that it now returns only 'S' and 'U'.  Since <code>CSCUCourse</code> is a subclass of <code>Course</code>, we can pass an instance to <code>displayGrade</code>:</p> <pre><code>displayGrade(new CSCUCourse(\"GEQ1000\"), 100);\n</code></pre> <p>and suddenly <code>displayGrade</code> is displaying <code>retake again</code> even if the student is scoring 100 marks.</p> <p>The example above shows that we are violating the LSP unintentionally. The object <code>m</code> of type <code>Course</code> has the property: <code>m.marksToGrade</code> always returns a value in the set { <code>'A'</code>, <code>'B'</code>, <code>'C'</code>, <code>'F'</code> }, that the method <code>displayGrade</code> depends on explicitly.  The subclass <code>CSCUCourse</code> violated that and made <code>m.marksToGrade</code> return <code>'S'</code> or <code>'U'</code>, breaking the assumption made by <code>displayGrade</code> and causing it to fail.</p> <p>LSP cannot be enforced by the compiler<sup>1</sup>.  LSP violations do not usually result in compilation errors. The program type-checks successfully, but fails to behave correctly at runtime because the compiler cannot reason about semantic properties such as \u201cwhat values this method is expected to return.  </p> <p>The properties of an object, therefore, have to be managed and agreed upon among programmers.  A common way is to document these properties as part of the code documentation.  The key issue in LSP violations is not the implementation of a method, but the expectations that client code relies on. These expectations form part of the method\u2019s specification, even if they are not explicitly written in code.</p>"},{"location":"16-lsp.html#lsp-through-the-lens-of-testing","title":"LSP Through the Lens of Testing","text":"<p>Another way to develop an intuition of the LSP is through the lens of testing. When we write a method, we may want to introduce test cases to check that our method is working correctly.  Since these test cases are designed based on the specification of our method and not its implementation details<sup>2</sup>, passing test cases aligns with adherence of the LSP.</p> <p>Let's look at an example. We would like to model a restaurant booking system for a restaurant chain. Consider the following <code>Restaurant</code> class.  Every restaurant in the chain opens at 12 PM and closes at 10 PM, and has a singular method <code>canMakeReservation</code> which allows us to check if the restaurant is available for reservations at a certain <code>time</code>.  The requirement given is that the system must be able to process a reservation during its opening hours.</p> The Restaurant Class<pre><code>public class Restaurant {\n  public static final int OPENING_HOUR = 1200;\n  public static final int CLOSING_HOUR = 2200;\n\n  public boolean canMakeReservation(int time) {\n    if (time &lt;= CLOSING_HOUR &amp;&amp; time &gt;= OPENING_HOUR) {\n      return true;\n    }\n    return false;\n  }\n}\n</code></pre> <p>The method <code>canMakeReservation</code> returns <code>true</code> when the argument passed into <code>time</code> is between 12 PM and 10 PM. Let's think about how we would test this method.  Two important edge cases to test are to check if the method returns true for the stated restaurant opening and closing hours.</p> <pre><code>Restaurant r = new Restaurant();\nr.canMakeReservation(1200) == true; // Is true, therefore test passes\n  : // test for other hours between 1200 - 2200\nr.canMakeReservation(2200) == true; // Is true, therefore test passes\n</code></pre> <p>Note that these are simple <code>jshell</code> tests, in software engineering courses you will learn better ways to design and formalize these tests.</p> <p>Let's now consider two subclasses of <code>Restaurant</code>, <code>LunchRestaurant</code> and <code>DigitalReadyRestaurant</code>. Our <code>LunchRestaurant</code> does not take reservations during peak hours (12 to 2 pm).</p> The LunchRestaurant Class<pre><code>public class LunchRestaurant extends Restaurant {\n  private final int peakHourStart = 1200;\n  private final int peakHourEnd = 1400;\n\n  @Override\n  public boolean canMakeReservation(int time) {\n    if (time &lt;= peakHourEnd &amp;&amp; time &gt;= peakHourStart) {\n      return false;\n    } else if (time &lt;= CLOSING_HOUR &amp;&amp; time &gt;= OPENING_HOUR) {\n      return true;\n    }\n    return false;\n  }\n}\n</code></pre> <p><code>LunchRestaurant</code> does not take reservations during peak hours (i.e., 1200 to 1400). As <code>LunchRestaurant</code> \\(&lt;:\\) <code>Restaurant</code>, we can point our variable <code>r</code> to a new instance of <code>LunchRestaurant</code> and run the test cases of the parent class, as can be seen in the code below.</p> <pre><code>Restaurant r = new LunchRestaurant();\nr.canMakeReservation(1200) == true; // Is false, therefore test fails\n  : // test for other hours between 1200 - 2200\nr.canMakeReservation(2200) == true; // Is true, therefore test passes\n</code></pre> <p>Whilst the second test passes, the first test does not since it falls within the peak lunch hour.  Therefore <code>LunchRestaurant</code> is not substitutable for <code>Restaurant</code> and the LSP is violated.  We have changed the expectation of the method in the child class.</p> <p>Let's suppose the restaurant chain starts to roll out an online reservation system for a subset of its restaurants.  These restaurants can take reservations at any time. We create a subclass <code>DigitalReadyRestaurant</code>, as follows:</p> The DigitalReadyRestaurant Class<pre><code>public class DigitalReadyRestaurant extends Restaurant {\n\n  @Override\n  public boolean canMakeReservation(int time) {\n    return true;\n  }\n}\n</code></pre> <p>Similarly, as <code>DigitalReadyRestaurant</code> \\(&lt;:\\) <code>Restaurant</code>, we can point our variable <code>r</code> to a new instance of <code>DigitalReadyRestaurant</code> and run the test cases of the parent class, as can be seen in the code below.</p> <pre><code>Restaurant r = new DigitalReadyRestaurant();\nr.canMakeReservation(1200) == true; // Is true, therefore test passes\n  : // test for other hours between 1200 - 2200\nr.canMakeReservation(2200) == true; // Is true, therefore test passes\n</code></pre> <p>Both test cases pass.  In fact, all test cases that pass for <code>Restaurant</code> would pass for <code>DigitalReadyRestaurant</code>.  Therefore <code>DigitalReadyRestaurant</code> is substitutable for <code>Restaurant</code>. Anywhere we can use an object of type <code>Restaurant</code>, we can use <code>DigitalReadyRestaurant</code> without breaking any previously written code.</p> <p>We can now rephrase our LSP in terms of testing. A subclass should not break the expectations set by the superclass. If a class <code>B</code> is substitutable for a parent class <code>A</code> then it should be able to pass all test cases of the parent class <code>A</code>. If it does not, then it is not substitutable and the LSP is violated.</p>"},{"location":"16-lsp.html#preventing-inheritance-and-method-overriding","title":"Preventing Inheritance and Method Overriding","text":"<p>Sometimes, it is useful for a developer to explicitly prevent a class from being inherited.  Not allowing inheritance would make it much easier to argue for the correctness of programs, something that is important when it comes to writing secure programs.  The two Java classes you have seen, <code>java.lang.Math</code> and <code>java.lang.String</code>, cannot be inherited from.  In Java, we use the keyword <code>final</code> when declaring a class to tell Java that we ban this class from being inherited.</p> <p>For example, to prevent <code>Circle</code> from being inherited, <pre><code>final class Circle {\n    :\n}\n</code></pre></p> <p>Alternatively, we can allow inheritance but still prevent a specific method from being overridden, by declaring a method as <code>final</code>.  Usually, we do this on methods that are critical for the correctness of the class.</p> <p>For instance, to prevent <code>contains</code> from being overridden, <pre><code>class Circle {\n    :\n  public final boolean contains(Point p) {\n      :\n  }\n}\n</code></pre></p>"},{"location":"16-lsp.html#recapping-the-final-keyword","title":"Recapping the <code>final</code> Keyword","text":"<p>We have now seen that the <code>final</code> keyword can be used in three places:</p> <ol> <li>In a class declaration to prevent inheritance.</li> <li>In a method declaration to prevent overriding.</li> <li>In a field declaration to prevent re-assignment.</li> </ol> <p>In fact, we can use <code>final</code> when declaring a local variable or parameter as well, to prevent re-assignment within the method body.</p> <ol> <li> <p>We can use <code>assert</code> to check some of the properties though.\u00a0\u21a9</p> </li> <li> <p>The test cases we are describing here are known as black-box tests and you will encounter these in later courses at NUS. We will not go into any further details in this course.\u00a0\u21a9</p> </li> </ol>"},{"location":"17-abstract.html","title":"Unit 17: Abstract Class","text":"<p>Learning Objectives</p> <p>After this unit, students should be able to:</p> <ul> <li>explain why abstract classes are needed to model incomplete abstractions</li> <li>declare and use abstract classes and abstract methods correctly in Java</li> <li>reason about compile-time constraints enforced by abstract methods and classes</li> <li>design class hierarchies that use abstract classes to support polymorphism safely</li> <li>distinguish clearly between abstract and concrete classes and their roles</li> </ul> <p>Overview</p> <p>In earlier units, we learned how inheritance and polymorphism allow us to write code that works at a higher level of abstraction.  For example, writing methods that operate on <code>Object</code>, or on a superclass such as <code>Shape</code>, rather than on a specific subclass like <code>Circle</code>. This allowed our programs to be more extensible and reusable.</p> <p>However, as we push abstraction further, we encounter a new problem: some classes are too abstract to be fully implemented.  In this unit, we introduce abstract classes, a language mechanism that allows us to express such incomplete abstractions explicitly. Abstract classes let us define what must be implemented by subclasses, while preventing misuse, such as instantiating objects that are conceptually incomplete. More importantly, abstract classes allow the compiler to enforce design constraints that would otherwise lead to subtle runtime bugs.</p> <p>This unit completes the abstraction story that began with inheritance and polymorphism by showing how Java helps us encode design intent directly into the type system.</p>"},{"location":"17-abstract.html#high-level-abstraction","title":"High-Level Abstraction","text":"<p>Recall that the concept of abstraction involves hiding away unnecessary complexity and details so that programmers do not have to be bogged down with the nitty-gritty.</p> <p>When we code, we should, as much as possible, try to work with the higher-level abstraction, rather than the detailed version.  Following this principle would allow us to write code that is general and extensible, by taking full advantage of inheritance and polymorphism.</p> <p>Take the following example which you have seen, contains v0.1 with Polymorphism<pre><code>boolean contains(Object[] array, Object obj) {\n  for (Object curr : array) {\n    if (curr.equals(obj)) {\n      return true;\n    }\n  }\n  return false;\n}\n</code></pre></p> <p>The function above is very general.  We do not assume and do not need to know about the details of the items being stored or searched.  All we required is that the <code>equals</code> method compared if two objects are equal.</p> <p>In contrast, someone whose mind focuses on finding a circle might write something like this: contains v0.3 for Circle only<pre><code>boolean contains(Circle[] array, Circle circle) {\n  for (Circle curr : array) {\n    if (curr.equals(circle)) {\n      return true;\n    }\n  }\n  return false;\n}\n</code></pre></p> <p>The version above serves the purpose, but is not general enough.  The only method used is <code>equals</code>, which <code>Circle</code> inherits/overrides from <code>Object</code> so using <code>Circle</code> for this function is too constraining.  We can reuse this for any other subclasses of Circle, but not other classes.</p>"},{"location":"17-abstract.html#abstracting-circles","title":"Abstracting Circles","text":"<p>Consider the following function, which finds the largest area among the circles in a given array:</p> findLargest v0.1 with Circle<pre><code>double findLargest(Circle[] array) {\n  double maxArea = 0;\n  for (Circle curr : array) {\n    double area = curr.getArea();\n    if (area &gt; maxArea) {\n      maxArea = area;\n    }\n  }\n  return maxArea;\n}\n</code></pre> <p><code>findLargest</code> suffers from the same specificity as version 0.3 of <code>contains</code>.  It only works for <code>Circle</code> and its subclasses.  Can we make this more general?  We cannot replace <code>Circle</code> with <code>Object</code>,</p> findLargest v0.2 with Object<pre><code>double findLargest(Object[] array) {\n  double maxArea = 0;\n  for (Object curr : array) {\n    double area = curr.getArea();\n    if (area &gt; maxArea) {\n      maxArea = area;\n    }\n  }\n  return maxArea;\n}\n</code></pre> <p>since <code>getArea</code> is not defined for a generic object (e.g., what does <code>getArea</code> of a string mean?).</p> <p>To allow us to apply <code>findLargest</code> to a more generic object, we have to create a new type \u2014 something more specific than <code>Object</code> that supports <code>getArea()</code>, yet more general than <code>Circle</code>.</p>"},{"location":"17-abstract.html#shape","title":"Shape","text":"<p>Let's create a new class called <code>Shape</code>, and redefine our <code>Circle</code> class as a subclass of <code>Shape</code>. We can now create other shapes, <code>Square</code>, <code>Rectangle</code>, <code>Triangle</code>, etc, and define the <code>getArea</code> method for each of them.</p> <p>With the new <code>Shape</code> class, we can rewrite <code>findLargest</code> as:</p> findLargest v0.3 with Shape<pre><code>double findLargest(Shape[] array) {\n  double maxArea = 0;\n  for (Shape curr : array) {\n    double area = curr.getArea();\n    if (area &gt; maxArea) {\n      maxArea = area;\n    }\n  }\n  return maxShape;\n}\n</code></pre> <p>This version not only works for an array of <code>Square</code>, <code>Rectangle</code>, <code>Circle</code>, etc but also an array containing multiple shapes!</p> <p>Let's actually write out our new <code>Shape</code> class:</p> <pre><code>class Shape {\n  public double getArea() {\n    // what is an area of an unknown shape?\n  }\n}\n</code></pre> <p>and rewrite our <code>Circle</code>:</p> Circle v0.8 extending from Shape<pre><code>/**\n * A Circle object encapsulates a circle on a 2D plane.\n */\nclass Circle extends Shape {\n  private Point c;   // the center\n  private double r;  // the length of the radius\n\n  /**\n   * Create a circle centered on Point c with given radius r\n   */\n  public Circle(Point c, double r) {\n    this.c = c;\n    this.r = r;\n  }\n\n  /**\n   * Return the area of the circle.\n   */\n  @Override\n  public double getArea() {\n    return Math.PI * this.r * this.r;\n  }\n\n  /**\n   * Return true if the given point p is within the circle.\n   */\n  public boolean contains(Point p) {\n    // TODO: Left as an exercise\n    return false;\n  }\n\n  /**\n   * Return the string representation of this circle.\n   */\n  @Override\n  public String toString() {\n    return \"{ center: \" + this.c + \", radius: \" + this.r + \" }\";\n  }\n\n  /**\n   * Return true if the object is the same circle (i.e., same center, same radius).\n   */\n  @Override\n  public boolean equals(Object obj) {\n    if (obj instanceof Circle) {\n      Circle circle = (Circle) obj;\n      return (circle.c.equals(this.c) &amp;&amp; circle.r == this.r);\n    }\n  }\n}\n</code></pre> <p>Notably, since our <code>Shape</code> is a highly abstract entity, it does not have any fields.  A key question is: how are we going to write <code>Shape::getArea()</code>?   We cannot compute the area of a shape unless we know what sort of shape it is.</p> <p>One solution is to make <code>Shape::getArea()</code> return 0.</p> <pre><code>class Shape {\n  public double getArea() {\n    return 0;\n  }\n}\n</code></pre> <p>This design is unsafe and error-prone.  It is easy for someone to inherit from <code>Shape</code>, but forget to override <code>getArea()</code>.  If this happens, then the subclass will have an area of 0.  This leads to silent logical errors that the compiler cannot detect.</p> <p>As we usually do in CS2030S, we want to exploit programming language constructs and rely on the compiler to check and catch such errors for us.  Abstract methods shift error detection from runtime to compile time. If a subclass fails to implement an abstract method, the program will not compile\u2014preventing incomplete implementations from slipping into execution.</p>"},{"location":"17-abstract.html#abstract-methods-and-classes","title":"Abstract Methods and Classes","text":"<p>This brings us to the concept of abstract classes.  An abstract class in Java is a class that has been made into something so general that it cannot and should not be instantiated.  Usually, this means that one or more of its instance methods cannot be implemented without further details.</p> <p>The <code>Shape</code> class above makes a good abstract class since we do not have enough details to implement <code>Shape::getArea</code>.</p> <p>To declare an abstract class in Java, we add the <code>abstract</code> keyword to the <code>class</code> declaration.  To make an instance method abstract, we add the keyword <code>abstract</code> when we declare the instance method.</p> <p>An <code>abstract</code> instance method cannot be implemented and therefore should not have any method body.</p> <p>This is how we implement <code>Shape</code> as an abstract class.</p> Shape v0.1<pre><code>abstract class Shape {\n  abstract public double getArea();\n}\n</code></pre> <p>An abstract class cannot be instantiated.  Any attempt to do so, such as: <pre><code>Shape s = new Shape();\n</code></pre></p> <p>would result in an error.</p> <pre><code>_.java:_: error: Shape is abstract; cannot be instantiated\n    Shape s = new Shape();\n              ^\n</code></pre> <p>Note that our simple example of <code>Shape</code> only encapsulates one abstract instance method.  An abstract class can contain multiple fields and multiple methods (including class methods).  Not all the methods have to be abstract.  As long as one of them is abstract, the class becomes abstract.</p> <p>To illustrate this, consider the following implemetation of the abstract class <code>Shape</code>.</p> Shape v0.2 with Non-abstract Method<pre><code>abstract class Shape {\n  private int numOfAxesOfSymmetry ;\n\n  public boolean isSymmetric() {\n    return numOfAxesOfSymmetry &gt; 0;\n  }\n\n  abstract public double getArea();\n}\n</code></pre> <p><code>Shape::isSymmetric()</code> is a concrete instance method but the class is still abstract since <code>Shape::getArea()</code> is abstract.</p> <p>Note that the rule for declaring an abstract class is not symmetric.  A class with at least one abstract instance method must be declared abstract.  On the other hand, an abstract class may have no abstract method.</p>"},{"location":"17-abstract.html#concrete-classes","title":"Concrete Classes","text":"<p>We call a class that is not abstract as a concrete class.  A concrete, non-abstract, class cannot have any abstract method.  Thus, any concrete subclass of <code>Shape</code> must override <code>getArea()</code> to supply its own implementation.</p>"},{"location":"18-interface.html","title":"Unit 18: Interface","text":"<p>Learning Objectives</p> <p>After completing this unit, students should be able to:</p> <ul> <li>Explain how interfaces model capabilities (\u201ccan-do\u201d behavior) independently of class hierarchies.</li> <li>Use interfaces to generalize code beyond inheritance and avoid inappropriate IS-A relationships.</li> <li>Reason about subtype\u2013supertype relationships involving interfaces, including multiple supertypes.</li> <li>Predict and explain compile-time and runtime behavior when casting objects to interface types.</li> <li>Recognize the design trade-offs involved in evolving interfaces, including the motivation for default methods.</li> </ul> <p>Overview</p> <p>In the previous units, we used inheritance, especially abstract classes, to write code that is more general and reusable. By programming against a superclass rather than a concrete class, we learned how to decouple what a method needs from how that behavior is implemented.</p> <p>However, inheritance has an important limitation: it models an IS-A relationship. Not every form of generalization fits naturally into a single class hierarchy.</p> <p>In this unit, we take abstraction one step further. Instead of modeling what something is, we focus on what it can do. This shift allows us to write highly flexible code that works across unrelated class hierarchies\u2014without forcing unnatural inheritance relationships.</p> <p>To achieve this, we introduce interfaces: a Java abstraction that models behavior rather than identity. Interfaces will allow us to express common capabilities, reason about multiple supertypes, and write code that is both more general and more precise.</p>"},{"location":"18-interface.html#modeling-behavior","title":"Modeling Behavior","text":"<p>Let's reexamine this method again: findLargest v0.3 with Shape<pre><code>double findLargest(Shape[] array) {\n  double maxArea = 0;\n  for (Shape curr : array) {\n    double area = curr.getArea();\n    if (area &gt; maxArea) {\n      maxArea = area;\n    }\n  }\n  return maxArea;\n}\n</code></pre></p> <p>The only requirement for this method to compile and run correctly is that the element type provides a <code>getArea()</code> method.  While <code>Shape</code> that we defined in the previous unit meets this requirement, it does not have to be.  We could pass in an array of countries or an array of HDB flats.  It would be inapprpriate to model a <code>Country</code> or a <code>Flat</code> as a subclass of <code>Shape</code>, since inheritance models the IS-A relationship.</p> <p>To resolve this, we will look at an abstraction that models what an entity can do, possibly across different class hierarchies.</p>"},{"location":"18-interface.html#interface","title":"Interface","text":"<p>The abstraction to do this is called an interface.  An interface is also a type and is declared with the keyword <code>interface</code>.</p> <p>Since an interface models what an entity can do, the name usually ends with the -able suffix<sup>1</sup>.</p> <p>Now, suppose we want to create a type that supports the<code>getArea()</code> method, be it a shape, a geographical region, or a real estate property.  Let's call it <code>GetAreable</code>: Interface GetAreable v0.1 with explicit modifiers<pre><code>interface GetAreable {\n  public abstract double getArea();\n}\n</code></pre></p> <p>All methods declared in an interface are <code>public abstract</code> by default.  We could also just write the following:</p> Interface GetAreable v0.2 with implicit modifiers<pre><code>interface GetAreable {\n  double getArea();\n}\n</code></pre> <p>Now, for every class that we wish to be able to call <code>getArea()</code> on, we tell Java that the class <code>implements</code> that particular interface.</p> <p>For instance, we can implement the class <code>Shape</code> as follows.</p> Shape v0.3 Implements the Interface GetAreable<pre><code>abstract class Shape implements GetAreable {\n  private int numOfAxesOfSymmetry;\n\n  public boolean isSymmetric() {\n    return numOfAxesOfSymmetry &gt; 0;\n  }\n}\n</code></pre> <p>The <code>Shape</code> class will now have a <code>public abstract double getArea()</code> thanks to the implementation of the <code>GetAreable</code> interface.</p> <p>We can have a concrete class implementing an interface too.</p> Flat Implements the Interface GetAreable<pre><code>class Flat extends RealEstate implements GetAreable {\n  private int numOfRooms;\n  private String block;\n  private String street;\n  private int floor;\n  private int unit;\n\n  @Override\n  public double getArea() {\n      :\n  }\n}\n</code></pre> <p>For a class to implement an interface and be concrete, it has to override all abstract methods from the interface and provide an implementation to each, just like the example above.  Otherwise, the class becomes abstract.</p> <p>With the <code>GetAreable</code> interface, we can now make our function <code>findLargest</code> even more general. findLargest v0.4 with GetAreable<pre><code>double findLargest(GetAreable[] array) {\n  double maxArea = 0;\n  for (GetAreable curr : array) {\n    double area = curr.getArea();\n    if (area &gt; maxArea) {\n      maxArea = area;\n    }\n  }\n  return maxArea;\n}\n</code></pre></p> <p>Note:</p> <ul> <li>A class can only extend from one superclass, but it can implement multiple interfaces.</li> <li>An interface can extend from one or more other interfaces, but an interface cannot extend from another class.</li> </ul> <p>As a rule of thumb, use an interface when you want to model a capability or behavior that can be shared across different class hierarchies. Use an abstract class when you want to model shared states or base functionality within a class hierarchy.</p>"},{"location":"18-interface.html#interface-as-supertype","title":"Interface as Supertype","text":"<p>If a class \\(C\\) implements an interface \\(I\\), \\(C &lt;: I\\).   This definition implies that a type can have multiple supertypes.</p> <p>In the example above, <code>Flat</code> &lt;: <code>GetAreable</code> and <code>Flat</code> &lt;: <code>RealEstate</code>.</p>"},{"location":"18-interface.html#casting-using-an-interface","title":"Casting using an Interface","text":"<p>Like any type in Java, it is also possible to cast a variable to an interface type. Let's consider an interface <code>I</code> and two classes <code>A</code> and <code>B</code>. Note that <code>A</code> does not implement <code>I</code></p> <pre><code>interface I {\n  :\n}\n\nclass A {\n  :\n}\n\nclass B implements I {\n  :\n}\n</code></pre> <p>Consider the following three variables:</p> <pre><code>I i;\nA a;\nB b;\n</code></pre> <p>First, let's recap whether the compiler allows the following when we convert between classes with and without a subtype relationship: <pre><code>i = b; // Compiles.  Widening conversion: B &lt;: I\nb = i; // Does not compile.  Narrowing conversion: I &lt;: B\ni = a; // Does not compile.  There is no A &lt;: I relationship\n</code></pre></p> <p>Now, let's consider narrowing conversion from <code>B</code> to <code>A</code> through an explicit cast: <pre><code>(A) b; \n</code></pre></p> <p>The above does not compile, since there is no <code>B</code> \\(&lt;:\\) <code>A</code> relationship.  However, the following conversion from <code>B</code> to <code>I</code> works: <pre><code>(I) b;  \n</code></pre></p> <p>since <code>B</code> \\(&lt;:\\) <code>I</code>.  </p> <p>Finally, consider the conversion from <code>A</code> to <code>I</code>: <pre><code>(I) a; \n</code></pre></p> <p>Even though <code>A</code> \\(\\not &lt;:\\) <code>I</code>, the Java compiler allows this code to compile! Why is that so? </p> <p>The Java compiler does not let us cast when it is provable that it will not work, i.e. casting between two classes that have no subtype relationship. However, for interfaces, there is the possibility that a subclass could implement the interface.  Therefore, the Java compiler trusts that the programmer knows what they are doing, and allows it to compile. Consider one such potential subclass <code>AI</code>:</p> <pre><code>class AI extends A implements I{\n  :\n}\n</code></pre> <p>The key takeaway is that an explicit cast tells the compiler to trust the programmer, and therefore it may not warn us or stop us from making bad decision. It is important to always be sure whenever you use an explicit typecast, otherwise the code may compile but throw a <code>ClassCastException</code> at runtime.  </p> <p>Here is an example that demonstrates this:</p> <pre><code>A a = new A();\ni = (I) a; // Compiles, but failed during execution\n</code></pre>"},{"location":"18-interface.html#impure-interfaces","title":"Impure Interfaces","text":"<p>As we mentioned at the beginning of this course, it is common for software requirements, and their design, to continuously evolve.  Once an interface is exposed beyond an abstraction barrier, changing it becomes difficult.  Unlike classes, interfaces represent a contract that many independent implementations may rely on.</p> <p>Suppose that, after we define that <code>GetAreable</code> interface, other developers in the team start to write classes that implement this interface.  One fine day, we realized that we need to add more methods to the <code>GetAreable</code> interface.  Perhaps we need methods <code>getAreaInSquareFeet()</code> and <code>getAreaInSquareMeter()</code> in the interface.  </p> <p>If we simply add these methods as abstract methods to the interface, all existing implementing classes will immediately fail to compile unless they are updated to provide implementations. This makes interfaces particularly hard to evolve once they are in use.</p> <p>This exact problem arose when Java transitioned from version 7 to version 8. The Java standard library needed to extend existing interfaces with new methods, but doing so would have broken a large amount of existing code.</p> <p>To address this, Java allows interfaces to include default methods\u2014methods that provide a concrete implementation. Implementing classes automatically inherit these methods unless they choose to override them.</p> Interface GetAreable v0.3 with Default Method<pre><code>interface GetAreable {\n  double getArea();\n\n  default double getAreaInSquareFeet() {\n    return getArea() * 10.7639;\n  }\n}\n</code></pre> <p>While default methods improve backward compatibility, they blur the clean conceptual distinction between interfaces and classes. An interface may now contain both abstract method declarations and concrete method implementations.</p> <p>In CS2030S, we refer to such interfaces as impure interfaces. In this course, we treat interfaces conceptually as pure specifications of behavior.  You are not expected to define default methods, and we will reason about interfaces as if they contain only abstract methods.</p> <p>The key takeaway is not the syntax of default methods, but the design lesson: interfaces are difficult to change once published, so they must be designed carefully and conservatively.  This restriction is one reason why we often prefer abstract classes when evolution and shared implementation are important, and interfaces when expressing minimal, stable capabilities.</p> <ol> <li> <p>Although in recent Java releases, this is less common.\u00a0\u21a9</p> </li> </ol>"},{"location":"19-wrapper.html","title":"Unit 19: Wrapper Class","text":"<p>Learning Objectives</p> <p>After this unit, students should be able to:</p> <ul> <li>explain why primitive types cannot be used with polymorphic code written over Object</li> <li>identify the wrapper class corresponding to each Java primitive type</li> <li>use wrapper classes to adapt primitive values for APIs that expect reference types</li> <li>explain and predict when Java performs auto-boxing and auto-unboxing</li> <li>reason about the performance implications of using wrapper classes versus primitive types</li> </ul> <p>Overview</p> <p>In earlier units, we learned how polymorphism allows us to write general code that operates over many different reference types using a common supertype such as Object. This flexibility, however, comes with a limitation: Java\u2019s primitive types do not participate in inheritance and therefore cannot be treated as Objects.</p> <p>In this unit, we examine how Java bridges this gap using wrapper classes. Wrapper classes allow primitive values to be represented as objects, making it possible to reuse polymorphic code and standard library APIs. We will also see how Java hides some of this complexity through auto-boxing and unboxing, and why this convenience comes with performance costs.</p> <p>Understanding wrapper classes is essential for working with generic code, collections, and Java\u2019s standard libraries, where the distinction between primitive types and reference types becomes unavoidable.</p>"},{"location":"19-wrapper.html#writing-general-code-for-primitive-types","title":"Writing General Code for Primitive Types","text":"<p>We have seen the following general code that takes in an array of <code>Object</code> objects and searches if another object <code>obj</code> is in the given <code>array</code>.</p> contains v0.1 with Polymorphism<pre><code>boolean contains(Object[] array, Object obj) {\n  for (Object curr : array) {\n    if (curr.equals(obj)) {\n      return true;\n    }\n  }\n  return false;\n}\n</code></pre> <p>Through polymorphism and overriding of the <code>equals</code> method, we can make sure that it is general enough to work on any reference type.  But what about primitive types?  Do we need to write a separate function for each primitive type, like this?</p> contains v0.4 for int<pre><code>boolean contains(int[] array, int obj) {\n  for (int curr : array) {\n    if (curr == obj) {\n      return true;\n    }\n  }\n  return false;\n}\n</code></pre>"},{"location":"19-wrapper.html#making-primitive-types-less-primitive","title":"Making Primitive Types Less Primitive","text":"<p>Java provides wrapper classes for each of its primitive types.  A wrapper class is a class that encapsulates a primitive value as an object.  The wrapper class for <code>int</code> is called <code>Integer</code>, for <code>double</code> is called <code>Double</code>, etc. There is a wrapper class for all of the Java primitives.</p> Primitive Wrapper <code>byte</code> <code>Byte</code> <code>short</code> <code>Short</code> <code>int</code> <code>Integer</code> <code>long</code> <code>Long</code> <code>float</code> <code>Float</code> <code>double</code> <code>Double</code> <code>char</code> <code>Character</code> <code>boolean</code> <code>Boolean</code> <p>A wrapper class can be used just like every other class in Java and behave just like every other class in Java.  In particular, they are reference types, their instances can be created with <code>new</code> and stored on the heap, etc.  </p> <p>For instance, <pre><code>Integer i = Integer.valueOf(4);\nint j = i.intValue();\n</code></pre></p> <p>The code snippet above shows how we can convert a primitive <code>int</code> value to a wrapper instance <code>i</code> of type <code>Integer</code>, and how the <code>intValue</code> method can retrieve the <code>int</code> value from an <code>Integer</code> instance.  </p> <p>By using wrapper types, we can reuse our <code>contains</code> method that takes in an <code>Object</code> array as a parameter to operate on an array of integers \u2014 we just need to pass our integers into the method in an <code>Integer</code> array instead of an <code>int</code> array.</p> <p>All primitive wrapper class objects are immutable \u2014 once you create an object, it cannot be changed.</p>"},{"location":"19-wrapper.html#auto-boxing-and-unboxing","title":"Auto-boxing and Unboxing","text":"<p>As conversion back-and-forth between a primitive type and its wrapper class is pretty common, Java provides a feature called auto-boxing/unboxing to perform type conversion between a primitive type and its wrapper class.</p> <p>For instance, <pre><code>Integer i = 4;\nint j = i;\n</code></pre></p> <p>The first statement is an example of auto-boxing, where the primitive value <code>int</code> of 4 is converted into an instance of <code>Integer</code>.  The second statement performs auto-unboxing, extracting the <code>int</code> value from the <code>Integer</code> object. </p>"},{"location":"19-wrapper.html#performance","title":"Performance","text":"<p>Since the wrapper classes allow us to write flexible programs, why not use them all the time and forget about primitive types?</p> <p>The answer: performance. Because using an object comes with the cost of allocating memory for the object on the heap and then deallocating the memory eventually, it is less efficient than primitive types.   </p> <p>Consider the following two programs:</p> <pre><code>Double sum = 0.0;\nfor (int i = 0; i &lt; Integer.MAX_VALUE; i++) {\n  sum += i;\n}\n</code></pre> <p>vs.</p> <pre><code>double sum = 0.0;\nfor (int i = 0; i &lt; Integer.MAX_VALUE; i++) {\n  sum += i;\n}\n</code></pre> <p>As all primitive wrapper class objects are immutable, every time the sum in the first example above is updated, a new <code>Double</code> object gets created. </p> <p>Auto-boxing and unboxing happen implicitly, which makes code concise but also makes object creation less visible. As a result, performance issues can arise even when the code appears to use only simple arithmetic.</p> <p>To address such performance issues, the Java API provides multiple versions of the same method, one for all the reference types using <code>Object</code>, and one for each of the primitive types.  This decision does lead to multiple versions of the same code, but this trade-off comes with the benefit of better performance.  See the Arrays class for instance.</p> <p>The separation between primitive types and their wrapper classes is a legacy design choice in Java.  Wrapper classes and auto-boxing were introduced later to improve interoperability without breaking existing code.</p>"},{"location":"19-wrapper.html#equality","title":"Equality","text":"<p>When comparing two primitive values, we use the <code>==</code> operator.  When comparing two reference types, we usually use the <code>equals</code> method.  What about comparing two wrapper class objects?</p> <p>When comparing two wrapper class objects, we should always use the <code>equals</code> method to compare their values.  Using the <code>==</code> operator will compare their references instead of their values, which is usually not what we want.</p> <pre><code>Integer a = 500;\nInteger b = 500;\na == b   // false\na.equals(b) // true\n</code></pre> <p>This difference does not arise with primitive types and is a common source of bugs.</p>"},{"location":"20-casting.html","title":"Unit 20: Runtime Class Mismatch","text":"<p>Learning Objectives</p> <p>After completing this unit, students should be able to:</p> <ul> <li>explain why narrowing type conversion requires explicit casting in Java</li> <li>distinguish between compile-time type checking and runtime type checking in the presence of casts</li> <li>identify situations where a cast is syntactically valid but can fail at runtime</li> <li>reason about how abstraction (interfaces and supertypes) can lead to runtime class mismatch errors</li> </ul> <p>Overview</p> <p>In earlier units, we learned how to write reusable and flexible code by programming to higher-level abstractions, such as interfaces and supertypes. This approach allows our code to work uniformly over many different concrete classes, improving extensibility and reuse.</p> <p>However, abstraction also comes with a cost. When we deliberately \u201cforget\u201d the concrete class of an object and treat it as a more general type, we sometimes need to recover that concrete type later. In Java, doing so requires type casting, and incorrect casts can lead to errors that only appear at runtime.</p> <p>In this unit, we examine how such runtime class mismatch errors arise, why the compiler cannot always prevent them, and what responsibilities fall on the programmer when casting is used.</p>"},{"location":"20-casting.html#finding-the-object-with-the-largest-area","title":"Finding the Object with the Largest Area","text":"<p>Let's revisit our example of <code>findLargest</code> method, which takes in an array of objects that support the <code>getArea</code> method and returns the largest area among these objects.</p> findLargest v0.4 with GetAreable<pre><code>double findLargest(GetAreable[] array) {\n  double maxArea = 0;\n  for (GetAreable curr : array) {\n    double area = curr.getArea();\n    if (area &gt; maxArea) {\n      maxArea = area;\n    }\n  }\n  return maxArea;\n}\n</code></pre> <p>The method served our purpose well, but it is NOT a very well-designed method.  Just returning the value of the largest area is not as useful as returning the object with the largest area.  Once the caller has a reference of the object, the caller can call <code>getArea</code> to find the value of the largest area.</p> <p>Let's write our <code>findLargest</code> method to find which object has the largest area instead.  </p> findLargest v0.5 with GetAreable (Finding the Largest Object)<pre><code>GetAreable findLargest(GetAreable[] array) {\n  double maxArea = 0;\n  GetAreable maxObj = null;\n  for (GetAreable curr : array) {\n    double area = curr.getArea();\n    if (area &gt; maxArea) {\n      maxArea = area;\n      maxObj = curr;\n    }\n  }\n  return maxObj;\n}\n</code></pre> <p>Let's see how <code>findLargest</code> can be used:</p> <pre><code>GetAreable[] circles = new GetAreable[] {\n  new Circle(new Point(1, 1), 2),\n  new Circle(new Point(0, 0), 5)\n};\n\nGetAreable ga = findLargest(circles);  // ok\nCircle c1 = findLargest(circles); // error\nCircle c2 = (Circle) findLargest(circles); // ok\n</code></pre> <p>The return type of <code>findLargest</code> (version 0.5) is now <code>GetAreable</code>.  On Line 6 above, we assign the return object with a compile-time type of <code>GetAreable</code> to <code>ga</code>, which also has <code>GetAreable</code> as its compile-time type.  Since the variable <code>ga</code> is of type <code>GetAreable</code>, however, it is not very useful.  Recall that <code>GetAreable</code> is an interface with only one method <code>getArea</code>.  We cannot use it as a circle.</p> <p>On Line 7, we try to return the return object to a variable with compile-time type <code>Circle</code>.  This line, however, causes a compile-time error.  Since <code>Circle</code> &lt;: <code>GetAreable</code>, this is a narrowing type conversion and thus is not allowed (See Unit 14).  We will have to make an explicit cast of the result to <code>Circle</code> (on Line 8).  Only with casting, our code can compile and we get a reference with a compile-time type of <code>Circle</code>.</p>"},{"location":"20-casting.html#cast-carefully","title":"Cast Carefully","text":"<p>Recall that, type casting, as we did in Line 8 above, is basically a way for programmers to ask the compiler to trust that the object returned by <code>findLargest</code> has a runtime type of <code>Circle</code> (or one of its subtype). A cast does not change the object or convert it into another class. It only changes how the compiler allows the reference to be used. </p> <p>In the snippet above, we can be sure (even prove) that the returned object from <code>findLargest</code> must have a runtime type of <code>Circle</code> since the input variable <code>circles</code> contains only <code>Circle</code> objects.</p> <p>The need to cast our returned object, however, leads to fragile code.  Since the correctness of Line 8 depends on the runtime type, the compiler cannot help us.  It is then up to the programmers to not make mistakes.</p> <p>Consider the following two snippets, which will compile perfectly, but will lead to an error at runtime, when Java detects that the actual object is not an instance of the target class.</p> <pre><code>GetAreable[] circles = new GetAreable[] {\n  new Circle(new Point(1, 1), 2),\n  new Square(new Point(1, 1), 5)\n};\n\nCircle c2 = (Circle) findLargest(circles);\n</code></pre> <p>Or</p> <pre><code>GetAreable[] circles = new GetAreable[] {\n  new Circle(new Point(1, 1), 2),\n  new Circle(new Point(1, 1), 5)\n};\n\nSquare sq = (Square) findLargest(circles);\n</code></pre> <p>We will see how to resolve this problem in later units, where we will show how Java\u2019s type system (in particular, generics) allows us to express stronger guarantees so that many of these casts and the associated runtime risks can be avoided entirely.</p>"},{"location":"21-variance.html","title":"Unit 21: Variance","text":"<p>Learning Objectives</p> <p>After completing this unit, students should be able to:</p> <ul> <li>explain what variance means and distinguish between covariant, contravariant, and invariant type relationships</li> <li>reason about subtype relationships involving complex types (e.g., arrays) based on the subtype relationships of their component types</li> <li>explain why Java arrays are covariant and how this design choice can lead to runtime type errors despite successful compilation</li> <li>predict when Java\u2019s type system can and cannot prevent unsafe operations involving arrays</li> </ul> <p>Overview</p> <p>In earlier units, we learned how Java establishes subtype relationships between classes and interfaces through inheritance and implementation. These relationships allow polymorphism: a variable of a supertype can refer to an object of a subtype.</p> <p>However, once we start working with collections of objects, such as arrays, the situation becomes more subtle. Even if one type is a subtype of another, it is no longer obvious whether an array of the first type should be considered a subtype of an array of the second.</p> <p>This unit introduces the notion of variance, which describes how subtype relationships between component types affect subtype relationships between complex types. We will see that Java makes arrays covariant, a decision that enables flexibility but also introduces a form of unsoundness that only manifests at run time.</p> <p>Understanding this trade-off is essential for appreciating both Java\u2019s type system design and the motivation behind safer alternatives introduced later in the course.</p>"},{"location":"21-variance.html#arrays-of-reference-types","title":"Arrays of Reference Types","text":"<p>Both the methods <code>findLargest</code> and <code>contains</code> take in an array of reference types as parameters:</p> findLargest v0.5 with GetAreable (Finding the Largest Object)<pre><code>GetAreable findLargest(GetAreable[] array) {\n  double maxArea = 0;\n  GetAreable maxObj = null;\n  for (GetAreable curr : array) {\n    double area = curr.getArea();\n    if (area &gt; maxArea) {\n      maxArea = area;\n      maxObj = curr;\n    }\n  }\n  return maxObj;\n}\n</code></pre> contains v0.1 with Polymorphism<pre><code>boolean contains(Object[] array, Object obj) {\n  for (Object curr : array) {\n    if (curr.equals(obj)) {\n      return true;\n    }\n  }\n  return false;\n}\n</code></pre> <p>What kinds of arrays can we pass into these methods?  Let's try this: <pre><code>Object[] objArray = new Object[] { Integer.valueOf(1), Integer.valueOf(2) };\nInteger[] intArray = new Integer[] { Integer.valueOf(1), Integer.valueOf(2) };\n\ncontains(objArray, Integer.valueOf(1)); // ok\ncontains(intArray, Integer.valueOf(1)); // ok\n</code></pre></p> <p>Line 4 is not surprising since the type for <code>objArray</code> matches that of the parameter <code>array</code>.  Line 5, however, shows that it is possible to assign a reference to an object with runtime type <code>Integer[]</code> to a variable with compile-time type <code>Object[]</code>.</p>"},{"location":"21-variance.html#variance-of-types","title":"Variance of Types","text":"<p>So far, we have established the subtype relationship between classes and interfaces based on inheritance and implementation.  The subtype relationship between complex types such as arrays, however, is not so trivial.  Let's look at some definitions.</p> <p>The variance of types refers to how the subtype relationship between complex types relates to the subtype relationship between components.</p> <p>Let \\(C(S)\\) correspond to some complex type based on type \\(S\\).  An array of type \\(S\\) is an example of a complex type.</p> <p>We say a complex type is:</p> <ul> <li>covariant if \\(S &lt;: T\\) implies \\(C(S) &lt;: C(T)\\)</li> <li>contravariant if \\(S &lt;: T\\) implies \\(C(T) &lt;: C(S)\\)</li> <li>invariant if it is neither covariant nor contravariant.</li> </ul>"},{"location":"21-variance.html#java-array-is-covariant","title":"Java Array is Covariant","text":"<p>Arrays of reference types are covariant in Java<sup>1</sup>.  This means that, if \\(S &lt;: T\\), then \\(S[] &lt;: T[]\\).  </p> <p>For example, because <code>Integer</code> &lt;: <code>Object</code>, we have <code>Integer[]</code> &lt;: <code>Object[]</code> and we can do the following:</p> <pre><code>Integer[] intArray;\nObject[] objArray;\nobjArray = intArray; // ok\n</code></pre> <p>By making array covariant, however, Java opens up the possibility of runtime errors, even without typecasting!</p> <p>Consider the following code: <pre><code>Integer[] intArray = new Integer[2] {\n  Integer.valueOf(10), Integer.valueOf(20)\n};\nObject[] objArray;\nobjArray = intArray;\nobjArray[0] = \"Hello!\"; // &lt;- compiles!\n</code></pre></p> <p>On Line 5 above, we set <code>objArray</code> (with a compile-time type of <code>Object[]</code>) to refer to an object with a runtime type of <code>Integer[]</code>.  This is allowed since the array is covariant.</p> <p>On Line 6, we try to put a <code>String</code> object into the <code>Object</code> array.  Since <code>String</code> &lt;: <code>Object</code>, the compiler allows this.  The compiler does not realize that at runtime, the <code>Object</code> array will refer to an array of <code>Integer</code>.  </p> <p>So we now have a perfectly compilable code, that will crash on us with an <code>ArrayStoreException</code> when it executes Line 6 \u2014 only then would Java realize that we are trying to stuff a string into an array of integers!</p> <p>This is an example of a type system rule that is unsafe.  In other words, covariance of arrays breaks the guarantee that \u201cwell-typed programs do not go wrong.\u201d Java compensates by inserting runtime checks, shifting some type safety from compile time to run time.</p> <p>Since the array type is an essential part of the Java language, this rule cannot be changed without ruining existing code.  We will see later that Java\u2019s generic types (such as List) avoid this pitfall by not being covariant by default, trading flexibility for stronger compile-time guarantees. <ol> <li> <p>Arrays of primitive types are invariant.\u00a0\u21a9</p> </li> </ol>"},{"location":"22-exception.html","title":"Unit 22: Exceptions","text":"<p>Learning Objectives</p> <p>After completing this unit, students should be able to:</p> <ul> <li>explain why exceptions improve program structure compared to error codes and global state</li> <li>trace and reason about exception control flow across method calls (try, catch, finally)</li> <li>distinguish checked vs unchecked exceptions and justify when each should be used</li> <li>design methods that throw, handle, or propagate exceptions appropriately</li> <li>apply good exception-handling practices without breaking abstraction barriers</li> </ul> <p>Overview</p> <p>In earlier units, you have already encountered runtime exceptions such as <code>NullPointerException</code>, <code>ClassCastException</code>, and <code>ArrayStoreException</code>. These exceptions are thrown automatically by Java when fundamental safety rules are violated, for example, invoking a method on null, performing an invalid cast, or storing an incompatible object into an array.</p> <p>So far, when such an exception occurs, the program typically terminates with a stack trace. As programmers, however, we often want more control: to detect invalid situations earlier, provide clearer error messages, recover gracefully, or enforce constraints specific to our own abstractions.</p> <p>This unit introduces exceptions as a programming construct. You will learn how to use <code>try</code>, <code>catch</code>, and <code>finally</code> to separate normal program logic from error handling, and how to define and throw your own exceptions to enforce the rules of your classes, just as Java does for its built-in abstractions.</p> <p>By the end of this unit, you should learn to use exceptions as a deliberate design tool for writing robust, well-structured programs.</p>"},{"location":"22-exception.html#a-motivating-example-from-a-c-program","title":"A Motivating Example from a C program","text":"<p>One of the nuances of programming is having to write code to deal with exceptions and errors. Consider writing a method that reads a single integer value from a file.  Here are some things that could go wrong:</p> <ul> <li>The file to read from may not exist</li> <li>The file to read from exists, but you may not have permission to read it</li> <li>You can open the file for reading, but it might contain non-numeric text where you expect numerical values</li> <li>The file might contain fewer values than expected</li> <li>The file might become unreadable as you are reading through it (e.g., someone unplugs the USB drive)</li> </ul> <p>In C, we usually have to write code like this:</p> Handling Errors when Opening and Reading a File in C<pre><code>fd = fopen(filename,\"r\");\nif (fd == NULL) {\n  fprintf(stderr, \"Unable to open file. \");\n  if (errno == ENFILE) {\n    fprintf(stderr, \"Too many opened files.  Unable to open another\\n\");\n  } else if (errno == ENOENT) {\n    fprintf(stderr, \"No such file %s\\n\", filename);\n  } else if (errno == EACCES) {\n    fprintf(stderr, \"No read permission to %s\\n\", filename);\n  }\n  return -1;\n}\nscanned = fscanf(fd, \"%d\", &amp;value);\nif (scanned == 0) {\n  fprintf(stderr, \"Unable to scan for an integer\\n\");\n  fclose(fd);\n  return -2;\n}\nif (scanned == EOF) {\n  fprintf(stderr, \"No input found.\\n\");\n  fclose(fd);\n  return -3;\n}\n</code></pre> <p>Out of the lines above, only TWO lines correspond to the actual task of opening and reading in a file, the others are for exception checking/handling.  The actual tasks are interspersed between exception-checking code, which makes reading and understanding the logic of the code difficult.</p> <p>The examples above also have to return different values to the calling method, because the calling method may have to do something to handle the errors. Note that the POSIX API has a global variable <code>errno</code> that signifies the detailed error. First, we have to check for different <code>errno</code> values and react accordingly (we can use <code>perror</code>, but that has its limits). Second, <code>errno</code> is global, and using a global variable is a bad practice.  In fact, the code above might not work because <code>fprintf</code> in Line 3 might have changed <code>errno</code>.</p> <p>Finally, another issue is having to repeatedly clean up after an error \u2014 here we <code>fclose</code> the file if there is an error reading, twice. It is easy to forget to do so if we have to do this in multiple places.  Furthermore, if we need to perform a more complex cleanup, then we would end up with lots of repeated code.</p> <p>Many modern programming languages support exceptions as a programming construct.  In Java, this is done with <code>try</code>, <code>catch</code>, <code>finally</code> keywords, and a hierarchy of <code>Exception</code> classes.  The <code>try</code>/<code>catch</code>/<code>finally</code> keywords group statements that check/handle errors together making code easier to read. The Java equivalent to the above is:</p> Handling Exceptions when Opening and Reading a File in Java<pre><code>try {\n  reader = new FileReader(filename);\n  scanner = new Scanner(reader);\n  value = scanner.nextInt();\n}\ncatch (FileNotFoundException e) {\n  System.err.println(\"Unable to open \" + filename + \" \" + e);\n}\ncatch (InputMismatchException e) {\n  System.err.println(\"Unable to scan for an integer\");\n}\ncatch (NoSuchElementException e) {\n  System.err.println(\"No input found\");\n}\nfinally {\n  if (scanner != null)\n    scanner.close();\n}\n</code></pre> <p>Let's look at the example more carefully.  The general syntax for <code>try</code>-<code>catch</code>- <code>finally</code> is the following:</p> <pre><code>try {\n  // do something\n} catch (an exception parameter) {\n  // handle exception\n} catch (another exception parameter) {\n  // can have more catch blocks\n} finally {\n  // clean up code\n  // regardless of whether an an exception occurs\n}\n</code></pre>"},{"location":"22-exception.html#try-block","title":"<code>try</code> Block","text":"<p>In the example above, we have the <code>try</code> block:</p> <pre><code>try {\n  reader = new FileReader(filename);\n  scanner = new Scanner(reader);\n  value = scanner.nextInt();\n}\n  :\n</code></pre> <p>which opens the file and reads an integer from it.  Thus the main task for the code is put together in one place, making it easier to read and understand (and thus less bug-prone).</p>"},{"location":"22-exception.html#catch-block","title":"<code>catch</code> Block","text":"<p>Next we have a sequence of <code>catch</code> blocks.</p> <pre><code>  :\ncatch (FileNotFoundException e) {\n  System.err.println(\"Unable to open \" + filename + \" \" + e);\n} catch (InputMismatchException e) {\n  System.err.println(\"Unable to scan for an integer\");\n} catch (NoSuchElementException e) {\n  System.err.println(\"No input found\");\n}\n</code></pre> <p>The error handling comes under the <code>catch</code> blocks, each handling a different type of exception.  In Java, exceptions are instances that are a subtype of the <code>Exception</code> class.  Information about an exception is encapsulated in an exception instance and is \"passed\" into the <code>catch</code> block.  In the example above, <code>e</code> is the variable containing an exception instance.</p> <p>The catch blocks are checked in the order they appear in our program from top to bottom. The first catch block that has an exception type compatible with the type of the thrown exception (i.e. a subtype) is selected to handle the exception. This means the actual type of the exception object must be the same as, or a subclass of, the exception type specified in the catch block. Consider if we have <code>ExceptionX</code> &lt;: <code>ExceptionY</code> and we have the following <code>catch</code> block:</p> <pre><code>  :\n} catch(ExceptionY e) {\n  // handle ExceptionY\n} catch(ExceptionX e) {\n  // handle ExceptionX\n}\n  :\n</code></pre> <p>As such, we will never execute the second catch as <code>ExceptionX</code> will already be caught by <code>catch(ExceptionY e) { .. }</code>.  Indeed, the Java compiler will prevent this issue with a compilation error.</p> <p><pre><code>_.java:_: error: exception ExceptionX has already been caught\n        } catch(ExceptionX e) {\n          ^\n</code></pre> Now with the exception, we no longer rely on a special return value from a function nor a global variable to indicate exceptions.</p>"},{"location":"22-exception.html#finally-block","title":"<code>finally</code> Block","text":"<p>Finally, we have the optional <code>finally</code> clause for housekeeping tasks.  Here, we close the <code>scanner</code> if it is opened.</p> <pre><code>  :\nfinally {\n  if (scanner != null)\n    scanner.close();\n}\n</code></pre> <p>In cases where the code to handle the exceptions is the same, you can avoid repetition by combining multiple exceptions into one catch statement: <pre><code>catch (FileNotFoundException | InputMismatchException | NoSuchElementException e) {\n  System.err.println(e);\n}\n</code></pre></p>"},{"location":"22-exception.html#throwing-exceptions","title":"Throwing Exceptions","text":"<p>The <code>try</code>-<code>catch</code>-<code>finally</code> blocks above show you how to handle exceptions.  Let's see how we can throw an exception.  Let's revisit our <code>Circle</code> class.  A circle cannot have a negative radius.  Let's say that we wish our constructor to throw an <code>IllegalArgumentException</code> when a negative radius is passed in.  </p> <p>We need to do two things.  First, we need to declare that the constructor is throwing an exception, with the <code>throws</code> keyword.  Second, we have to create a new <code>IllegalArgumentException</code> object and throw it to the caller with the <code>throw</code> keywords.</p> <pre><code>class Circle {\n  private Point c;\n  private double r;\n\n  public Circle(Point c, double r) throws IllegalArgumentException {\n    if (r &lt; 0) {\n      throw new IllegalArgumentException(\"radius cannot be negative.\");\n    }\n    this.c = c;\n    this.r = r;\n  }\n}\n</code></pre> <p>Note that executing the <code>throw</code> statement causes the method to immediately return.  In the example above, the initialization of the center <code>c</code> and radius <code>r</code> does not happen.</p> <p>The caller then can catch and handle this exception: <pre><code>try {\n    c = new Circle(point, radius);\n} catch (IllegalArgumentException e) {\n    System.err.println(\"Illegal argument:\" + e.getMessage());\n}\n</code></pre></p> <p><code>throw</code> vs <code>throws</code></p> <p>The keyword <code>throws</code> is used in the method declaration.  The keyword <code>throw</code> is used to throw exceptions.</p>"},{"location":"22-exception.html#checked-vs-unchecked-exceptions","title":"Checked vs Unchecked Exceptions","text":"<p>Java distinguishes between two types of exceptions: checked and unchecked.  </p> <p>An unchecked exception is an exception caused by a programmer's errors.  They should not happen if perfect code is written.  <code>IllegalArgumentException</code>, <code>NullPointerException</code>, <code>ClassCastException</code> are examples of unchecked exceptions.  Generally, unchecked exceptions are not explicitly caught or thrown.  They indicate that something is wrong with the program and cause runtime errors.</p> <p>A checked exception is an exception that a programmer has no control over.  Even if the code written is perfect, such an exception might still happen.  The programmer should thus actively anticipate the exception and handle them.  For instance, when we open a file, we should anticipate that in some cases, the file cannot be opened.  <code>FileNotFoundException</code> is an example of a checked exception.  A checked exception must be either handled, or else the program will not compile.</p> <p>In Java, unchecked exceptions are subclasses of the class <code>RuntimeException</code>.</p>"},{"location":"22-exception.html#exceptions-as-method-contracts","title":"Exceptions as Method Contracts","text":"<p>Exceptions are part of a method\u2019s contract with its callers. In addition to specifying parameter types and return values, a method also specifies which exceptional situations may occur, typically through its <code>throws</code> clause.</p> <p>For checked exceptions, this contract is enforced by the compiler: any caller must either handle the exception or explicitly propagate it. As a result, changing the set of checked exceptions that a method throws is a change to its public specification and may require changes to all its callers. This is why overridden methods are only allowed to throw the same or more specific checked exceptions.  Callers relying on the original contract must not be surprised by new exceptional behavior. </p> <p>Unchecked exceptions, on the other hand, usually signal violated preconditions and are therefore not part of the method\u2019s explicit contract, even though they may still occur at runtime.  As such, we do not need to declare them in the <code>throws</code> clause.</p> <p>In Java, checked exceptions are subclasses of the class <code>Exception</code> that are not a subclass of <code>RuntimeException</code>.</p>"},{"location":"22-exception.html#passing-the-buck","title":"Passing the Buck","text":"<p>The caller of the method that generates (i.e., <code>new</code> and <code>throw</code>) an exception need not catch the exception.  The caller can pass the exception to its caller, and so on if the programmer deems that it is not the right place to handle it.  </p> <p>An unchecked exception, if not caught, will propagate automatically down the stack until either, it is caught or if it is not caught at all, resulting in an error message displayed to the user.</p> <p>For instance, the following toy program would result in <code>IllegalArgumentException</code> being thrown out of <code>main</code> and displayed to the user.</p> Throwing Unchecked IllegalArgumentException<pre><code>class Main {\n  static void createCircles() {\n    int radius = 10;\n    for (int i = 0; i &lt;= 11; i++) {\n        new Circle(new Point(1, 1), radius--);\n    }\n  }\n  public static void main(String[] args) {\n    createCircles();\n  }\n}\n</code></pre> <p>A checked exception, on the other hand, must be handled.  Consider the following example:</p> Checked Exception v0.1 (Compilation Error)<pre><code>class Main {\n  static FileReader openFile(String filename) {\n    return new FileReader(filename);\n  }\n  public static void main(String[] args) {\n    openFile();\n  }\n}\n</code></pre> <p>This program won't compile because the checked exception <code>FileNotFoundException</code> is not handled.  As the example we have seen, we could handle it in <code>openFile</code>.  In this case, <code>openFile</code> does not throw any exception. Checked Exception v0.2 (Handled In-Situ)<pre><code>class Main {\n  static FileReader openFile(String filename) {\n    try {\n      return new FileReader(filename);\n    } catch (FileNotFoundException e) {\n      System.err.println(\"Unable to open \" + filename + \" \" + e);\n    }\n  }\n  public static void main(String[] args) {\n    openFile();\n  }\n}\n</code></pre></p> <p>Alternatively, <code>openFile</code> can pass the buck to the caller instead of catching it. Checked Exception v0.3 (Passed to Caller)<pre><code>class Main {\n  static FileReader openFile(String filename) throws FileNotFoundException {\n    return new FileReader(filename);\n  }\n  public static void main(String[] args) {\n    try {\n      openFile();\n    } catch (FileNotFoundException e) {\n      // warn user and pop up dialog box to select another file.\n    }\n  }\n}\n</code></pre></p> <p>Sometimes the caller is a better place to handle the exception.  Where an exception should be handled is a design decision.  We will see some considerations for this later in this unit.</p> <p>What should not happen is the following: Checked Exception v0.4 (Passed to User)<pre><code>class Toy {\n  static FileReader openFile(String filename) throws FileNotFoundException {\n    return new FileReader(filename);\n  }\n  public static void main(String[] args) throws FileNotFoundException {\n    openFile();\n  }\n}\n</code></pre></p> <p>In the code above, every method passes the buck around.  No one takes the responsibility to handle it and the user ends up with the exception.  The ugly internals of the program (such as the call stack) are then revealed to the user.</p> <p>A good program always handles checked exception gracefully and hides the details from the users.  </p> <p>As a guideline, handle an exception at the lowest level that can meaningfully respond to it.  If a method can restore a valid state or clean up resources, it should catch the exception. Otherwise, propagate it upward.</p>"},{"location":"22-exception.html#control-flow-of-exceptions","title":"Control Flow of Exceptions","text":"<p>Here is a more detailed description of the control flow of exceptions. Consider we have a <code>try</code>-<code>catch</code>-<code>finally</code> block that catches two exceptions <code>E1</code> and <code>E2</code>. Inside the try block, we call a method <code>m1()</code>; <code>m1()</code> calls <code>m2()</code>; <code>m2()</code> calls <code>m3()</code>, and <code>m3()</code> calls <code>m4()</code>.</p> <p></p> <pre><code>try {\n    m1();\n} catch (E1 e) {\n    :\n} catch (E2 e) {\n    :\n} finally {\n    :\n}\n</code></pre> <pre><code>void m1() throws E2 {\n    :\n    m2();\n    :\n}\n\nvoid m2() throws E2 {\n    :\n    m3();\n    :\n}\n\nvoid m3() throws E2 {\n    :\n    m4();\n    :\n}\n\nvoid m4() throws E2 {\n    :\n    throw new E2();\n    :\n}\n</code></pre> <p>In a normal (no exception) situation, the control flow looks like this:</p> <p></p> <p>The statements in the try block are executed, followed by the statements in the <code>finally</code> block.</p> <p>Now, let's suppose something went wrong deep inside the nested call, in <code>m4()</code>. One of the statements executes <code>throw new E2();</code>, which causes the execution in <code>m4()</code> to stop. JVM now looks for the block of code that catches <code>E2</code>, going down the call stack, until it can find a place where the exception is handled. In this example, we suppose that none of <code>m1()</code>-<code>m4()</code> handles (i.e., <code>catch</code>) the exception. Thus, JVM then jumps to the code that handles <code>E2</code>. Finally, JVM executes the <code>finally</code> block.</p> <p>Note that the <code>finally</code> block is always executed even when <code>return</code> or <code>throw</code> is called in a catch block.</p> <p></p>"},{"location":"22-exception.html#creating-our-own-exceptions","title":"Creating Our Own Exceptions","text":"<p>If you find that none of the exceptions provided by Java meet your needs, you can create your own exceptions, by simply inheriting from one of the existing ones. But, you should only do so if there is a good reason, for instance, to provide additional useful information to the exception handler.</p> <p>Here is an example:</p> <pre><code>class IllegalCircleException extends IllegalArgumentException {\n  Point center;\n  IllegalCircleException(String message) {\n    super(message);\n  }\n  IllegalCircleException(Point c, String message) {\n    super(message);\n    this.center = c;\n  }\n  @Override\n    public String toString() {\n      return \"The circle centered at \" + this.center + \" cannot be created:\" + getMessage();\n    }\n}\n</code></pre>"},{"location":"22-exception.html#overriding-method-that-throws-exceptions","title":"Overriding Method that Throws Exceptions","text":"<p>When you override a method that throws a checked exception, the overriding method must throw only the same, or a more specific checked exception, than the overridden method. This rule follows the Liskov Substitution Principle. The caller of the overridden method cannot expect any new checked exception beyond what has already been \"promised\" in the method specification.</p>"},{"location":"22-exception.html#good-practices-for-exception-handling","title":"Good Practices for Exception Handling","text":""},{"location":"22-exception.html#catch-exceptions-to-clean-up","title":"Catch Exceptions to Clean Up","text":"<p>While it is convenient to just pass the buck and let the calling method deal with exceptions (\"Hey! Not my problem!\"), it is not always responsible to do so. Consider the example earlier, where <code>m1()</code>, <code>m2()</code>, and <code>m3()</code> do not handle exception <code>E2</code>. Let's say that <code>E2</code> is a checked exception, and it is possible to react to this and let the program continue properly. Also, suppose that <code>m2()</code> allocated some system resources (e.g., temporary files, network connections) at the beginning of the method, and deallocated the resources at the end of the method. By not handling the exception, the code that deallocates these resources does not get called when an exception occurs.  It is better for <code>m2()</code> to catch the exception and handle the resource deallocation in a <code>finally</code> block. If there is a need for the calling methods to be aware of the exception, <code>m2()</code> can always re-throw the exception:</p> <pre><code>public void m2() throws E2 {\n  try {\n    // setup resources\n    m3();\n  }\n  catch (E2 e) {\n    throw e;\n  }\n  finally {\n    // clean up resources\n  }\n}\n</code></pre>"},{"location":"22-exception.html#do-not-catch-them-all","title":"Do NOT catch-them-all!","text":"<p>Sometimes, you just want to focus on the main logic of the program and get it working instead of dealing with the exceptions. Since Java uses checked exceptions, it forces you to handle the exceptions, or else your code will not compile. One way to quickly get around this is to write:</p> <pre><code>try {\n  // your code\n}\ncatch (Exception e) {\n  // do nothing\n}\n</code></pre> <p>to stop the compiler from complaining.  DO NOT DO THIS.  Since <code>Exception</code> is the superclass of all exceptions, every exception that is thrown, checked or unchecked, is now silently ignored!  You will not be able to figure out if something is wrong with your program.  This practice is such a bad practice that there is a name for it \u2014 this is called Pokemon Exception Handling.</p>"},{"location":"22-exception.html#do-not-overreact","title":"Do NOT Overreact","text":"<p>Do not exit a program just because of an exception. This would prevent the calling function from cleaning up their resources. Worse, do not exit a program silently.</p> <pre><code>try {\n  // your code\n}\ncatch (Exception e) {\n  System.exit(0);\n}\n</code></pre>"},{"location":"22-exception.html#do-not-break-the-abstraction-barrier","title":"Do NOT Break the Abstraction Barrier","text":"<p>Sometimes, letting the calling method handle the exception causes the implementation details to be leaked, and make it harder to change the implementation later.</p> <p>For instance, suppose we design a class <code>ClassRoster</code> with a method <code>getStudents()</code>, which reads the list of students from a text file.</p> <pre><code>class ClassRoster {\n   :\n  public Students[] getStudents() throws FileNotFoundException {\n    :\n  }\n}\n</code></pre> <p>Here, the fact that a <code>FileNotFoundException</code> is thrown leaks the information that the information is read from a file.  </p> <p>Suppose that, later, we change the implementation to reading the list from an SQL database.  We may have to change the exception thrown to something else:</p> <pre><code>class ClassRoster {\n   :\n  public Students[] getStudents() throws SQLException {\n    :\n  }\n}\n</code></pre> <p>The caller will have to change their exception handling code accordingly.</p> <p>We should, as much as possible, handle the implementation-specific exceptions within the abstraction barrier.  A method should not expose implementation-specific exceptions across abstraction boundaries.</p>"},{"location":"22-exception.html#do-not-use-exception-as-a-control-flow-mechanism","title":"Do NOT use Exception as a Control Flow Mechanism","text":"<p>This is probably the most commonly seen mistake among new programmers.  Exceptions are meant to handle unexpected errors, not to handle the logic of your program.  Consider the following snippet:</p> <pre><code>if (obj != null) {\n  obj.doSomething();\n} else {\n  doTheOtherThing();\n}\n</code></pre> <p>We use an <code>if</code> condition to handle the logic.  Some programmers wrote this: <pre><code>   try {\n     obj.doSomething();\n   } catch (NullPointerException e) {\n     doTheOtherThing();\n   }\n</code></pre></p> <p>The mechanism of throwing and catching exception is expensive: When an exception is thrown, the JVM must first abort normal execution immediately at the throw site, unwin the call stack, discarding stack frames one by one until a matching catch block is found, construct an exception object, which includes recording a stack trace that captures the sequence of method calls leading to the error, and finall transfer control non-locally to a catch block, bypassing intermediate method logic.</p> <p>Furthermore, not only is exception as control flow expensive, but it also might not be correct, since a <code>NullPointerException</code> might be triggered by something else other than <code>obj</code> being null.</p> <p>Do not use exceptions to handle normal program logic.  If you expect it to happen, it is not exceptional.</p>"},{"location":"22-exception.html#do-not-throw-checked-exception-to-the-users","title":"Do NOT throw checked exception to the users","text":"<p>As mentioned earlier, a good program always handles checked exceptions gracefully and hides the details from the users.  Do not let checked exceptions propagate to the top-level <code>main</code> method, or else the user will see ugly stack traces.</p> <pre><code>  // bad practice\n  public static void main(String[] args) throws FileNotFoundException {\n      :\n  }\n</code></pre>"},{"location":"22-exception.html#the-error-class","title":"The <code>Error</code> class","text":"<p>Java has another class called <code>Error</code> for situations where the program should terminate as generally there is no way to recover from the error. For instance, when the heap is full (<code>OutOfMemoryError</code>) or the stack is full (<code>StackOverflowError</code>).  Typically we don't need to create or handle such errors.  </p> <p><code>Exception</code> and <code>Error</code> shares a common superclass called <code>Throwable</code>.  In fact, only objects that are instances of this class or its subclasses can be thrown by the <code>throw</code> statement or caught by the <code>catch</code> block.</p>"},{"location":"23-generics.html","title":"Unit 23: Generics","text":"<p>Learning Objectives</p> <p>After completing this unit, students should be able to:</p> <ul> <li>define and use generic classes and generic methods with appropriate type parameters</li> <li>distinguish clearly between type parameters, type arguments, and parameterized types</li> <li>explain how generics enforce compile-time type safety and eliminate certain classes of runtime errors</li> <li>apply bounded type parameters to constrain permissible operations on type variables</li> <li>reason about how generics reduce code duplication while preserving static typing guarantees</li> </ul> <p>Overview</p> <p>In earlier units, we saw how polymorphism allows us to write general code that works for many types, often by treating objects uniformly as Object or through interfaces. While flexible, this approach can sacrifice type precision and shift certain errors from compile time to run time.</p> <p>This unit introduces generics, a language mechanism that allows us to write reusable and abstract code without giving up static type safety. By parameterizing classes and methods with types, we let the compiler track and enforce relationships between values, preventing common mistakes such as invalid casts. Generics form a key bridge between abstraction and safety in Java, and understanding them is essential for reasoning about correctness in larger systems.</p>"},{"location":"23-generics.html#the-pair-class","title":"The <code>Pair</code> class","text":"<p>Sometimes it is useful to have a lightweight class to bundle a pair of variables together.  One could, for instance, write a method that returns two values.  The example defines a class <code>IntPair</code> that bundles two <code>int</code> variables together. This is a utility class with no semantics or methods associated with it.  So, we did not attempt to hide the implementation details.</p> <pre><code>class IntPair {\n  private int first;\n  private int second;\n\n  public IntPair(int first, int second) {\n    this.first = first;\n    this.second = second;\n  }\n\n  int getFirst() {\n    return this.first;\n  }\n\n  int getSecond() {\n    return this.second;\n  }\n}\n</code></pre> <p>This class can be used, for instance, in a function that returns two <code>int</code> values.</p> <pre><code>IntPair findMinMax(int[] array) {\n  int min = Integer.MAX_VALUE;  // stores the min\n  int max = Integer.MIN_VALUE;  // stores the max\n  for (int i : array) {\n    if (i &lt; min)  {\n      min = i;\n    }\n    if (i &gt; max) {\n      max = i;\n    }\n  }\n  return new IntPair(min, max);\n}\n</code></pre> <p>We could similarly define a pair class for two doubles (<code>DoublePair</code>), two booleans (<code>BooleanPair</code>), etc.  In other situations, it is useful to define a pair class that bundles two variables of two different types, say, a <code>Customer</code> and a <code>ServiceCounter</code>; a <code>String</code> and an <code>int</code>; etc.  </p> <p>We should not, however, create one class for each possible combination of types.  A better idea is to define a class that stores two <code>Object</code> references:</p> Pair v0.1 with Object<pre><code>class Pair {\n  private Object first;\n  private Object second;\n\n  public Pair(Object first, Object second) {\n    this.first = first;\n    this.second = second;\n  }\n\n  Object getFirst() {\n    return this.first;\n  }\n\n  Object getSecond() {\n    return this.second;\n  }\n}\n</code></pre> <p>At the cost of using a wrapper class in place of primitive types, we get a single class that can be used to store any type of value.  </p> <p>You might recall that we used a similar approach for our <code>contains</code> method to implement a general method that works for any type of object.  Here, we are using this approach for a general class that encapsulates any type of object.</p> <p>Unfortunately, the issues we faced with narrowing type conversion and potential runtime errors apply to the <code>Pair</code> class as well.  Suppose that a function returns a <code>Pair</code> containing a <code>String</code> and an <code>Integer</code>, and we accidentally treat this as an <code>Integer</code> and a <code>String</code> instead, the compiler will not be able to detect the type mismatch and stop the program from crashing during runtime.</p> <pre><code>Pair foo() {\n  return new Pair(\"hello\", 4);\n}\n\nPair p = foo();\nInteger i = (Integer) p.getFirst(); // runtime ClassCastException\n</code></pre> <p>To reduce the risk of human error, what we need is a way to specify the following: suppose the type of <code>first</code> is \\(S\\) and type of <code>second</code> is \\(T\\), then we want the return type of <code>getFirst</code> to be \\(S\\) and of <code>getSecond</code> to be \\(T\\).</p>"},{"location":"23-generics.html#generic-types","title":"Generic Types","text":"<p>In Java and many other programming languages, the mechanism to do this is called generics or templates.  Java allows us to define a generic type that takes other types as type parameters, just like how we can write methods that take in variables as parameters.  </p>"},{"location":"23-generics.html#declaring-a-generic-type","title":"Declaring a Generic Type","text":"<p>Let's see how we can do this for <code>Pair</code>:</p> Pair v0.2 with Generics<pre><code>class Pair&lt;S,T&gt; {\n  private S first;\n  private T second;\n\n  public Pair(S first, T second) {\n    this.first = first;\n    this.second = second;\n  }\n\n  public S getFirst() {\n    return this.first;\n  }\n\n  public T getSecond() {\n    return this.second;\n  }\n}\n</code></pre> <p>We declare a generic type by specifying its type parameters between <code>&lt;</code> and <code>&gt;</code> when we declare the type.  Similar to how the parameters to a method can be used as variables within the method, type parameters can be used as type variables . By convention, we use a single capital letter to name each type variable.  These type variables are scoped within the definition of the generic type.  </p> <p>In the example above, we have a generic class <code>Pair&lt;S,T&gt;</code> (read \"pair of S and T\")  with <code>S</code> and <code>T</code> as type parameters.  This declaration of generic class also declares <code>S</code> and <code>T</code> as type variables. We can then use <code>S</code> and <code>T</code> as the type of the fields <code>first</code> and <code>second</code>.  We ensure that <code>getFirst()</code> returns type <code>S</code> and <code>getSecond()</code> returns type <code>T</code>, so that the compiler will give an error if we mix up the types.</p> <p>Note that the constructor for <code>Pair</code> is still declared as <code>Pair</code> (without the type parameters).</p> <p>Just like a variable must be declared before it is used, a type variable must be declared as a type parameter before it is used.  For instance, the following would result in a compilation error:</p> <pre><code>class A {\n    T x; // compilation error: T not declared\n}\n</code></pre> <p>Here is a summary of the two approaches towards writing generic code: </p> Aspect Using <code>Object</code> Using Generics Type checking Run time Compile time Casts required Yes No Risk of <code>ClassCastException</code> High Eliminated Code readability Lower Higher Compiler assistance Minimal Strong <p>Generics allow us to encode relationships between types directly in method and class definitions, so that the compiler, not the programmer, checks these relationship.</p>"},{"location":"23-generics.html#usinginstantiating-a-generic-type","title":"Using/Instantiating a Generic Type","text":"<p>To use a generic type, we have to pass in type arguments, which itself can be a non-generic type, a generic type, or another type parameter that has been declared.  Once a generic type is instantiated, it is called a parameterized type.</p> <p>To avoid human errors that could lead to <code>ClassCastException</code> in the example above, we can use the generic version of <code>Pair</code> as follows, taking in two non-generic types:</p> <pre><code>Pair&lt;String,Integer&gt; foo() {\n  return new Pair&lt;String,Integer&gt;(\"hello\", 4);\n}\n\nPair&lt;String,Integer&gt; p = foo();\nInteger i = (Integer) p.getFirst(); // compile-time error\n</code></pre> <p>With the parameterized type <code>Pair&lt;String,Integer&gt;</code>, the return type of <code>getFirst</code> is bound to <code>String</code>, and the compiler now has enough type information to check and give us an error since we try to cast a <code>String</code> to an <code>Integer</code>.</p> <p>Note that we use <code>Integer</code> instead of <code>int</code>, since only reference types can be used as type arguments.</p> <p>Just like you can pass a parameter of a method to another method, we can pass the type parameter of a generic type to another:</p> <pre><code>class DictEntry&lt;T&gt; extends Pair&lt;String,T&gt; {\n    :\n}\n</code></pre> <p>We define a generic class called <code>DictEntry&lt;T&gt;</code> with a single type parameter <code>T</code> that extends from <code>Pair&lt;String,T&gt;</code>, where <code>String</code> is the first type argument (in place of <code>S</code>), while the type parameter <code>T</code> from <code>DictEntry&lt;T&gt;</code> is passed as the type argument for <code>T</code> of <code>Pair&lt;String,T&gt;</code>.  Now, if we want a dictionary entry that maps a <code>String</code> to an <code>Integer</code>, we can use the parameterized type <code>DictEntry&lt;Integer&gt;</code>.</p>"},{"location":"23-generics.html#generic-methods","title":"Generic Methods","text":"<p>Methods can be parameterized with a type parameter as well.  Consider the <code>contains</code> method, which we now put within a class for clarity.</p> contains v0.1 (with Polymorphism)<pre><code>class A {\n  public static boolean contains(Object[] array, Object obj) {\n    for (Object curr : array) {\n      if (curr.equals(obj)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n</code></pre> <p>While using this method does not involve narrowing type conversion and type casting, it is a little too general \u2014 it allows us to call <code>contains</code> in a nonsensical way, like this: <pre><code>String[] strArray = new String[] { \"hello\", \"world\" };\nA.contains(strArray, 123);\n</code></pre></p> <p>Searching for an integer within an array of strings is a futile attempt!  Let's constrain the type of the object to search for to be the same as the type of the array.  We can make this type the parameter to this method:</p> contains v0.5 with Generics<pre><code>class A {\n  public static &lt;T&gt; boolean contains(T[] array, T obj) {\n    for (T curr : array) {\n      if (curr.equals(obj)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n</code></pre> <p>The above shows an example of a generic method.  The type variable <code>T</code> is declared within <code>&lt;</code> and <code>&gt;</code> and is added before the return type of the method.  This variable <code>T</code> is then scoped within the whole method.</p> <p>To call a generic method, we need to pass in the type argument placed before the name of the method<sup>1</sup>.  For instance, <pre><code>String[] strArray = new String[] { \"hello\", \"world\" };\nA.&lt;String&gt;contains(strArray, 123); // type mismatch error\n</code></pre></p> <p>The code above won't compile since the compiler expects the second argument to also be a <code>String</code>.</p>"},{"location":"23-generics.html#bounded-type-parameters","title":"Bounded Type Parameters","text":"<p>Let's now try to apply our newly acquired trick to fix the issue with <code>findLargest</code>.  Recall that we have the following <code>findLargest</code> method (which we now put into an ad hoc class just for clarity), which requires us to perform a narrowing type conversion to cast from <code>GetAreable</code> and possibly lead to a runtime error.</p> findLargest v0.5 with GetAreable<pre><code>class A {\n  public static GetAreable findLargest(GetAreable[] array) {\n    double maxArea = 0;\n    GetAreable maxObj = null;\n    for (GetAreable curr : array) {\n      double area = curr.getArea();\n      if (area &gt; maxArea) {\n        maxArea = area;\n        maxObj = curr;\n      }\n    }\n    return maxObj;\n  }\n}\n</code></pre> <p>Let's try to make this method generic, by forcing the return type to be the same as the type of the elements in the input array,</p> findLargest v0.6 with Generics (Won't Compile)<pre><code>class A {\n  public static &lt;T&gt; T findLargest(T[] array) {\n    double maxArea = 0;\n    T maxObj = null;\n    for (T curr : array) {\n      double area = curr.getArea();\n      if (area &gt; maxArea) {\n        maxArea = area;\n        maxObj = curr;\n      }\n    }\n    return maxObj;\n  }\n}\n</code></pre> <p>The code above won't compile, since the compiler cannot be sure that it can find the method <code>getArea()</code> in type <code>T</code>.  In contrast, when we run <code>contains</code>, we have no issue since we are invoking the method <code>equals</code>, which exists in any reference type in Java.</p> <p>Since we intend to use <code>findLargest</code> only in classes that implement the <code>GetAreable</code> interface and support the <code>getArea()</code> method, we can put a constraint on <code>T</code>.  We can say that <code>T</code> must be a subtype of <code>GetAreable</code> when we specify the type parameter:</p> findLargest v0.7 with Generics and Bounded Type Parameter<pre><code>class A {\n  public static &lt;T extends GetAreable&gt; T findLargest(T[] array) {\n    double maxArea = 0;\n    T maxObj = null;\n    for (T curr : array) {\n      double area = curr.getArea();\n      if (area &gt; maxArea) {\n        maxArea = area;\n        maxObj = curr;\n      }\n    }\n    return maxObj;\n  }\n}\n</code></pre> <p>We use the keyword <code>extends</code> here to indicate that <code>T</code> must be a subtype of <code>GetAreable</code>.  It is unfortunate that Java decides to use the term <code>extends</code> for any type of subtyping when declaring a bounded type parameter, even if the supertype (such as <code>GetAreable</code>) is an interface.</p> <p>We can use bounded type parameters for declaring generic classes as well.  For instance, Java has a generic interface <code>Comparable&lt;T&gt;</code>, which dictates the implementation of the following <code>int compareTo(T t)</code> for any concrete class that implements the interface.   Any class that implements the <code>Comparable&lt;T&gt;</code> interface can be compared with an instance of type <code>T</code> to establish an ordering.  Such ordering can be useful for sorting objects, for instance.</p> <p>Suppose we want to compare two <code>Pair</code> instances, by comparing the first element in the pair, we could do the following:</p> Pair v0.3 with Generics and Bounded Type Parameters<pre><code>class Pair&lt;S extends Comparable&lt;S&gt;,T&gt; implements Comparable&lt;Pair&lt;S,T&gt;&gt; {\n  private S first;\n  private T second;\n\n  public Pair(S first, T second) {\n    this.first = first;\n    this.second = second;\n  }\n\n  public S getFirst() {\n    return this.first;\n  }\n\n  public T getSecond() {\n    return this.second;\n  }\n\n  @Override\n  public int compareTo(Pair&lt;S,T&gt; s1) {\n    return this.first.compareTo(s1.first);\n  }\n\n  @Override\n  public String toString() {\n    return this.first + \" \" + this.second;\n  }\n}\n</code></pre> <p>Let's look at what it means:</p> <ul> <li>We declared <code>Pair</code> to be a generic type of two type parameters: the first one <code>S</code> is bounded and must be a subtype of <code>Comparable&lt;S&gt;</code>.  This bound is self-referential, but it is intuitive \u2014 we say that <code>S</code> must be comparable to itself, which is common in many use cases.</li> <li>Since we want to compare two <code>Pair</code> instances, we make <code>Pair</code> implement the <code>Comparable</code> interface too, passing in <code>Pair&lt;S,T&gt;</code> as the type argument to <code>Comparable</code>.</li> </ul> <p>Let's see this in action with <code>Arrays::sort</code> method, which sorts an array based on the ordering defined by <code>compareTo</code>.</p> <pre><code>Object[] array = new Object[] {\n  new Pair&lt;String,Integer&gt;(\"Alice\", 1),\n  new Pair&lt;String,Integer&gt;(\"Carol\", 2),\n  new Pair&lt;String,Integer&gt;(\"Bob\", 3),\n  new Pair&lt;String,Integer&gt;(\"Dave\", 4),\n};\n\njava.util.Arrays.sort(array);\n\nfor (Object o : array) {\n  System.out.println(o);\n}\n</code></pre> <p>You will see the pairs are sorted by the first element.</p>"},{"location":"23-generics.html#summary-of-terms","title":"Summary of Terms","text":"<p>We introduce multiple new terms in this unit.  Here is a summary:</p> Term Definition Example Type Variable A placeholder for a type, declared in the definition of a generic class or method, and can be used throughout the code within scope. <code>S</code> and <code>T</code> Type Parameter Type variable used in the definition of a generic class or method. <code>S</code> and <code>T</code> in <code>Pair&lt;S, T&gt;</code> Generic Type A class or interface that is parameterized by one or more type parameters. <code>Pair&lt;S,T&gt;</code> Type Argument A concrete type or type variable passed to a generic type or method when it is instantiated or invoked. <code>String</code> and <code>Integer</code> in <code>Pair&lt;String, Integer&gt;</code>; <code>T</code> in <code>Pair&lt;String, T&gt;</code> when defining <code>DictEntry&lt;T&gt;</code> Parameterized Type A generic type with specific type arguments. <code>Pair&lt;String,Integer&gt;</code> <ol> <li> <p>Java actually can infer the type using the type inference mechanism and allows us to skip the type argument, but for clarity, we insist on specifying the type explicitly until students get used to the generic types and reasoning about types.\u00a0\u21a9</p> </li> </ol>"},{"location":"24-erasure.html","title":"Unit 24: Type Erasure","text":"<p>Learning Objectives</p> <p>After completing this unit, students should be able to:</p> <ul> <li>Explain how Java implements generics using type erasure and contrast it with code specialization.</li> <li>Reason about what type information is (and is not) available at run time when generics are used.</li> <li>Explain why generic types are not reifiable, and how this affects runtime checks.</li> <li>Identify and explain heap pollution, including how it can lead to ClassCastException.</li> <li>Explain why arrays and generics do not mix, and distinguish between generic array declaration and instantiation.</li> </ul> <p>Overview</p> <p>In earlier units, we introduced generics as a way to write reusable, type-safe code without sacrificing expressiveness. An important question remains: how are generics actually implemented in Java?</p> <p>In this unit, we uncover the answer by studying type erasure, Java\u2019s design choice for implementing generics. While type erasure preserves backward compatibility and enables code sharing, it also means that generic type information is largely unavailable at run time. This design has far-reaching consequences, including surprising interactions with arrays, the possibility of heap pollution, and limitations on what the compiler and runtime can check.</p> <p>Understanding type erasure helps explain many \u201cwhy can\u2019t Java do this?\u201d questions about generics and equips you to reason more precisely about type safety across compile time and run time.</p>"},{"location":"24-erasure.html#implementing-generics","title":"Implementing Generics","text":"<p>There are several ways one could implement generics in a programming language.</p> <p>For instance, in C#, every instantiation of a generic type causes new code to be generated for that instantiated type.  Instantiating <code>Pair&lt;S,T&gt;</code> into <code>Pair&lt;String,Integer&gt;</code> causes a new type to be generated during runtime.  In C++ and in Rust, instantiating <code>Pair&lt;String,Integer&gt;</code> causes new code to be generated during compile-time.  This approach is sometimes called code specialization, in contrast to Java's code sharing approach.</p> <p>In Java, instead of creating a new type for every instantiation, it chooses to erase the type parameters and type arguments during compilation (after type checking, of course).  Thus, there is only one representation of the generic type in the generated code, representing all the instantiated generic types, regardless of the type arguments.  </p> <p>Part of the reason to do this is for compatibility with the older version of Java.  Java introduces generics only from version 5 onwards.  Prior to version 5, one has to use <code>Object</code> to implement classes that are general enough to work on multiple types, similar to what we did with <code>Pair</code> here:</p> Pair v0.1 with Object<pre><code>class Pair {\n  private Object first;\n  private Object second;\n\n  public Pair(Object first, Object second) {\n    this.first = first;\n    this.second = second;\n  }\n\n  public Object getFirst() {\n    return this.first;\n  }\n\n  public Object getSecond() {\n    return this.second;\n  }\n}\n</code></pre> <p>The Java type erasure process transforms: Pair v0.2 with Generics<pre><code>class Pair&lt;S,T&gt; {\n  private S first;\n  private T second;\n\n  public Pair(S first, T second) {\n    this.first = first;\n    this.second = second;\n  }\n\n  public S getFirst() {\n    return this.first;\n  }\n\n  public T getSecond() {\n    return this.second;\n  }\n}\n</code></pre></p> <p>to the version above.  Note that each type parameter <code>S</code> and <code>T</code> are replaced with <code>Object</code>.  If the type parameter is bounded, it is replaced by the bounds instead (e.g., If <code>T extends GetAreable</code>, then <code>T</code> is replaced with <code>GetAreable</code>).</p> <p>Where a generic type is instantiated and used, the code <pre><code>Integer i = new Pair&lt;String,Integer&gt;(\"hello\", 4).getSecond();\n</code></pre></p> <p>is transformed into <pre><code>Integer i = (Integer) new Pair(\"hello\", 4).getSecond();\n</code></pre></p> <p>The generated code is similar to what we would write earlier, but this is generated by the compiler after type checking, only where it has proven that the casting is correct and will not lead to <code>ClassCastException</code> during runtime.  Thus, the type safety is preserved.</p> <p>Type erasure has several important implications.  We will explore some of them below, and a few others during recitation.  </p>"},{"location":"24-erasure.html#overloading-based-on-type-arguments","title":"Overloading Based on Type Arguments","text":"<p>Suppose we have the following class.  The intention is to overload the method <code>foo</code> to accept either a pair of strings or a pair of integers.  This seems reasonable at the source level: <pre><code>class A {\n  void foo(Pair&lt;Sring, String&gt; p) {\n      // body omitted\n  }\n\n  void foo(Pair&lt;Integer, Integer&gt; p) {\n      // body omitted\n  }\n}\n</code></pre></p> <p>After type erasure, both methods have the same signature: <pre><code>class A {\n  void foo(Pair p) {\n      // body omitted\n  }\n\n  void foo(Pair p) {\n      // body omitted\n  }\n}\n</code></pre> and thus, the compiler will complain about duplicate methods.  This shows that method overloading based on different type arguments is not allowed in Java generics.</p>"},{"location":"24-erasure.html#using-type-parameters-in-static-contexts","title":"Using Type Parameters in Static Contexts","text":"<p>Consider the following generic class: Instance Field with Type Parameter<pre><code>class B&lt;T&gt; { \n  private T x;\n\n  public void setX(T x) { \n    this.x = x; \n  }\n\n  public T getX() { \n    return this.x; \n  }\n}\n</code></pre></p> <p>which can be used in the following way: <pre><code>B&lt;Integer&gt; bInteger = new B&lt;Integer&gt;();\nbInteger.setX(67);\nInteger i = bInteger.getX();\n</code></pre></p> <p>If the caller tries to call <pre><code>String s = bInteger.getX();\n</code></pre></p> <p>the compiler will report an error about type mismatch.  The type checking is done at compile time, before type erasure happens.  Crucially, the type argument <code>Integer</code> to <code>B&lt;Integer&gt;</code> is used to type check the call to <code>getX()</code>.</p> <p>What if <code>x</code> is a static variable?  Consider the following code:</p> Class Field with Type Parameter<pre><code>class C&lt;T&gt; { \n  private static T x;\n\n  public static void setX(T x) { \n    C.x = x; \n  }\n\n  public static T getX() { \n    return C.x; \n  }\n}\n</code></pre> <p>We can access class fields and class methods using only the class name, without creating an instance. <pre><code>C.setX(67);\nString s = C.getX();\n</code></pre></p> <p>There is no type argument to <code>C</code> here, so the compiler is unable to type check the call to <code>getX()</code>.  To avoid this, Java does not allow using the type parameter <code>T</code> in a static context.  There is only one copy of the static variable <code>x</code> shared across all instantiations of <code>C&lt;T&gt;</code>, regardless of what type argument is used.  Thus, it does not make sense to have a static variable or static method that depends on the type parameter <code>T</code> of the class.</p> <p>As a result, it is necessary for a generic class method to declare its own type parameters.  For example:</p> Static Generic Method<pre><code>class D&lt;T&gt; {\n  public static &lt;T&gt; T foo(T x) {\n    // body omitted\n  }\n}\n</code></pre> <p>Note that the type parameter <code>T</code> of the static method <code>foo</code> is independent of the type parameter <code>T</code> of the class <code>D</code>.</p>"},{"location":"24-erasure.html#generics-and-arrays-cant-mix","title":"Generics and Arrays Can't Mix","text":"<p>Let's consider the hypothetical code below:</p> <pre><code>// create a new array of pairs\nPair&lt;String,Integer&gt;[] pairArray = new Pair&lt;String,Integer&gt;[2];\n\n// pass around the array of pairs as an array of object\nObject[] objArray = pairArray;\n\n// put a pair into the array -- no ArrayStoreException!\nobjArray[0] = new Pair&lt;Double,Boolean&gt;(3.14, true);\n</code></pre> <p>This is similar to what we have in Unit 21, where we showed we could get an <code>ArrayStoreException</code> due to Java arrays being covariant.  We would not, however, get an exception when we try to put a pair of double and boolean, into an array meant to store a pair of string and integer!  This type checking is done during runtime, and due to type erasure, the runtime has no information about what is the type arguments to <code>Pair</code>.  The runtime sees:</p> <pre><code>// create a new array of pairs\nPair[] pairArray = new Pair[2];\n\n// pass around the array of pairs as an array of object\nObject[] objArray = pairArray;\n\n// put a pair into the array -- no ArrayStoreException!\nobjArray[0] = new Pair(3.14, true);\n</code></pre> <p>It checks that we have an array of pairs and we are putting another pair inside.   Everything checks out.  This would have caused a heap pollution, a term that refers to the situation where a variable of a parameterized type refers to an object that is not of that parameterized type.</p> <p>Heap pollution is dangerous, as now, we will get a <code>ClassCastException</code> when we do: <pre><code>// getting back a string?  -- now we get ClassCastException\nString str = pairArray[0].getFirst();\n</code></pre></p> <p>The example above shows why generics and arrays don't mix well together.  An array is what is called reifiable type \u2014 a type where full type information is available during runtime.  It is because the Java array is reifiable that the Java runtime can check what we store into the array matches the type of the array and throw an <code>ArrayStoreException</code> at us if there is a mismatch.  Java generics, however, is not reifiable due to type erasure.  Java designers have decided not to mix the two.</p> <p>The hypothetical code above actually is not a valid Java syntax.  We can't compile this line: <pre><code>Pair&lt;String,Integer&gt;[] pairArray = new Pair&lt;String,Integer&gt;[2];\n</code></pre></p> <p>The following is illegal as well: <pre><code>new Pair&lt;S,T&gt;[2];\nnew T[2];\n</code></pre></p> <p>However, given a generic type <code>T</code>, the following is allowed:</p> <pre><code>T[] array;\n</code></pre> <p>In summary, generic array declaration is fine but generic array instantiation is not.</p>"},{"location":"24-erasure.html#bridge-methods","title":"Bridge Methods","text":"<p>Type erasure has an important consequence when inheritance and method overriding interact with generics. To preserve polymorphism after erasure, the Java compiler sometimes generates additional methods known as bridging methods (or bridge methods).</p> <p>Consider the following example:</p> Generic Superclass<pre><code>class Box&lt;T&gt; {\n  void get(T t) {\n    // body omitted  \n  }\n}\n\nclass StringBox extends Box&lt;String&gt; {\n  @Override\n  void get(String s) {\n    // body omitted\n  }\n}\n</code></pre> <p>At the source level, <code>StringBox::get(String)</code> clearly overrides <code>Box::get(T)</code>.</p> <p>After erasure, the compiler conceptually sees:</p> After erasure<pre><code>class Box {\n  void get(Object o) {\n    // body omitted\n  }\n}\n\nclass StringBox extends Box {\n  void get(String s) {\n    // body omitted\n  }\n}\n</code></pre> <p>The two methods now have different descriptors: <code>void get(Object)</code> and <code>void get(String)</code>, breaking polymorphism.</p> <p>In such situation, where (i) a class is a subtype of a parameterized type and (ii) type erasure changes the signature of any inherited method, the Java compiler automatically generates a bridging method.  </p> <p>In the case of <code>StringBox</code>, </p> <pre><code>class StringBox extends Box {\n  // compiler-generated bridge method\n  void get(Object s) {\n    this.get((String) s);   \n  }\n\n  // programmer-defined method\n  void get(String s) {\n    // body omitted\n  }\n}\n</code></pre> <p>The bridge method <code>get(Object)</code> simply casts its argument to <code>String</code> and delegates to the programmer-defined <code>get(String)</code>. This synthetically generated method preserves the semantic of polymorphism, </p>"},{"location":"25-unchecked.html","title":"Unit 25: Unchecked Warnings","text":"<p>Learning Objectives</p> <p>After completing this unit, students should be able to:</p> <ul> <li>Explain why arrays and generics do not mix well in Java and how unchecked warnings arise.</li> <li>Interpret unchecked warnings produced by the Java compiler (<code>-Xlint:unchecked</code>).</li> <li>Reason about and justify (informally) the type safety of simple generic code despite unchecked casts.</li> <li>Use <code>@SuppressWarnings(\"unchecked\")</code> correctly, minimally, and ethically.</li> <li>Explain what raw types are, why they exist, and why they should generally be avoided in modern Java.</li> </ul> <p>Overview</p> <p>In earlier units, we learned that Java\u2019s type system helps detect many errors at compile time, preventing failures such as <code>ClassCastException</code> at run time. Generics play a crucial role in achieving this safety. However, there are situations, especially when implementing generic data structures, where the compiler cannot fully verify type safety. In these cases, Java issues unchecked warnings rather than errors.</p> <p>This unit explores why unchecked warnings arise, what they mean, and how programmers should respond to them. We will see how type erasure, arrays, and raw types interact in subtle ways, and why the compiler sometimes has to rely on human reasoning instead of static checks. We will also discuss when (and when not) it is appropriate to suppress warnings, emphasizing both technical correctness and professional responsibility.</p>"},{"location":"25-unchecked.html#creating-arrays-with-type-parameters","title":"Creating Arrays with Type Parameters","text":"<p>We have seen how arrays and generics do not mix well.  One way to get around this is to use Java Collections, a library of data structures provided by Java, instead of arrays, to store our items.  The <code>ArrayList</code> class provides similar functionality to an array, with some performance overhead.  </p> <pre><code>ArrayList&lt;Pair&lt;String,Integer&gt;&gt; pairList;\npairList = new ArrayList&lt;Pair&lt;String,Integer&gt;&gt;(); // ok\n\npairList.add(0, new Pair&lt;Double,Boolean&gt;(3.14, true));  // error\n\nArrayList&lt;Object&gt; objList = pairList;  // error\n</code></pre> <p><code>ArrayList</code> itself is a generic class, and when parameterized, it ensures type safety by checking for appropriate types during compile time.  We can't add a <code>Pair&lt;Double,Boolean&gt;</code> object to a list of <code>Pair&lt;String,Integer&gt;</code>.  Furthermore, unlike Java arrays, which is covariant, generics are invariant.  There is no subtyping relationship between <code>ArrayList&lt;Object&gt;</code> and <code>ArrayList&lt;Pair&lt;String,Integer&gt;&gt;</code> so we can't alias one with another, preventing the possibility of heap pollution.</p> <p>Using <code>ArrayList</code> instead of arrays only gets around the problem of mixing arrays and generics, as a user.  <code>ArrayList</code> is implemented with an array internally after all.  As computing students, especially computer science students, it is important to know how to implement your own data structures instead of using ones provided by Java or other libraries.  </p> <p>Let's try to build one and to minimize confusion let's call it <code>Seq&lt;T&gt;</code>: Seq&lt;T&gt; v0.1 with getArray<pre><code>class Seq&lt;T&gt; {\n  private T[] array;\n\n  public Seq(int size) {\n    this.array = (T[]) new Object[size];\n  }\n\n  public void set(int index, T item) {\n    this.array[index] = item;\n  }\n\n  public T get(int index) {\n    return this.array[index];\n  }\n\n  public T[] getArray() {\n    return this.array;\n  }\n}\n</code></pre></p> <p>This generic class is a wrapper around an array of type <code>T</code>.  Recall that we can't instantiate a generic type directly (i.e. <code>new T[]</code>).  On Line 6, to get around this restriction, we instantiate (<code>new</code>) an <code>Object</code> array instead, and then cast it to an array of <code>T[]</code> instead.</p> <p>The code now compiles, but we receive the following message: <pre><code>$ javac Seq.java\nNote: Seq.java uses unchecked or unsafe operations.\nNote: Recompile with -Xlint:unchecked for details.\n</code></pre></p> <p>Let's do what the compiler tells us, and compile with the <code>-Xlint:unchecked</code> flags. <pre><code>$ javac -`lint:unchecked Seq.java\nSeq.java:6: warning: [unchecked] unchecked cast\n    array = (T[]) new Object[size];\n                  ^\n  required: T[]\n  found:    Object[]\n  where T is a type-variable:\n    T extends Object declared in class Seq\n1 warning\n</code></pre></p> <p>We get a warning that our Line 6 is doing an unchecked cast.  </p>"},{"location":"25-unchecked.html#unchecked-warnings","title":"Unchecked Warnings","text":"<p>An unchecked warning is a message from the compiler that it has done what it can, and because of type erasures, there could be a runtime error that it cannot prevent. They indicate that the compiler cannot prove type safety, not that the code is necessarily unsafe. The responsibility shifts from the compiler to the programmer.</p> <p>Recall that type erasure generates the following code: <pre><code>(String) array.get(0);\n</code></pre></p> <p>Since <code>array</code> is an array of <code>Object</code> instances and the Java array is covariant, the compiler can't guarantee that the code it generated is safe anymore.</p> <p>Consider the following: <pre><code>Seq&lt;String&gt; seq = new Seq&lt;String&gt;(4);\nObject[] objArray = seq.getArray();\nobjArray[0] = 4;\nseq.get(0);  // ClassCastException\n</code></pre></p> <p>The last line would generate a <code>ClassCastException</code>, exactly a scenario that the compiler has warned us.</p> <p>It is now up to us humans to change our code so that the code is safe.  Suppose we remove the <code>getArray</code> method from the <code>Seq</code> class,</p> Seq&lt;T&gt; v0.2 without getArray<pre><code>class Seq&lt;T&gt; {\n  private T[] array;\n\n  public Seq(int size) {\n    this.array = (T[]) new Object[size];\n  }\n\n  public void set(int index, T item) {\n    this.array[index] = item;\n  }\n\n  public T get(int index) {\n    return this.array[index];\n  }\n}\n</code></pre> <p>Can we prove that our code is type-safe?  In this case, yes.  Since <code>array</code> is declared as <code>private</code>, the only way someone can put something into the <code>array</code> is through the <code>Seq::set</code> method<sup>1</sup>.  <code>Seq::set</code> only put items of type <code>T</code> into <code>array</code>.  So the only type of objects we can get out of <code>array</code> must be of type <code>T</code>.  So we, as humans, can see that casting <code>Object[]</code> to <code>T[]</code> is type-safe.</p> <p>If we are sure (and only if we are sure) that the line <pre><code>    array = (T[]) new Object[size];\n</code></pre></p> <p>is safe, we can thank the compiler for its warning and assure the compiler that everything is going to be fine.  We can do so with the <code>@SuppressWarnings(\"unchecked\")</code> annotation.</p> Seq&lt;T&gt; v0.3 with @SuppressWarnings<pre><code>class Seq&lt;T&gt; {\n  private T[] array;\n\n  public Seq(int size) {\n    // The only way we can put an object into array is through\n    // the method set() and we only put object of type T inside.\n    // So it is safe to cast `Object[]` to `T[]`.\n    @SuppressWarnings(\"unchecked\")\n    T[] a = (T[]) new Object[size];\n    this.array = a;\n  }\n\n  public void set(int index, T item) {\n    this.array[index] = item;\n  }\n\n  public T get(int index) {\n    return this.array[index];\n  }\n}\n</code></pre> <p><code>@SuppressWarnings</code> is a powerful annotation that suppresses warning messages from compilers.  Like everything that is powerful, we have the responsibility to use it properly:</p> <ul> <li><code>@SuppressWarnings</code> can apply to declaration at a different scope: a local variable, a method, a type, etc.  We must always use <code>@SuppressWarnings</code> to the most limited scope to avoid unintentionally suppressing warnings that are valid concerns from the compiler.  In CS2030/S, we only allow applying <code>@SuppressWarnings</code> to local variables.</li> <li>We must suppress a warning only if we are sure that it will not cause a type error later.  Note that suppressing a warning does not fix the underlying problem.  It only hides the warning from the compiler.  If we are wrong, we are on our own.</li> <li>We must always add a note (as a comment) to fellow programmers explaining why a warning can be safely suppressed.</li> </ul> <p>Note that since <code>@SuppressWarnings</code> cannot apply to an assignment but only to the declaration, we declare a local variable <code>a</code> in the example above before assigning <code>this.array</code> to <code>a</code>.</p>"},{"location":"25-unchecked.html#raw-types","title":"Raw Types","text":"<p>Another common scenario where we can get an unchecked warning is the use of raw types.  A raw type is a generic type used without type arguments.  Suppose we do: <pre><code>Seq s = new Seq(4);\n</code></pre></p> <p>The code would compile perfectly.  We are using the generic <code>Seq&lt;T&gt;</code> as a raw type <code>Seq</code>.  Java allows this code to compile for backward compatibility.  This is anyway what the code looks like after type erasure and how we would write the code in Java before version 5.   Without a type argument, the compiler can't do any type-checking at all.  We are back to the uncertainty that our code could bomb with <code>ClassCastException</code> after it ships.</p> <p>Mixing raw types with parameterized types can also lead to errors.  Consider: <pre><code>Seq&lt;String&gt; s = new Seq&lt;String&gt;(4);\npopulateSeq(s);\nString str = s.get(0);\n</code></pre></p> <p>where the method <code>populateSeq</code> uses raw types: <pre><code>void populateSeq(Seq s) {\n  s.set(0, 1234);\n}\n</code></pre></p> <p>Since we use raw types in this method, the compiler can't help us.  It will warn us: <pre><code>Seq.java:24: warning: [unchecked] unchecked call to set(int,T) as a member of the raw type Seq\n    s.set(0, 1234);\n         ^\n  where T is a type-variable:\n    T extends Object declared in class Seq\n1 warning\n</code></pre></p> <p>If we ignore this warning or worse, suppress this warning, we will get a runtime error when we execute <code>s.get(0)</code>.</p> <p>Raw types exists in modern Java for backward compatibility reason, and it could behave in an unexpected way.  For instance, if we have a generic type <code>A&lt;T&gt;</code>, then <code>A</code> \\(&lt;:\\) <code>A&lt;T&gt;</code> and <code>A&lt;T&gt;</code> \\(&lt;:\\) <code>A</code>.</p> <p>Raw types must not be used in your code, ever.  For now, the only exception to this rule is using it as an operand of the <code>instanceof</code> operator.  Since <code>instanceof</code> checks for runtime type and type arguments have been erased, we can only use the <code>instanceof</code> operator on raw types.  We will remove this allowance after we introduce wildcards in later units.</p> <ol> <li> <p>Another win for information hiding!\u00a0\u21a9</p> </li> </ol>"},{"location":"26-wildcard.html","title":"Unit 26: Wildcards","text":"<p>Learning Objectives</p> <p>After completing this unit, students should be able to:</p> <ul> <li>explain why Java generics are invariant and how this limits method flexibility</li> <li>use upper-bounded (<code>? extends T</code>) and lower-bounded (<code>? super T</code>) wildcards to safely relax type constraints</li> <li>reason about covariance and contravariance induced by wildcards</li> <li>reason about and apply the PECS principle to method parameters</li> <li>distinguish between <code>Seq&lt;?&gt;</code>, <code>Seq&lt;Object&gt;</code>, and raw <code>Seq</code>, and explain why raw types should be avoided</li> </ul> <p>Overview</p> <p>In earlier units, we saw how generics help us write reusable and type-safe code. However, we also encountered an important limitation: generics in Java are invariant. This means that even if <code>Circle</code> is a subtype of <code>Shape</code>, <code>Seq&lt;Circle&gt;</code> is not a subtype of <code>Seq&lt;Shape&gt;</code>.</p> <p>While invariance prevents subtle runtime errors, it can also make otherwise reasonable code impossible to write. For example, why can\u2019t we search for a <code>Shape</code> in a sequence of circles, or copy a sequence of circles into a sequence of shapes?</p> <p>In this unit, we introduce wildcards as a way to recover flexibility without sacrificing type safety. We will see how bounded wildcards express variance explicitly, how the PECS principle guides our choice of bounds, and how unbounded wildcards let us avoid raw types entirely.</p>"},{"location":"26-wildcard.html#contains-with-seqt","title":"<code>contains</code> with <code>Seq&lt;T&gt;</code>","text":"<p>Now that we have our <code>Seq&lt;T&gt;</code> class, let's modify our generic <code>contains</code> method and replace the type of the argument <code>T[]</code> with <code>Seq&lt;T&gt;</code>.</p> contains v0.5 (with Seq&lt;T&gt;)<pre><code>class A {\n  public static &lt;T&gt; boolean contains(Seq&lt;T&gt; seq, T obj) {\n    for (int i = 0; i &lt; seq.getLength(); i++) {\n      T curr = seq.get(i);\n      if (curr.equals(obj)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n</code></pre> <p>Similar to the version that takes in <code>T[]</code>, using generics allows us to constrain the type of the elements of the sequence and the object to search for to be the same.  This allows the following code to type-check correctly: <pre><code>Seq&lt;String&gt; stringSeq;\nSeq&lt;Circle&gt; circleSeq;\nCircle circle;\n :\nA.&lt;String&gt;contains(stringSeq, \"hello\"); // ok\nA.&lt;Circle&gt;contains(circleSeq, circle); // ok\n</code></pre></p> <p>But trying to search for a circle in a sequence of strings would lead to a type error: <pre><code>A.&lt;String&gt;contains(stringSeq, circle); // error\n</code></pre></p> <p>Consider now having a sequence of shapes. <pre><code>Seq&lt;Shape&gt; shapeSeq;\nSeq&lt;Circle&gt; circleSeq;\nShape shape;\nCircle circle;\n :\nA.&lt;Shape&gt;contains(shapeSeq, shape); // ok\nA.&lt;Circle&gt;contains(circleSeq, circle); // ok\n</code></pre></p> <p>As expected, we can pass <code>Shape</code> as the argument for <code>T</code>, and search for a <code>Shape</code> in an instance of <code>Seq&lt;Shape&gt;</code>. Similarly, we can pass <code>Circle</code> as the argument for <code>T</code> and search for a <code>Circle</code> in an instance of <code>Seq&lt;Circle&gt;</code>.</p> <p>We could also look for a <code>Circle</code> instance from <code>Seq&lt;Shape&gt;</code> if we pass <code>Shape</code> as the argument for <code>T</code>. <pre><code>A.&lt;Shape&gt;contains(shapeSeq, circle); // ok\n</code></pre></p> <p>Note that we can pass in a <code>Circle</code> instance as a <code>Shape</code>, since <code>Circle</code> &lt;: <code>Shape</code>.</p> <p>Generics are invariant in Java, i.e., there is no subtyping relationship between <code>Seq&lt;Shape&gt;</code> and <code>Seq&lt;Circle&gt;</code>.  <code>Seq&lt;Circle&gt;</code> is not a subtype of <code>Seq&lt;Shape&gt;</code>.  Otherwise, it would violate the Liskov Substitution Principle: we can put a square into a <code>Seq&lt;Shape&gt;</code> instance, but we can't put a square into a <code>Seq&lt;Circle&gt;</code> instance.</p> <p>So, we can't call: <pre><code>A.&lt;Circle&gt;contains(shapeSeq, circle); // compilation error\n</code></pre></p> <p>The following would result in compilation errors as well: <pre><code>A.&lt;Shape&gt;contains(circleSeq, shape); // compilation error\nA.&lt;Circle&gt;contains(circleSeq, shape); // compilation error\n</code></pre></p> <p>Thus, with our current implementation, we can't look for a shape (which may be a circle) in a sequence of circles, even though this is something reasonable that a programmer might want to do.  This constraint is due to the invariance of generics \u2014 while we avoided the possibility of runtime errors by avoiding the covariance of arrays, our methods have become less general.</p> <p>Let's see how we can fix this with bounded type parameters first.  We can introduce another type parameter, say <code>S</code>, to remove the constraints that the type of the sequence must be the same as the type of the object to search for,  i.e., we change from <pre><code>  public static &lt;T&gt; boolean contains(Seq&lt;T&gt; seq, T obj) { .. }\n</code></pre></p> <p>to: <pre><code>  public static &lt;S,T&gt; boolean contains(Seq&lt;T&gt; seq, S obj) { .. }\n</code></pre></p> <p>But we don't want to completely decouple <code>T</code> and <code>S</code>, as we want <code>T</code> to be a subtype of <code>S</code>.  We can thus make <code>T</code> a bounded type parameter, and write: <pre><code>  public static &lt;S, T extends S&gt; boolean contains(Seq&lt;T&gt; seq, S obj) { .. }\n</code></pre></p> <p>Now, we can search for a shape in a sequence of circles. <pre><code>A.&lt;Shape,Circle&gt;contains(circleSeq, shape);\n</code></pre></p>"},{"location":"26-wildcard.html#copying-to-and-from-seqt","title":"Copying to and from <code>Seq&lt;T&gt;</code>","text":"<p>Let's consider another example.  Let's add two methods <code>copyFrom</code> and <code>copyTo</code>, to <code>Seq&lt;T&gt;</code> so that we can copy to and from one sequence to another.</p> Seq&lt;T&gt; v0.4 (with copy)<pre><code>class Seq&lt;T&gt; {\n  private T[] array;\n\n  public Seq(int size) {\n  // The only way we can put an object into the array is through\n  // the method set() and we only put an object of type T inside.\n  // So it is safe to cast `Object[]` to `T[]`.\n  @SuppressWarnings(\"unchecked\")\n    T[] a = (T[]) new Object[size];\n    this.array = a;\n  }\n\n  public void set(int index, T item) {\n    this.array[index] = item;\n  }\n\n  public T get(int index) {\n    return this.array[index];\n  }\n\n  public void copyFrom(Seq&lt;T&gt; src) {\n    int len = Math.min(this.array.length, src.array.length);\n    for (int i = 0; i &lt; len; i++) {\n        this.set(i, src.get(i));\n    }\n  }\n\n  public void copyTo(Seq&lt;T&gt; dest) {\n    int len = Math.min(this.array.length, dest.array.length);\n    for (int i = 0; i &lt; len; i++) {\n        dest.set(i, this.get(i));\n    }\n  }\n}\n</code></pre> <p>With this implementation, we can copy, say, a <code>Seq&lt;Circle&gt;</code> to another <code>Seq&lt;Circle&gt;</code>, a <code>Seq&lt;Shape&gt;</code> to another <code>Seq&lt;Shape&gt;</code>, but not a <code>Seq&lt;Circle&gt;</code> into a <code>Seq&lt;Shape&gt;</code>, even though each circle is a shape!</p> <pre><code>Seq&lt;Circle&gt; circleSeq;\nSeq&lt;Shape&gt; shapeSeq;\n  :\nshapeSeq.copyFrom(circleSeq); // error\ncircleSeq.copyTo(shapeSeq); // error\n</code></pre>"},{"location":"26-wildcard.html#upper-bounded-wildcards","title":"Upper-Bounded Wildcards","text":"<p>Let's consider the method <code>copyFrom</code>.  We should be able to copy from a sequence of shapes, a sequence of circles, a sequence of squares, etc, into a sequence of shapes.  In other words, we should be able to copy from a sequence of any subtype of shapes into a sequence of shapes.  Is there such a type in Java?</p> <p>The type that we are looking for is <code>Seq&lt;? extends Shape&gt;</code>.  This generic type uses the wildcard <code>?</code>.  Just like a wildcard in card games, it is a substitute for any type.   A wildcard can be bounded.  Here, this wildcard is upper-bounded by <code>Shape</code>, i.e., it can be substituted with either <code>Shape</code> or any subtype of <code>Shape</code>.</p> <p>The upper-bounded wildcard is an example of covariance. The upper-bounded wildcard has the following subtyping relations:</p> <ul> <li>If <code>S</code> &lt;: <code>T</code>, then <code>A&lt;? extends S&gt;</code> &lt;: <code>A&lt;? extends T&gt;</code> (covariance)</li> <li>For any type <code>S</code>, <code>A&lt;S&gt;</code> &lt;: <code>A&lt;? extends S&gt;</code></li> </ul> <p>For instance, we have:</p> <ul> <li><code>Seq&lt;Circle&gt;</code> &lt;: <code>Seq&lt;? extends Circle&gt;</code></li> <li>Since <code>Circle</code> &lt;: <code>Shape</code>, <code>Seq&lt;? extends Circle&gt;</code> &lt;: <code>Seq&lt;? extends Shape&gt;</code></li> <li>Since subtyping is transitive, we have <code>Seq&lt;Circle&gt;</code> &lt;: <code>Seq&lt;? extends Shape&gt;</code></li> </ul> <p>Because <code>Seq&lt;Circle&gt;</code> &lt;: <code>Seq&lt;? extends Shape&gt;</code>, if we change the type of the parameter of <code>copyFrom</code> to <code>Seq&lt;? extends T&gt;</code>,  <pre><code>  public void copyFrom(Seq&lt;? extends T&gt; src) {\n    int len = Math.min(this.array.length, src.array.length);\n    for (int i = 0; i &lt; len; i++) {\n        this.set(i, src.get(i));\n    }\n  }\n</code></pre></p> <p>We can now call: <pre><code>shapeSeq.copyFrom(circleSeq); // ok\n</code></pre></p> <p>without error.</p> <p> Important Distinction between Wildcards and Type Variables</p> <p>Wildcards are not type variables.  A wildcard <code>?</code> cannot be used in place of a type variable.  For instance, the following code would not compile:</p> <pre><code>class A&lt;? extends Circle&gt; { // compilation error\n}\n</code></pre> <p>A wildcard and its bounds can only be used in the context of parameterized types, as type argument.  </p>"},{"location":"26-wildcard.html#lower-bounded-wildcards","title":"Lower-Bounded Wildcards","text":"<p>Let's now try to allow copying of a <code>Seq&lt;Circle&gt;</code> to <code>Seq&lt;Shape&gt;</code>. <pre><code>circleSeq.copyTo(shapeSeq); \n</code></pre></p> <p>by doing the same thing: <pre><code>  public void copyTo(Seq&lt;? extends T&gt; dest) {\n    int len = Math.min(this.array.length, dest.array.length);\n    for (int i = 0; i &lt; len; i++) {\n        dest.set(i, this.get(i));\n    }\n  }\n</code></pre></p> <p>The code above would not compile.  We will get the following somewhat cryptic message when we compile with the <code>-Xdiags:verbose</code> flag: <pre><code>Seq.java:32: error: method set in class Seq&lt;T&gt; cannot be applied to given types;\n        dest.set(i, this.get(i));\n          ^\n  required: int,CAP#1\n  found: int,T\n  reason: argument mismatch; T cannot be converted to CAP#1\n  where T is a type-variable:\n    T extends Object declared in class Seq\n  where CAP#1 is a fresh type-variable:\n    CAP#1 extends T from capture of ? extends T\n</code></pre></p> <p>Let's try not to understand what the error message means first, and think about what could go wrong if the compiler allows: <pre><code>        dest.set(i, this.get(i));\n</code></pre></p> <p>Here, we are trying to put an instance with compile-time type <code>T</code> into a sequence that contains elements with the compile-time type of <code>T</code> or subtype of <code>T</code>.  </p> <p>The <code>copyTo</code> method of <code>Seq&lt;Shape&gt;</code> would allow a <code>Seq&lt;Circle&gt;</code> as an argument, and we would end up putting instance with compile-time type <code>Shape</code> into <code>Seq&lt;Circle&gt;</code>.  If all the shapes are circles, we are fine, but there might be other shapes (rectangles, squares) in <code>this</code> instance of <code>Seq&lt;Shape&gt;</code>, and we can't fit them into <code>Seq&lt;Circle&gt;</code>!  Thus, the line  <pre><code>        dest.set(i, this.get(i));\n</code></pre></p> <p>is not type-safe and could lead to <code>ClassCastException</code> during runtime.  </p> <p>Where can we copy our shapes into?  We can only copy them safely into a <code>Seq&lt;Shape&gt;</code>, <code>Seq&lt;Object&gt;</code>, <code>Seq&lt;GetAreable&gt;</code>, for instance.  In other words, into sequences containing <code>Shape</code> or supertype of <code>Shape</code>.  </p> <p>We need a wildcard lower-bounded by <code>Shape</code>, and Java's syntax for this is <code>? super Shape</code>.  Using this new notation, we can replace the type for <code>dest</code> with:</p> <pre><code>  public void copyTo(Seq&lt;? super T&gt; dest) {\n    int len = Math.min(this.array.length, dest.array.length);\n    for (int i = 0; i &lt; len; i++) {\n        dest.set(i, this.get(i));\n    }\n  }\n</code></pre> <p>The code would now type-check and compile.</p> <p>The lower-bounded wildcard is an example of contravariance.  We have the following subtyping relations:</p> <ul> <li>If <code>S</code> &lt;: <code>T</code>, then <code>A&lt;? super T&gt;</code> &lt;: <code>A&lt;? super S&gt;</code> (contravariance)</li> <li>For any type <code>S</code>, <code>A&lt;S&gt;</code> &lt;: <code>A&lt;? super S&gt;</code></li> </ul> <p>For instance, we have:</p> <ul> <li><code>Seq&lt;Shape&gt;</code> &lt;: <code>Seq&lt;? super Shape&gt;</code></li> <li>Since <code>Circle</code> &lt;: <code>Shape</code>, <code>Seq&lt;? super Shape&gt;</code> &lt;: <code>Seq&lt;? super Circle&gt;</code></li> <li>Since subtyping is transitive, we have <code>Seq&lt;Shape&gt;</code> &lt;: <code>Seq&lt;? super Circle&gt;</code></li> </ul> <p>The line of code below now compiles: <pre><code>circleSeq.copyTo(shapeSeq); \n</code></pre></p> <p>Our new <code>Seq&lt;T&gt;</code> is now Seq&lt;T&gt; v0.5 (with flexible copy using wildcards)<pre><code>class Seq&lt;T&gt; {\n  private T[] array;\n\n  public Seq(int size) {\n    // The only way we can put an object into the array is through\n    // the method set() and we only put an object of type T inside.\n    // So it is safe to cast `Object[]` to `T[]`.\n    @SuppressWarnings(\"unchecked\")\n    T[] a = (T[]) new Object[size];\n    this.array = a;\n  }\n\n  public void set(int index, T item) {\n    this.array[index] = item;\n  }\n\n  public T get(int index) {\n    return this.array[index];\n  }\n\n  public void copyFrom(Seq&lt;? extends T&gt; src) {\n    int len = Math.min(this.array.length, src.array.length);\n    for (int i = 0; i &lt; len; i++) {\n      this.set(i, src.get(i));\n    }\n  }\n\n  public void copyTo(Seq&lt;? super T&gt; dest) {\n    int len = Math.min(this.array.length, dest.array.length);\n    for (int i = 0; i &lt; len; i++) {\n      dest.set(i, this.get(i));\n    }\n  }\n}\n</code></pre></p>"},{"location":"26-wildcard.html#pecs","title":"PECS","text":"<p>Now we will introduce the rule that governs when we should use the upper-bounded wildcard <code>? extends T</code> or the lower-bounded wildcard <code>? super T</code>.  This choice depends on the role of the variable in our program.   If the variable is a producer that returns a variable of type <code>T</code>, it should be declared with the wildcard <code>? extends T</code>.  Otherwise, if it is a consumer that accepts a variable of type <code>T</code>, it should be declared with the wildcard <code>? super T</code>.</p> <p>As an example, the variable <code>src</code> in <code>copyFrom</code> above acts as a producer.  It produces a variable of type <code>T</code>.  The type parameter for <code>src</code> must be either <code>T</code> or a subtype of <code>T</code> to ensure type safety.  So the type for <code>src</code> is <code>Seq&lt;? extends T&gt;</code>.    </p> <p>On the other hand, the variable <code>dest</code> in <code>copyTo</code> above acts as a consumer.  It consumes a variable of type <code>T</code>.  The type parameter of <code>dest</code> must be either <code>T</code> or supertype of <code>T</code> for it to be type-safe.  As such, the type for <code>dest</code> is <code>Seq&lt;? super T&gt;</code>.  </p> <p>This rule can be remembered with the mnemonic PECS, or \"Producer Extends; Consumer Super\".</p>"},{"location":"26-wildcard.html#unbounded-wildcards","title":"Unbounded Wildcards","text":"<p>It is also possible to have unbounded wildcards, such as <code>Seq&lt;?&gt;</code>.  <code>Seq&lt;?&gt;</code> is the supertype of every parameterized type of <code>Seq&lt;T&gt;</code>.  Recall that <code>Object</code> is the supertype of all reference types.  When we want to write a method that takes in a reference type, but we want the method to be flexible enough, we can make the method accept a parameter of type <code>Object</code>.  Similarly, <code>Seq&lt;?&gt;</code> is useful when you want to write a method that takes in a sequence of some specific type, and you want the method to be flexible enough to take in a sequence of any type.  For instance, if we have:</p> <pre><code>void foo(Seq&lt;?&gt; seq) {\n}\n</code></pre> <p>We could call it with: <pre><code>Seq&lt;Circle&gt; ac;\nSeq&lt;String&gt; as;\nfoo(ac); // ok\nfoo(as); // ok\n</code></pre></p> <p>A method that takes in generic type with an unbounded wildcard is actually pretty restrictive.  Consider the following: <pre><code>void foo(Seq&lt;?&gt; seq) {\n   :\n  x = seq.get(0);\n  seq.set(0, y);\n\n}\n</code></pre></p> <p>What should the type of the returned element <code>x</code> be?  Since <code>Seq&lt;?&gt;</code> is the supertype of all possible <code>Seq&lt;T&gt;</code>, the method <code>foo</code> can receive an instance of <code>Seq&lt;Circle&gt;</code>, <code>Seq&lt;String&gt;</code>, etc. as an argument.  The only safe choice for the type of <code>x</code> is <code>Object</code>.</p> <p>The type for <code>y</code> is even more restrictive.  Since there are many possibilities of what type of sequence it is receiving, we can only put <code>null</code> into <code>seq</code>! </p> <p>There is an important distinction to be made between <code>Seq</code>, <code>Seq&lt;?&gt;</code> and <code>Seq&lt;Object&gt;</code>.  Whilst <code>Object</code> is the supertype of all <code>T</code>, it does not follow that <code>Seq&lt;Object&gt;</code> is the supertype of all <code>Seq&lt;T&gt;</code> due to generics being invariant. Therefore, the following statements will fail to compile:</p> <pre><code>Seq&lt;Object&gt; a1 = new Seq&lt;String&gt;(0); \nSeq&lt;Object&gt; a2 = new Seq&lt;Integer&gt;(0);\n</code></pre> <p>Whereas the following statements will compile:</p> <pre><code>Seq&lt;?&gt; a1 = new Seq&lt;String&gt;(0); // Does compile\nSeq&lt;?&gt; a2 = new Seq&lt;Integer&gt;(0); // Does compile\n</code></pre> <p>If we have a function <pre><code>void bar(Seq&lt;Object&gt; seq) {\n}\n</code></pre></p> <p>Then, the method <code>bar</code> is restricted to only take in a <code>Seq&lt;Object&gt;</code> instance as argument. <pre><code>Seq&lt;Circle&gt; ac;\nSeq&lt;String&gt; as;\nbar(ac); // compilation error\nbar(as); // compilation error\n</code></pre></p> <p>What about raw types?  Suppose we write the method below that accepts a raw type <pre><code>void qux(Seq seq) {\n}\n</code></pre></p> <p>Then, the method <code>qux</code> is also flexible enough to take in any <code>Seq&lt;T&gt;</code> as argument. <pre><code>Seq&lt;Circle&gt; ac;\nSeq&lt;String&gt; as;\nqux(ac); \nqux(as); \n</code></pre></p> <p>Unlike <code>Seq&lt;?&gt;</code>, however, the compiler does not have the information about the type of the component of the sequence, and cannot type check for us.  It is up to the programmer to ensure type safety.  For this reason, we must not use raw types.</p> <p>Intuitively, we can think of <code>Seq&lt;?&gt;</code>, <code>Seq&lt;Object&gt;</code>, and <code>Seq</code> as follows:</p> <ul> <li><code>Seq&lt;?&gt;</code> is a sequence of objects of some specific, but unknown type;</li> <li><code>Seq&lt;Object&gt;</code> is a sequence of <code>Object</code> instances, with type checking by the compiler;</li> <li><code>Seq</code> is a sequence of <code>Object</code> instances, without type checking.</li> </ul>"},{"location":"26-wildcard.html#back-to-contains","title":"Back to <code>contains</code>","text":"<p>Now, let's simplify our <code>contains</code> methods with the help of wildcards.  Recall that to add flexibility into the method parameter and allow us to search for a shape in a sequence of circles, we have modified our method into the following:</p> contains v0.6 (with Seq&lt;T&gt;)<pre><code>class A { \n  public static &lt;S,T extends S&gt; boolean contains(Seq&lt;T&gt; seq, S obj) {\n    for (int i = 0; i &lt; seq.getLength(); i++) {\n      T curr = seq.get(i);\n      if (curr.equals(obj)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n</code></pre> <p>Can we make this simpler using wildcards?  Since we want to search for an object of type <code>S</code> in a sequence of its subtype, we can remove the second parameter type <code>T</code> and change the type of <code>seq</code> to <code>Seq&lt;? extends S&gt;</code>:</p> contains v0.7 (with wild cards)<pre><code>class A {\n  public static &lt;S&gt; boolean contains(Seq&lt;? extends S&gt; seq, S obj) {\n    for (int i = 0; i &lt; seq.getLength(); i++) {\n      S curr = seq.get(i);\n      if (curr.equals(obj)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n</code></pre> <p>We can double-check that <code>seq</code> is a producer (it produces <code>curr</code> on Line 5) and this follows the PECS rules. Now, we can search for a shape in a sequence of circles. <pre><code>A.&lt;Shape&gt;contains(circleSeq, shape);\n</code></pre></p>"},{"location":"26-wildcard.html#revisiting-raw-types","title":"Revisiting Raw Types","text":"<p>In previous units, we said that you may use raw types only in two scenarios. Namely, when using generics and <code>instanceof</code> together, and when creating arrays. However, with unbounded wildcards, we can now see it is possible to remove both of these exceptions. We can now use <code>instanceof</code> in the following way:</p> <pre><code>a instanceof A&lt;?&gt; \n</code></pre> <p>Recall that in the example above, <code>instanceof</code> checks of the runtime type of <code>a</code>.  Previously, we said that we can't check for, say, <pre><code>a instanceof A&lt;String&gt; \n</code></pre></p> <p>since the type argument <code>String</code> is not available during runtime due to erasure.  Using <code>&lt;?&gt;</code> fits the purpose here because it explicitly communicates to the reader of the code that we are checking that <code>a</code> is an instance of <code>A</code> with some unknown (erased) type parameter.</p> <p>Similarly, we can create arrays in the following way: <pre><code>new Comparable&lt;?&gt;[10];\n</code></pre></p> <p>Previously, we said that we could not create an array using the expression <code>new Comparable&lt;String&gt;[10]</code> because generics and arrays do not mix well.  Java insists that the array creation expression uses a reifiable type, i.e., a type where no type information is lost during compilation.  Unlike <code>Comparable&lt;String&gt;</code>, however, <code>Comparable&lt;?&gt;</code> is reifiable.  Since we don't know what is the type of <code>?</code>, no type information is lost during erasure!</p> <p>Going forward now in the course, we will not permit the use of raw types in any scenario.  Every historical justification for raw types now has a wildcard alternative.</p>"},{"location":"27-inference.html","title":"Unit 27: Type Inference","text":"<p>Learning Objectives</p> <p>After this unit, students should be able to:</p> <ul> <li>explain what type inference is and why Java supports it for generic methods and types</li> <li>identify the sources of type constraints (method arguments, bounds, and target typing) used during inference</li> <li>manually derive the inferred type arguments in common generic method calls</li> <li>recognize situations where type inference leads to surprising or unsafe behaviour</li> <li>diagnose and explain compilation errors caused by incompatible inference bounds</li> </ul> <p>Overview</p> <p>In earlier units, we saw how Java\u2019s type system helps prevent many classes of runtime errors by enforcing type correctness at compile time. We also learned that generic types and wildcards allow us to write flexible and reusable code\u2014but often at the cost of additional type annotations.</p> <p>To reduce verbosity, Java allows programmers to omit some type arguments and rely on the compiler to infer them automatically. This process, known as type inference, attempts to determine which type arguments would make the program type-correct.</p> <p>While type inference can make code shorter and easier to read, it is not merely a convenience feature. It follows precise rules based on subtyping, bounds, and target types\u2014and these rules can sometimes lead to results that surprise even experienced programmers.</p> <p>In this unit, we study how Java infers type arguments for generic methods and types, how these inferences are derived from constraints, and why understanding the inference process is essential for writing safe and predictable generic code.</p>"},{"location":"27-inference.html#diamond-operator","title":"Diamond Operator","text":"<p>One example of type inference is the diamond operator <code>&lt;&gt;</code> when we <code>new</code> an instance of a generic type: <pre><code>Pair&lt;String,Integer&gt; p = new Pair&lt;&gt;();\n</code></pre></p> <p>Java can infer that <code>p</code> should be an instance of <code>Pair&lt;String,Integer&gt;</code> since the compile-time type of <code>p</code> is <code>Pair&lt;String,Integer&gt;</code>.  The line above is equivalent to: <pre><code>Pair&lt;String,Integer&gt; p = new Pair&lt;String,Integer&gt;();\n</code></pre></p>"},{"location":"27-inference.html#type-inferencing","title":"Type Inferencing","text":"<p>We have been invoking  contains v0.7 (with wild cards)<pre><code>class A {\n  public static &lt;S&gt; boolean contains(Seq&lt;? extends S&gt; seq, S obj) {\n    for (int i = 0; i &lt; seq.getLength(); i++) {\n      S curr = seq.get(i);\n      if (curr.equals(obj)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n</code></pre></p> <p>by explicitly passing in the type argument <code>Shape</code> (also called type witness in the context of type inference). <pre><code>     A.&lt;Shape&gt;contains(circleSeq, shape);\n</code></pre></p> <p>We could remove the type argument <code>&lt;Shape&gt;</code> so that we can call <code>contains</code> just like a non-generic method: <pre><code>     A.contains(circleSeq, shape);\n</code></pre></p> <p>and Java could still infer that <code>S</code> should be <code>Shape</code>.  The type inference process looks for all possible types that match.  In this example, the type of the two arguments must match.  Let's consider each individually first:</p> <ul> <li>An object of type <code>Shape</code> is passed as an argument to the parameter <code>obj</code>.  So <code>S</code> might be <code>Shape</code> or, if widening type conversion has occurred, one of the other supertypes of <code>Shape</code>. Therefore, <code>Shape &lt;: S &lt;: Object</code>.</li> <li>A <code>Seq&lt;Circle&gt;</code> has been passed into <code>Seq&lt;? extends S&gt;</code>.  A widening type conversion occurred here, so we need to find all possible <code>S</code> such that <code>Seq&lt;Circle&gt;</code> &lt;: <code>Seq&lt;? extends S&gt;</code>.  This is true only if <code>S</code> is <code>Circle</code>, or another supertype of <code>Circle</code>. Therefore, <code>Circle &lt;: S &lt;: Object</code>.</li> </ul> <p>Solving for these two constraints on <code>S</code>, we get the following: <pre><code>Shape &lt;: S &lt;: Object \n</code></pre></p> <p>Therefore, <code>S</code> could be <code>Shape</code> or one of its supertypes: <code>GetAreable</code> and <code>Object</code>.   We choose the lower bound, so <code>S</code> is inferred to be <code>Shape</code>.</p> <p>Type inference can have unexpected consequences.  Let's consider an older version of <code>contains</code> that we wrote:</p> contains v0.4 (with generics)<pre><code>class A {\n  public static &lt;T&gt; boolean contains(T[] array, T obj) {\n    for (T curr : array) {\n      if (curr.equals(obj)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n</code></pre> <p>Recall that we want to prevent nonsensical calls where we are searching for an integer in an array of strings. <pre><code>String[] strArray = new String[] { \"hello\", \"world\" };\nA.&lt;String&gt;contains(strArray, 123); // type mismatch error\n</code></pre></p> <p>But, if we write: <pre><code>A.contains(strArray, 123); // ok!  (huh?)\n</code></pre></p> <p>The code compiles!  Let's go through the type inference steps to understand what happened.  Again, we have two parameters:</p> <ul> <li><code>strArray</code> has the type <code>String[]</code> and is passed to <code>T[]</code>.  So <code>T</code> must be <code>String</code> or its superclass <code>Object</code> (i.e. <code>String &lt;: T &lt;: Object</code>).  The latter is possible since Java array is covariant.</li> <li><code>123</code> is passed as type <code>T</code>.  The value is treated as <code>Integer</code> and, therefore, <code>T</code> must be either <code>Integer</code>,  or its superclasses <code>Number</code>, and <code>Object</code> (i.e. <code>Integer &lt;: T &lt;: Object</code>). </li> </ul> <p>Solving for these two constraints: <pre><code>T &lt;: Object\n</code></pre> The most specific type that <code>T</code> can be is <code>Object</code>, so Java infers <code>T</code> to be <code>Object</code>.  The code above is equivalent to:</p> <pre><code>A.&lt;Object&gt;contains(strArray, 123);\n</code></pre> <p>And our version 0.4 of <code>contains</code> actually is quite fragile and does not work as intended.  We were bitten again by the fact that the Java array is covariant.</p> <p>Type inference does not guarantee that the inferred type matches the programmer's intention. When multiple types satisfy the constraints, Java chooses the most general one that satisfies all bounds, even if that makes the method semantically meaningless.  Explicit type witnesses override inference and can be used to document intent or avoid surprising inferences. However, they do not bypass type checking, only inference.</p>"},{"location":"27-inference.html#target-typing","title":"Target Typing","text":"<p>The example above performs type inference on the parameters of the generic methods.  Type inference can involve the type of the expression as well.  This is known as target typing.  Take the following upgraded version of <code>findLargest</code>:</p> findLargest v0.6 (with Seq&lt;T&gt;)<pre><code>public static &lt;T extends GetAreable&gt; T findLargest(Seq&lt;? extends T&gt; seq) {\n  double maxArea = 0;\n  T maxObj = null;\n  for (int i = 0; i &lt; seq.getLength(); i++) {\n    T curr = seq.get(i);\n    double area = curr.getArea();\n    if (area &gt; maxArea) {\n      maxArea = area;\n      maxObj = curr;\n    }\n  }\n  return maxObj;\n}\n</code></pre> <p>and we call <pre><code>Shape o = A.findLargest(new Seq&lt;Circle&gt;(0));\n</code></pre></p> <p>We have a few more constraints to check:</p> <ul> <li>Due to target typing, the return type of <code>T</code> must be a subtype of <code>Shape</code> (i.e. <code>T &lt;: Shape</code>)</li> <li>Due to the bound of the type parameter, <code>T</code> must be a subtype of <code>GetAreable</code> (i.e. <code>T &lt;: GetAreable</code>)</li> <li>Due to argument typing, <code>Seq&lt;Circle&gt;</code> must be a subtype of <code>Seq&lt;? extends T&gt;</code>, so <code>T</code> must be a supertype of <code>Circle</code> (i.e. <code>Circle &lt;: T &lt;: Object</code>)</li> </ul> <p>Solving for all three of these constraints: <pre><code>Circle &lt;: T &lt;: Shape\n</code></pre></p> <p>The lower bound is <code>Circle</code>, so the call above is equivalent to: <pre><code>Shape o = A.&lt;Circle&gt;findLargest(new Seq&lt;Circle&gt;(0));\n</code></pre></p>"},{"location":"27-inference.html#further-type-inference-examples","title":"Further Type Inference Examples","text":"<p>We now return to our <code>Circle</code> and <code>ColoredCircle</code> classes and the <code>GetAreable</code> interface. Recall that <code>Circle</code> implements <code>GetAreable</code> and <code>ColoredCircle</code> inherits from <code>Circle</code>.</p> <p>Consider the following method signature of a generic method <code>foo</code>:</p> <pre><code>public &lt;T extends Circle&gt; T foo(Seq&lt;? extends T&gt; seq)\n</code></pre> <p>Then we consider the following code excerpt:</p> <pre><code>ColoredCircle c = foo(new Seq&lt;GetAreable&gt;());\n</code></pre> <p>What does the java compiler infer <code>T</code> to be? Let's look at all of the constraints on <code>T</code>.</p> <ul> <li> <p>First, the return type of <code>foo</code> must be a subtype of <code>ColoredCircle</code>, therefore <code>T &lt;: ColoredCircle</code>.</p> </li> <li> <p><code>T</code> is also a bounded type parameter, therefore <code>T &lt;: Circle</code>.</p> </li> <li> <p>Our method argument is of type <code>Seq&lt;GetAreable&gt;</code> and must be a subtype of <code>Seq&lt;? extends T&gt;</code>, so <code>T</code> must be a supertype of <code>GetAreable</code> (i.e. <code>GetAreable &lt;: T &lt;: Object</code>).</p> </li> </ul> <p>We can see that there is no solution to our contraints, <code>T</code> can not be both a subtype of <code>ColoredCircle</code> and a supertype of <code>GetAreable</code> and therefore the Java compiler can not find a type <code>T</code>. The Java compiler will throw an error stating the inference variable <code>T</code> has incompatible bounds.</p> <p>Lets consider, one final example using the following method signature of a generic method <code>bar</code>:</p> <pre><code>public &lt;T extends Circle&gt; T bar(Seq&lt;? super T&gt; seq)\n</code></pre> <p>Then we consider the following code excerpt:</p> <pre><code>GetAreable c = bar(new Seq&lt;Circle&gt;());\n</code></pre> <p>What does the java compiler infer <code>T</code> to be? Again, lets look at all of the constraints on <code>T</code>.</p> <ul> <li> <p>We can say that the return type of <code>bar</code> must be a subtype of <code>GetAreable</code>, therefore <code>T &lt;: GetAreable</code>.</p> </li> <li> <p>Our method argument is of type <code>Seq&lt;Circle&gt;</code> and must be a subtype of <code>Seq&lt;? super T&gt;</code>, so <code>T</code> must be a subtype of <code>Circle</code> (i.e. <code>T &lt;: Circle</code>).</p> </li> </ul> <p>Solving for these two constraints: <pre><code>T &lt;: Circle\n</code></pre></p> <p>Whilst <code>ColoredCircle</code> is also a subtype of <code>Circle</code> it is not included in the above statement and therefore the compiler does not consider this class during type inference. Indeed, the compiler cannot be aware<sup>1</sup> of all subtypes of <code>Circle</code> and there could be more than one subtype. Therefore <code>T</code> can only have the type <code>Circle</code>, so Java infers <code>T</code> to be <code>Circle</code>. </p>"},{"location":"27-inference.html#rules-for-type-inference","title":"Rules for Type Inference","text":"<p>We now summarize the steps for type inference. First, we figure out all of the type constraints on our type parameters, and then we solve these constraints. If no type can satisfy all the constraints, Java will fail to compile. If in resolving the type constraints for a given type parameter <code>T</code> we are left with:</p> <ul> <li><code>Type1 &lt;: T &lt;: Type2</code>, then <code>T</code> is inferred as <code>Type1</code></li> <li><code>Type1 &lt;: T</code><sup>2</sup>, then <code>T</code> is inferred as <code>Type1</code></li> <li><code>T &lt;: Type2</code>, then <code>T</code> is inferred as <code>Type2</code></li> </ul> <p>where <code>Type1</code> and <code>Type2</code> are arbitrary types. Java prefers the lower bound when both bounds are present, as it leads to more specific types and better type safety.  If only one bound is present, Java uses that bound to infer the type.</p> <p>Fresh Type Variables and Captured Wildcards</p> <p>In more complex scenarios, Java may introduce fresh type variables or capture wildcards during type inference to handle cases where the exact type cannot be determined directly. These mechanisms allow Java to maintain type safety while still providing flexibility in generic programming. However, these topics are beyond the scope of this unit and will be covered in more advanced discussions on Java's type system.</p> <ol> <li> <p>Due to evolving specifications of software, at the time of compilation, a subtype may not have even been conceived of or written yet!\u00a0\u21a9</p> </li> <li> <p>Note that <code>T &lt;: Object</code> is implicit here. We can see that this case could also be written as <code>Type1 &lt;: T &lt;: Object</code>, and would therefore also be explained by the previous case (<code>Type1 &lt;: T &lt;: Type2</code>).\u00a0\u21a9</p> </li> </ol>"},{"location":"28-immutability.html","title":"Unit 28: Immutability","text":"<p>Learning Objectives</p> <p>After completing this unit, students should be able to:</p> <ul> <li>Explain immutability as a design principle and articulate how it reduces bugs arising from aliasing, mutation, and unintended side effects. </li> <li>Design and implement immutable classes in Java, including the correct use of <code>final</code>, factory methods, and copy-on-write semantics.</li> <li>Distinguish between <code>final</code> and true immutability, and identify common pitfalls where <code>final</code> fields do not guarantee immutability.</li> <li>Reason about safe sharing of objects and internal representations, including when and why structural sharing is correct and efficient.</li> <li>Recognize the role of immutability in program reasoning and concurrency, and explain why immutable objects are inherently thread-safe.</li> </ul> <p>Overview</p> <p>In earlier units, we saw how abstraction, typing, and reuse help manage software complexity. In this unit, we introduce another powerful strategy: avoiding change.</p> <p>Many subtle bugs arise from mutation, especially when objects are aliased and updated through multiple references. When an object can change over time, reasoning about program behaviour becomes significantly harder.</p> <p>Immutability avoids this problem by ensuring that an object\u2019s observable state never changes after creation<sup>1</sup>. Updates instead produce new objects, eliminating aliasing bugs and enabling safe sharing without defensive copying.</p>"},{"location":"28-immutability.html#avoiding-change","title":"Avoiding Change","text":"<p>Another useful strategy to reduce bugs when code complexity increases is to avoid change altogether.  This can be done by making our classes immutable. We create an instance of an immutable class, the instance cannot have any observable changes outside its abstraction barrier.  This means that every call to the instance's method must behave the same way throughout the lifetime of the instance.  An object can be logically immutable even if it mutates private, unobservable state, as long as its externally visible behaviour remains unchanged.</p> <p>There are many advantages to making classes immutable when possible.  To start, let's revisit a common bug due to aliasing.  Recall the following example from Unit 9,  where we create two circles <code>c1</code> and <code>c2</code> centered at the origin (0, 0). <pre><code>Point p = new Point(0, 0);\nCircle c1 = new Circle(p, 1);\nCircle c2 = new Circle(p, 4);\n</code></pre></p> <p>Let's say that we have the <code>moveTo</code> method in both <code>Circle</code> and <code>Point</code>, to move the circle and point respectively.</p> Mutable Point and Circle<pre><code>class Point {\n  private double x;\n  private double y;\n    :\n  public void moveTo(double x, double y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nclass Circle {\n  private Point c;\n  private double r;\n\n  public Circle (Point c, double r) {\n    this.c = c;\n    this.r = r;\n  }\n    :\n\n  public void moveTo(double x, double y) {\n    c.moveTo(x, y);\n  }\n}\n</code></pre> <p>Suppose we want to move <code>c1</code> and only <code>c1</code> to be centered at (1,1).</p> <pre><code>c1.moveTo(1, 1);\n</code></pre> <p>The line of code above surprisingly moved the center of both <code>c1</code> and <code>c2</code>, due to both circles <code>c1</code> and <code>c2</code> sharing the same point.  We have explored a solution below:</p> <pre><code>Point p1 = new Point(0, 0);\nCircle c1 = new Circle(p1, 1);\n\nPoint p2 = new Point(0, 0);\nCircle c2 = new Circle(p2, 4);\n\nc1.moveTo(1, 1);\n</code></pre> <p>This approach avoids sharing references by creating separate copies of the points so that no two references point to the same instance, avoiding aliasing altogether.  This partial fix, however, comes with extra costs in computational resources as the number of objects may proliferate.</p> <p>This is also not a complete solution because we can still move <code>c2</code> without calling <code>c2.moveTo(1, 1)</code> but by calling the code below.</p> <pre><code>p2.moveTo(1, 1);\n</code></pre> <p>Let's now see how immutability can help us resolve our problem.</p>"},{"location":"28-immutability.html#immutable-points-and-circles","title":"Immutable Points and Circles","text":"<p>Let's start by making our <code>Point</code> class immutable.  We start by making the fields <code>final</code> to signal our intention that we do not intend to assign another value to them.  Now that the <code>x</code> and <code>y</code> cannot be re-assigned (a new value or even the same value), to move a point, we shouldn't re-assign to the fields <code>x</code> and <code>y</code> anymore.  Instead, we return a new <code>Point</code> instance to prevent mutating the current instance, as follows:</p> Immutable Point<pre><code>final class Point {\n  private final double x;\n  private final double y;\n\n  public Point(double x, double y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  public Point moveTo(double x, double y) {\n    return new Point(x, y);\n  }\n    :\n\n  @Override\n  public String toString() {\n    return \"(\" + this.x + \",\" + this.y + \")\";\n  }\n}\n</code></pre> <p>Note that, to prevent subclasses from overriding methods in a way that breaks immutability, it is recommended that we declare immutable classes as as <code>final</code> to disallow inheritance.</p> <p>Now, let's make <code>Circle</code> immutable:</p> Immutable Circle<pre><code>final class Circle {\n  private final Point c;\n  private final double r;\n\n  public Circle (Point c, double r) {\n    this.c = c;\n    this.r = r;\n  }\n    :\n\n  public Circle moveTo(double x, double y) {\n    return new Circle(c.moveTo(x, y), r);\n  }\n}\n</code></pre> <p>With both <code>Point</code> and <code>Circle</code> immutable, we can be sure that once an instance is created, it remains unchanged (outside the abstraction barrier):</p> <pre><code>Point p = new Point(0, 0);\nCircle c1 = new Circle(p, 1);\nCircle c2 = new Circle(p, 4);\nc1.moveTo(1, 1); // c1 remains unchanged\n</code></pre> <p>To update the variable <code>c1</code>, we need to explicitly reassign it.</p> <pre><code>c1 = c1.moveTo(1, 1);\n</code></pre> <p>Now, <code>c1</code> moves to a new location, but <code>c2</code> remains unchanged.</p> <p>Compare our new immutable approach to the two approaches above. The first shares all the references and is bug-prone.  The second creates a new copy of the instance every time and is resource-intensive.  Our third approach, using immutable classes, allows us to share all the references until we need to modify the instance, in which case we make a copy.  Such a copy-on-write semantic allows us to avoid aliasing bugs without creating excessive copies of objects.</p> <p>Note that the <code>final</code> keyword prevents assigning new values to the field.  Unfortunately, it does not prevent the field from being mutated.  So, to ensure that the classes we create are immutable, we have to ensure that the fields are themselves immutable.</p>"},{"location":"28-immutability.html#advantages-of-being-immutable","title":"Advantages of Being Immutable","text":"<p>We have seen how making our classes immutable helps us remove the risk of potential bugs when we use composition and aliasing.  Immutability has other advantages as well.  </p>"},{"location":"28-immutability.html#ease-of-understanding","title":"Ease of Understanding","text":"<p>Code written with immutable objects is easier to reason with and easier to understand.  Suppose we create a <code>Circle</code> and assign it to a local variable:</p> <pre><code>Circle c = new Circle(new Point(0, 0), 8);\n</code></pre> <p>We pass <code>c</code> around to many other methods.  These other methods may invoke <code>c</code>'s methods; we may invoke <code>c</code>'s methods locally as well.  But, despite putting <code>c</code> through so much, unless we have explicitly re-assigned <code>c</code>, we can guarantee that <code>c</code> is still a circle centered at (0,0) with a radius of 8.  This immutable property makes it significantly easier to read, understand, and debug our code.</p> <p>Without this property, we have to trace through all the methods that we pass <code>c</code> to, and each call of <code>c</code>'s methods to make sure that none of these codes modifies <code>c</code>.</p>"},{"location":"28-immutability.html#enabling-safe-sharing-of-objects","title":"Enabling Safe Sharing of Objects","text":"<p>Making a class immutable allows us to safely share instances of the class, therefore reducing the need to create multiple copies of the same object.  For instance, the origin (0, 0) is commonly used.  If the instance is immutable, we can just create and cache a single copy of the origin, and always return this copy when the origin is required.</p> <p>Let's modify our <code>Point</code> class so that it creates a single copy of the origin and returns the same copy every time the origin is required.</p> Immutable Point with shared ORIGIN<pre><code>final class Point {\n  private final double x;\n  private final double y;\n  private final static Point ORIGIN = new Point(0, 0);\n\n  private Point(double x, double y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  public static Point of(double x, double y) {\n    if (x == 0 &amp;&amp; y == 0) {\n      return ORIGIN;\n    }\n    return new Point(x, y);\n  }\n\n  // other methosd omitted\n}\n</code></pre> <p>We made a few changes in the above:</p> <ul> <li>We made the constructor for <code>Point</code> private so that one cannot call the constructor directly.</li> <li>We provide a class factory method named <code>of</code> for the client to create a <code>Point</code> instance.  The <code>of</code> method returns the same instance <code>ORIGIN</code> every time <code>Point.of(0, 0)</code> is called.</li> </ul> <p>Such a design pattern is only safe when the class is immutable.  Consider the mutable version of <code>Point</code> \u2014 calling <code>Point.of(0, 0).moveTo(1, 1)</code> would change every reference to the origin to (1, 1), causing chaos in the code!</p>"},{"location":"28-immutability.html#enabling-safe-sharing-of-internals","title":"Enabling Safe Sharing of Internals","text":"<p>Immutable instances can also share their internals freely.  Consider an immutable implementation of our <code>Seq&lt;T&gt;</code>, called <code>ImmutableSeq&lt;T&gt;</code>.  Let's start with a simple version first.</p> ImmutableSeq&lt;T&gt; v0.1<pre><code>final class ImmutableSeq&lt;T&gt; {\n  private final T[] array;\n\n  // Only items of type T goes into the array.\n  @SafeVarargs\n  public static &lt;T&gt; ImmutableSeq&lt;T&gt; of(T... items) {\n    // We need to copy to ensure that it is truly immutable\n    @SuppressWarnings(\"unchecked\");\n    T[] arr = (T[]) new Object[items.length];\n    for (int i = 0; i &lt; items.length; i++) {\n      arr[i] = items[i];\n    }\n    return new ImmutableSeq&lt;&gt;(arr);\n  }\n\n  private ImmutableSeq(T[] a) {\n    this.array = a;\n  }\n\n  public T get(int index) {\n    return this.array[index];\n  }\n}\n</code></pre> <p>There are a few things to note here.</p> <p>Varargs The parameter to the class factory method <code>of</code> has the form <code>T... items</code>.  The triple <code>.</code> notation is a Java syntax for a variable number of arguments of the same type (<code>T</code>).  Often called varargs, this is just syntactic sugar for passing in an array of items to a method.  The method is called variadic method.  We can then call <code>of</code> with a variable number of arguments, such as:</p> <pre><code>ImmutableSeq&lt;Integer&gt; a;\na = ImmutableSeq.of();\na = ImmutableSeq.of(1, 2, 3);\na = ImmutableSeq.of(1, 2, 3, 4, 5);\n</code></pre> <p>@SafeVarargs. \u00a0 Since the varargs is implemented as an array, and array and generics do not mix well in Java, the compiler would throw us an unchecked warning.  In this instance, however, we know that our code is safe because we never put anything other than items of type <code>T</code> into the array.  We can use the <code>@SafeVarargs</code> annotation to tell the compiler that we know what we are doing and this varargs is safe.</p> <p>Notice that we removed the <code>set</code> method and there is no other way an external client can modify the array once it is created.  This, of course, assumes that we will only be inserting an immutable object into our immutable array.  Unfortunately, this cannot be enforced by the compiler as the generic type <code>T</code> can be anything.</p> <p>Now, suppose that we wish to support a <code>subarray</code> method, that returns a new array containing only a range of elements in the original array.  It behaves as follows:</p> <pre><code>ImmutableSeq&lt;Integer&gt; a = ImmutableSeq.of(10, 20, 30, 40, 50, 60);\nImmutableSeq&lt;Integer&gt; b = a.subarray(2, 4); // b is [30, 40, 50]\nb.get(0) // returns 30\nImmutableSeq&lt;Integer&gt; c = b.subarray(1, 2); // c is [40, 50]\nc.get(1) // returns 50\n</code></pre> <p>A typical way to implement <code>subarray</code> is to allocate a new <code>T[]</code> and copy the elements over.  This operation can be expensive if our <code>ImmutableSeq</code> has millions of elements.  But, since our class is immutable and the internal field <code>array</code> is guaranteed not to mutate, we can safely let <code>b</code> and <code>c</code> refer to the same <code>array</code> from <code>a</code>, and only store the starting and ending index.</p> ImmutableSeq&lt;T&gt; v0.2 (with sharing)<pre><code>class ImmutableSeq&lt;T&gt; {\n  private final int start;\n  private final int end;\n  private final T[] array;\n\n  @SafeVarargs\n  public static &lt;T&gt; ImmutableSeq&lt;T&gt; of(T... items) {\n    // We need to copy to ensure that it is truly immutable\n    @SuppressWarnings(\"unchecked\");\n    T[] arr = (T[]) new Object[items.length];\n    for (int i = 0; i &lt; items.length; i++) {\n      arr[i] = items[i];\n    }\n    return new ImmutableSeq&lt;&gt;(arr, 0, items.length - 1);\n  }\n\n  private ImmutableSeq(T[] a, int start, int end) {\n    this.start = start;\n    this.end = end;\n    this.array = a;\n  }\n\n  public T get(int index) {\n    if (index &lt; this.start || this.start + index &gt; this.end) {\n      throw new IllegalArgumentException(\"Index out of bounds\");\n    }\n    return this.array[this.start + index];\n  }\n\n  public ImmutableSeq&lt;T&gt; subarray(int start, int end) {\n     return new ImmutableSeq&lt;&gt;(this.array, this.start + start, this.start + end);\n  }\n}\n</code></pre>"},{"location":"28-immutability.html#enabling-safe-concurrent-execution","title":"Enabling Safe Concurrent Execution","text":"<p>We will explore concurrent execution of code towards the end of the course, but making our classes immutable goes a long way in reducing bugs related to concurrent execution.  Without going into details (you will learn this later), concurrent programming allows multiple threads of code to run in an interleaved fashion, in an arbitrary interleaving order.   If we have complex code that is difficult to debug to begin with, imagine having code where we have to ensure its correctness regardless of how the execution interleaves!  Immutability helps us ensure that regardless of how the code interleaves, our objects remain unchanged.</p>"},{"location":"28-immutability.html#final-immutable","title":"Final \u2260 Immutable","text":"<p>When creating an immutable class, we need to be careful to distinguish between the keywords that help us avoid accidentally making things easily mutable and the actual concept of an immutable class.  For instance, it is insufficient to simply declare all fields with <code>final</code> keywords.  Just because we cannot accidentally update the field, does not mean that the field is immutable.  Consider the same <code>Circle</code> above but with a getter for the center point and now imagine that the <code>Point</code> is mutable.</p> Circle with Mutable Point<pre><code>final class Circle {\n  private final Point c;\n  private final double r;\n\n  public Circle (Point c, double r) {\n    this.c = c;\n    this.r = r;\n  }\n    :\n\n  public Point getCenter() {\n    return this.c;\n  }\n\n  public Circle moveTo(double x, double y) {\n    return new Circle(c.moveTo(x, y), r);\n  }\n}\n</code></pre> <p>We can then simply retrieve the center point and mutate it externally.</p> <pre><code>Circle c = new Circle(new Point(0, 0), 1);\nc.getCenter().moveTo(1, 1); // assume mutable Point\n</code></pre> <p>On the other hand, it is not even necessary to use the <code>final</code> keyword to make an immutable class.  We simply have to have a class that prevents any and all kinds of sharing by copying all the parameters before assigning them to the fields and copying all return values.  Assume that all classes have a correctly implemented <code>clone()</code> method.  Then the following <code>Circle</code> is immutable even with a getter and no <code>final</code> keyword on the fields.  We still need the <code>final</code> keyword on the class to disallow inheritance.</p> Immutable Circle with Cloning<pre><code>final class Circle {\n  private Point c;\n  private double r;\n\n  public Circle (Point c, double r) {\n    this.c = c.clone();\n    this.r = r; // primitive, no need cloning\n  }\n    :\n\n  public Point getCenter() {\n    return this.c.clone();\n  }\n\n  public Circle moveTo(double x, double y) {\n    return new Circle(c.moveTo(x, y), r);\n  }\n}\n</code></pre> <p>That does not mean that the <code>final</code> keyword is not important.  It helps accidental re-assignment and in some cases, that is sufficient especially if the fields are of primitive type.  Once we have created one immutable class, we can then create other larger immutable classes by only using immutable classes as fields.</p>"},{"location":"28-immutability.html#performance-trade-offs-of-immutability","title":"Performance Trade-offs of Immutability","text":"<p>While immutability offers significant benefits in correctness, reasoning, and safety, it is not without cost. Because immutable objects cannot be modified in place, updates typically require creating new objects, which may increase memory allocation and garbage collection overhead.</p> <p>In performance-critical code, such as tight loops, low-level data processing, or numerical computations, this additional allocation can be expensive compared to mutating an existing object. You have seen an example of this issue when we discussed wrapper classes, which are immutable.  </p> <p>In such cases, a carefully designed mutable implementation may be more efficient.  Hence, immutability should be viewed as a design trade-off, not a universal rule.  When correctness, simplicity, and safe sharing are priorities, immutability is often the better choice. When performance is critical and mutation can be tightly controlled within a well-defined abstraction barrier, mutability may be justified.</p> <p>In practice, many systems combine both approaches: using mutable objects internally for efficiency, while exposing immutable interfaces to clients.</p> <ol> <li> <p>Note that this is a looser definition than some other definitions of immutability.  Java tutorial, for instance, defines immutability as preventing any change to the object, including private state.  Our definition allows private state to change as long as the observable behaviour remains unchanged.</p> <p>In this unit, we learn how to design immutable classes in Java and why immutability is a key tool for writing simpler, safer, and more robust programs.\u00a0\u21a9</p> </li> </ol>"},{"location":"29-nested-classes.html","title":"Unit 29: Nested Class","text":"<p>Learning Objectives</p> <p>After completing this unit, students should be able to:</p> <ul> <li>Explain why and when nested classes are used, particularly for encapsulation, information hiding, and logical grouping of tightly coupled classes.</li> <li>Differentiate between the kinds of nested classes in Java (static nested classes, inner classes, local classes, and anonymous classes), including their scoping rules and access to enclosing members.</li> <li>Reason about access control and abstraction barriers when exposing or hiding nested classes, and understand how this affects clients of a class.</li> <li>Apply qualified this correctly to disambiguate between enclosing instances in inner classes.</li> <li>Explain and predict variable capture behavior, including the notion of effectively final variables and its implications for program correctness.</li> <li>Write and use local and anonymous classes appropriately, especially for single-use behaviors such as custom comparators.</li> </ul> <p>Overview</p> <p>As programs grow is size, a class often requires several helper classes that exist solely to support its internal implementation. Declaring these helpers as top-level classes can clutter the namespace and expose unnecessary implementation details to clients.</p> <p>Java allows classes to be defined within other classes or even within methods. These nested classes let us group tightly coupled components together, keep helper classes within the abstraction barrier, and express design intent more clearly. Nested classes also interact closely with Java\u2019s access control, static and instance contexts, and scoping rules.</p> <p>In this unit, we examine the different kinds of nested classes in Java and the rules that govern their access to enclosing state, including variable capture and the requirement for effectively final variables. Understanding these mechanisms will help you write better-encapsulated code and understand common patterns used in Java libraries.</p>"},{"location":"29-nested-classes.html#nested-class","title":"Nested Class","text":"<p>A nested class is a class defined within an enclosing class.  For example, the following declaration declares a private nested class named <code>B</code> within the class <code>A</code>.</p> <pre><code>class A {\n  private class B {\n      :\n  }\n}\n</code></pre> <p>Nested classes are used to group logically relevant classes together.  Typically, a nested class is tightly coupled with the enclosing class and would have no use outside of the enclosing class.  Nested classes can be used to encapsulate implementation details within an enclosing class, for instance, when the implementation of the enclosing class becomes too complex.  As such, they are useful for \"helper\" classes that serve specific purposes.</p> <p>A nested class is a field of the enclosing class and can access its fields and methods, including those declared as <code>private</code>.  We can keep the nested class within the abstraction barrier by declaring the nested class as <code>private</code> if there is no need for it to be exposed to the client outside the barrier.  </p> <p>Since the nested class can access the private fields of the enclosing class, we should introduce a nested class only if the nested class belongs to the same encapsulation as the enclosing class.  Otherwise, the enclosing class would leak its implementation details to the nested class.</p> <p>Take the <code>HashMap&lt;K,V&gt;</code> class for instance.  The implementation of <code>HashMap&lt;K,V&gt;</code> contains several nested classes, including <code>HashIterator</code>, which implement an <code>Iterator&lt;E&gt;</code> interface for iterating through the key and value pairs in the map, and an <code>Entry&lt;K,V&gt;</code> class, which encapsulates a key-value pair in the map.  Some of these classes are declared <code>private</code>, as they are only used within the <code>HashMap&lt;K,V&gt;</code> class.</p> <p>Example from CS2030S This Semester</p> <p>We can take another example from your programming exercise on bank simulation.  In one of many possible designs, the subclasses of <code>Event</code>: <code>ArrivalEvent</code>, <code>DepartureEvent</code>, etc. are not used anywhere outside of <code>BankSimulation</code>.  They can be safely encapsulated within <code>BankSimulation</code> as inner classes, so that these classes can access the fields within the <code>BankSimulation</code> class, simplifying their implementation.</p> <p>A nested class can be either static or non-static.  Just like static fields and static methods, a static nested class is associated with the enclosing class, NOT an instance.  So, it can only access static fields and static methods of the enclosing class.  A non-static nested class, on the other hand, carries implicitly a reference to the enclosing object<sup>1</sup> and can access all fields and methods of the enclosing instance.  A non-static nested class is also known as an inner class. It cannot be instantiated without an enclosing instance.</p> <p>The example below shows an enclosing class <code>A</code> with two nested classes, a non-static inner class <code>B</code>, and a static nested class <code>C</code>.  <code>B</code> can access instance fields, instance methods, class fields, and class methods in <code>A</code>.  <code>C</code> can only access the class fields and class methods in <code>A</code>.</p> <pre><code>class A {\n  private int x;\n  private static int y;\n\n  private class B {\n    void foo() {\n      x = 1; // accessing x from A is OK\n      y = 1; // accessing y from A is OK\n    }\n  }\n\n  private static class C {\n    void bar() {\n      x = 1; // accessing x from A is not OK since C is static\n      y = 1; // accessing y is OK\n    }\n  }\n}\n</code></pre> <p>Recall that we recommend that all access to instance fields be done through the <code>this</code> reference.  In the example above, however, we can't access <code>this.x</code> from within <code>B</code>.</p> <pre><code>class A {\n private int x;\n\n private class B {\n   void foo() {\n     this.x = 1; // error\n     x = 1; // ok\n   }\n }\n}\n</code></pre> <p>Since <code>this.x</code> is called within a method of <code>B</code>, <code>this</code> would refer to the instance of <code>B</code>, rather than the instance of <code>A</code>.  Java has a piece of syntax called qualified <code>this</code> to resolve this.  A qualified <code>this</code> reference is prefixed with the enclosing class name, to differentiate between the <code>this</code> of the inner class and the <code>this</code> of the enclosing class.  In the example above, we can access <code>x</code> from <code>A</code> through the <code>A.this</code> reference.</p> <pre><code>class A {\n  private int x;\n\n  private class B {\n    void foo() {\n      A.this.x = 1; // ok\n    }\n  }\n}\n</code></pre>"},{"location":"29-nested-classes.html#hiding-nested-classes","title":"Hiding Nested Classes","text":"<p>When we use nested classes for encapsulating the implementation details of the enclosing class, it is better to declare them as <code>private</code> nested classes, so that they are not exposed across the abstract barrier, adhering to the information hiding principle.  For example, consider the following</p> <pre><code>class A {\n  private class B {\n    public void buz() { \n    }\n  }\n  private static class C {\n  }\n}\n</code></pre> <p>We cannot access <code>A.B</code> or <code>A.C</code> </p> <pre><code>A.B b; // compilation error\nA.C c; // compilation error\n</code></pre> <p>Note that it is still possible to expose instances of private nested classes outside the enclosing class.  For example, let's say we have:</p> <pre><code>class A {\n  private class B {\n    public void buz() { \n    }\n  }\n  B foo() {\n    return new B();\n  }\n}\n</code></pre> <p>We are allowed to call <code>A::foo</code> and obtain a reference to an instance of <code>B</code>, as long as the type <code>B</code> is not used directly.</p> <pre><code>A a = new A();\na.foo();         // return an instance of A.B is OK\nA.B b = a.foo(); // still not allowed since the type A.B is private\n</code></pre> <p>Since the type <code>A.B</code> is private to within <code>A</code>, we cannot call methods of <code>B</code> outside of <code>A</code> as well.</p> <pre><code>A a = new A();\na.foo().buz();  // error since `buz` is defined in a private nested class\n</code></pre> <p>When a nested class does not expose implementation details and is an essential part of the methods provided by the class, it is useful to expose the nested classes across the abstraction barrier. For example, Java's <code>Map</code> has a nested type <code>Entry&lt;K, V&gt;</code> that is public.</p> <p>Consider the example below, where <code>A</code> has two public nested classes <code>B</code> and <code>C</code>.</p> <pre><code>class A {\n  public class B {\n    public void buz() { \n    }\n  }\n  public static class C {\n  }\n}\n</code></pre> <p>We can declare variables of type <code>A.B</code> and <code>A.C</code></p> <pre><code>A.B b;  // ok\nA.C c;  // ok\n</code></pre> <p>and initialize them like so</p> <pre><code>A a = new A();\nA.B b = a.new B();\nA.C c = new A.C();\n</code></pre> <p>Note that syntax to create an instance of <code>B</code> is <code>a.new B()</code>, not <code>new a.B()</code>.</p>"},{"location":"29-nested-classes.html#local-class","title":"Local Class","text":"<p>We can also declare a class within a function, just like a local variable.  </p> <p>To motivate this, let's consider how one would use the <code>java.util.Comparator</code> interface.   The <code>Comparator</code> interface allows us to specify how to compare two elements, by implementing this interface with a customized <code>compare()</code> method.  <code>compare(o1,o2)</code> should return 0 if the two elements are equal, a negative integer if o1 is \"less than\" o2, and a positive integer otherwise.</p> <p>Suppose we have a list of strings, and we want to sort them in the order of their length, we can write the following method:</p> sortNames v1 with Local Class<pre><code>void sortNames(List&lt;String&gt; names) {\n\n  class NameComparator implements Comparator&lt;String&gt; {\n    public int compare(String s1, String s2) {\n      return s1.length() - s2.length();\n    }\n  }\n\n  names.sort(new NameComparator());\n}\n</code></pre> <p>This makes the code easier to read since we keep the definition of the class and its usage closer together.</p> <p>Classes like <code>NameComparator</code> that are declared inside a method (or to be more precise, inside a block of code between <code>{</code> and <code>}</code>) is called a local class.  Just like a local variable, a local class is scoped within the method.  Like a nested class, a local class has access to the variables of the enclosing class through the qualified <code>this</code> reference.  Further, it can access the local variables of the enclosing method.</p> <p>For example,</p> <pre><code>class A {\n  int x = 1;\n\n  void f() {\n    int y = 1;\n\n    class B {\n      void g() {\n        x = y; // accessing x and y is OK.\n      }\n    }\n\n    new B().g();\n  }\n}\n</code></pre> <p>Here, <code>B</code> is a local class defined in method <code>f()</code>.  It has access to all the local variables accessible from within <code>f</code>, as well as the fields of its enclosing class.</p>"},{"location":"29-nested-classes.html#variable-capture","title":"Variable Capture","text":"<p>Recall that when a method returns, all local variables of the methods are removed from the stack.  But, an instance of that local class might still exist.  Consider the following example:</p> <pre><code>interface C {\n  void g();\n}\n\nclass A {\n  int x = 1;\n\n  C f() {\n    int y = 1;\n\n    class B implements C {\n      void g() {\n        x = y; // accessing x and y is OK.\n      }\n    }\n\n    B b = new B();\n    return b;\n  }\n}\n</code></pre> <p>Calling <pre><code>A a = new A();\nC b = a.f();\nb.g();\n</code></pre></p> <p>will give us a reference to an object of type <code>B</code> now.  But, if we call <code>b.g()</code>, what is the value of <code>y</code>?</p> <p>For this reason, although a local class can access local variables in the enclosing method, the local class makes a copy of local variables inside itself.  We say that a local class captures the local variables.  Capturing local variables or enclosing instances may extend their lifetime beyond the execution of the method.</p>"},{"location":"29-nested-classes.html#effectively-final","title":"Effectively <code>final</code>","text":"<p>Variable captures can be confusing.  Consider the following code:</p> sortNames v2 with Sorting Order (Won't Compile)<pre><code>void sortNames(List&lt;String&gt; names) {\n  boolean ascendingOrder = true;\n  class NameComparator implements Comparator&lt;String&gt; {\n    public int compare(String s1, String s2) {\n      if (ascendingOrder)\n        return s1.length() - s2.length();\n      else\n        return s2.length() - s1.length();\n    }\n  }\n\n  ascendingOrder = false;\n  names.sort(new NameComparator());\n}\n</code></pre> <p>Will <code>sort</code> sorts in ascending order (i.e., use the value of <code>ascendingOrder</code> when the class is declared) or descending order (i.e., use the value of <code>ascendingOrder</code> when the class is instantiated)?</p> <p>To avoid such confusion, Java only allows a local class to access variables that are explicitly declared <code>final</code> or implicitly final (or effectively final).  An effectively final variable is a variable that is assigned only once, even if the <code>final</code> keyword is not used.  Therefore, Java saves us from such a hair-pulling situation and disallows such code \u2014 <code>ascendingOrder</code> is not effectively final so the code above does not compile.</p> <p>Breaking the Limitation of Effectively <code>final</code>. \u00a0\u00a0 The limitation of effectively final only happens because the value is of a primitive type.  So, if we capture the value and forbid re-assigning the value, there is nothing we can do to change the primitive value.</p> <p>On the other hand, reference types can be mutated. So if we use our own implementation of <code>Bool</code> class below instead of <code>boolean</code> primitive type, we can modify the code above to allow the \"value\" in variable <code>ascendingOrder</code> to be changed. However, this change is via mutation and not re-assignment to the variable.</p> sortNames v3 with Mutable Wrapper<pre><code>void sortNames(List&lt;String&gt; names) {\n  Bool ascendingOrder = new Bool(true);\n  class NameComparator implements Comparator&lt;String&gt; {\n    public int compare(String s1, String s2) {\n      if (ascendingOrder.val)\n        return s1.length() - s2.length();\n      else\n        return s2.length() - s1.length();\n    }\n  }\n\n  ascendingOrder.val = false;\n  names.sort(new NameComparator());\n}\n\nclass Bool {\n  boolean val;\n}\n</code></pre> <p>The code above compiles correctly now.  But, as a result, the behavior of the code is not as intuitive as before.  So please exercise this workaround with extreme caution.</p> <p>Variable Capture in JavaScript</p> <p>Those of you who did CS1101S or are otherwise familiar with JavaScript might want to note that this is different from JavaScript, which does not enforce the final/effectively final restriction in variable captures.  This is because there is no concept of primitive value in JavaScript.</p> <p>Every single primitive type is automatically boxed in JavaScript. The unboxed variant is not available to the programmer directly.  So, if we write <code>x = 1</code> in JavaScript, the value <code>1</code> is boxed and put into the heap.  Then, the variable <code>x</code> in the stack points to this box in the heap, unlike Java primitive type.</p>"},{"location":"29-nested-classes.html#anonymous-class","title":"Anonymous Class","text":"<p>An anonymous class is one where you declare a local class and instantiate it in a single statement.  This is syntactic sugar to allow programmers to declare quickly a \"single-use\" class -- a class that we use only once and never need again.  We don't even need to give the class a name (hence, anonymous).</p> <pre><code>names.sort(new Comparator&lt;String&gt;() {\n  public int compare(String s1, String s2) {\n    return s1.length() - s2.length();\n }\n});\n</code></pre> <p>The example above removes the need to declare a class just to compare two strings.  </p> <p>An anonymous class has the following format: <code>new X (arguments) { body }</code>, where:</p> <ul> <li>X is a class that the anonymous class extends or an interface that the anonymous class implements.  X cannot be empty.  This syntax also implies an anonymous class cannot extend another class and implement an interface at the same time.  Furthermore, an anonymous class cannot implement more than one interface. Put simply, you cannot have <code>extends</code> and <code>implements</code> keywords in between <code>X</code> and <code>(arguments)</code>.</li> <li>arguments are the arguments that you want to pass into the constructor of the anonymous class.  If the anonymous class is extending an interface, then there is no constructor, but we still need <code>()</code>.</li> <li>body is the body of the class as per normal, except that we cannot have a constructor for an anonymous class.</li> </ul> <p>The syntax might look overwhelming at first, but we can also write it as:</p> <pre><code>Comparator&lt;String&gt; cmp = new Comparator&lt;String&gt;() {\n  public int compare(String s1, String s2) {\n    return s1.length() - s2.length();\n  }\n};\nnames.sort(cmp);\n</code></pre> <p>Line 1 above looks just like what we do when we instantiate a class, except that we are instantiating an interface with a <code>{ .. }</code> body.</p> <p>You can think of anonymous class as a syntactic sugar for the following class.</p> <pre><code>class MyComparator implements Comparator&lt;String&gt; {\n  public int compare(String s1, String s2) {\n    return s1.length() - s2.length();\n  }\n}\n</code></pre> <p>Then, the code above can also be rewritten to be the following.</p> <pre><code>Comparator&lt;String&gt; cmp = new MyComparator();\nnames.sort(cmp);\n</code></pre> <p>Like a local class, an anonymous class captures the variables of the enclosing scope as well \u2014 the same rules to variable access as local classes apply.</p> <p>Anonymous classes were commonly used before Java 8 for single-use behavior. In many cases, lambda expressions (which you will encounter in the next unit) now provide a clearer alternative, but anonymous classes are still required when state or multiple methods are involved.</p> <ol> <li> <p>Some recent versions of Java optimize away the implicit reference to the enclosing instance if it is not used in the inner class.  However, for the purpose of this course, we will always assume the implicit reference always exists.\u00a0\u21a9</p> </li> </ol>"},{"location":"30-functions.html","title":"Unit 30: Side Effect-Free Programming","text":"<p>Learning Objectives</p> <p>After completing this unit, students should be able to:</p> <ul> <li>Explain the notion of functions as side-effect-free computations and relate them to mathematical functions, including referential transparency.</li> <li>Identify and reason about side effects and purity in Java methods, and explain why purity improves program reasoning and correctness.</li> <li>Use functions as first-class values in Java, including defining, assigning, passing, and returning functions via functional interfaces.</li> <li>Write and refactor code using lambda expressions and method references, replacing anonymous classes where appropriate.</li> <li>Apply currying and partial application to transform multi-argument computations into higher-order unary functions.</li> <li>Explain and use closures, including how lambda expressions capture their surrounding environment and the implications of effective finality.</li> </ul> <p>Overview</p> <p>In earlier units, we emphasized abstraction, immutability, and reasoning about program behavior using types. These ideas allow us to control how objects are used and how data flows through a program, but they do not by themselves guarantee that code is easy to reason about.</p> <p>As programs grow, reasoning becomes difficult when methods can modify state, depend on hidden variables, or produce unexpected side effects. Even simple expressions can no longer be safely replaced by their values, breaking the local reasoning we rely on in mathematics.</p> <p>This unit revisits these earlier ideas from a different angle: how restricting side effects allows programs to be reasoned about like mathematical functions. By treating computation as the composition of well-behaved functions, we strengthen the guarantees provided by immutability and abstraction, and make program behavior easier to understand, test, and maintain.</p>"},{"location":"30-functions.html#functions","title":"Functions","text":"<p>Recall that, a function, in mathematics, refers to a mapping from a set of inputs (domain) \\(X\\) to a set of output values (codomain) \\(Y\\).  We write \\(f: X \\rightarrow Y\\).  Every input in the domain must map to exactly one output but multiple inputs can map to the same output.  Not all values in the codomain need to be mapped.  </p> <p>In mathematics, we follow certain rules to reason about functions.  For instance, suppose we have an unknown \\(x\\) and a function \\(f\\), we know that applying \\(f\\) on \\(x\\), i.e., \\(f(x)\\) does not change the value of \\(x\\), or any other unknowns \\(y\\), \\(z\\), etc.  We say that mathematical functions have no side effects.  It simply computes and returns the value.</p> <p>Another property of a mathematical function is referential transparency.  Let \\(f(x) = a\\).  Then in every formula that \\(f(x)\\) appears in, we can safely replace occurences of \\(f(x)\\) with \\(a\\).  Conversely, everywhere \\(a\\) appears, we can replace it with \\(f(x)\\).  We are guaranteed that the resulting formulas are still equivalent.</p> <p>These two fundamental properties of mathematical functions allow us to solve equations, prove theorems, and reason about mathematical objects rigorously.</p> <p>Unfortunately, we can't always reason about our program the same way as we reason about mathematical functions.  For instance, consider the line:</p> <pre><code>s.get(0)\n</code></pre> <p>where <code>s</code> is an instance of <code>Seq&lt;T&gt;</code>.  Suppose we know that <code>s.get(0)</code> is 5 for some <code>s</code>.  When we reason about the behavior of our code, we cannot replace (mentally) every invocation of <code>s.get(0)</code> with the result 5.  This is because the sequence <code>s</code> may not be immutable and therefore <code>s.get(0)</code> cannot be guaranteed to be the same.  </p> <p>The converse should also hold.  Suppose we have a variable</p> <pre><code>T t = s.get(0);\n</code></pre> <p>Then everywhere in our code where we use <code>t</code>, we should be able to replace it with <code>s.get(0)</code>, and the behavior of the code should still be the same. This behavior is only guaranteed if <code>s.get(0)</code> has no side effects (such as modifying a field or printing something to the standard output).</p> <p>To be able to reason about our code using the mathematical reasoning techniques we are familiar with, it is important to write our code as if we are writing mathematical functions \u2014 our methods should be free of side effects and our code should be referentially transparent.  Our program is then just a sequence of functions, chained and composed together.  To achieve this, functions need to be a first class citizen in our program, so that we can assign functions to a variable, pass it as parameters, return a function from another function, etc, just like any other variable.</p>"},{"location":"30-functions.html#pure-functions","title":"Pure Functions","text":"<p>Ideally, methods in our programs should behave the same as functions in mathematics.  Given an input, the function computes and returns an output.  A pure function does nothing else \u2014 it does not print to the screen, write to files, throw exceptions, change other variables, modify the values of the arguments, etc.  That is, a pure function does not cause any side effects.  </p> <p>Here are two examples of pure functions:</p> <pre><code>int square(int i) {\n  return i * i;\n}\n\nint add(int i, int j) {\n  return i + j;  // believe it or not, an overflow is\n                 // not an error in Java\n}\n</code></pre> <p>and some examples of non-pure functions: <pre><code>int div(int i, int j) {\n  return i / j;  // may throw an exception\n}\n\nint incrCount(int i) {\n  return this.count + i; // assume that count is not final.\n                         // this may give diff results for the same i.\n}\n\nvoid incrCount(int i) {\n  this.count += i; // does not return a value\n                   // and has side effects on count\n}\n\nint addToQueue(Queue&lt;Integer&gt; queue, int i) {\n  queue.enq(i);  // has side effects on queue\n}\n</code></pre></p> <p>A pure function must also be deterministic.  Given the same input, the function must produce the same output, every single time.  This deterministic property ensures referential transparency.</p> <p>In the OO paradigm, we commonly need to write methods that update the fields of an instance or compute values using the fields of an instance.  Such methods are not pure functions.  On the other hand, if our class is immutable, then its methods must not have side effects and thus is pure.</p> <p>In computer science, we refer to the style of programming where we build a program from pure functions as functional programming (FP). Examples of functional programming languages include Haskell, OCaml, Erlang, Clojure, F#, and Elixir.</p> <p>Many modern programming languages including Java, C++, Python, Rust, and Swift support this style of programming.  As these languages are not designed to be functional, we cannot build a program from only pure functions.  Java, for instance, is still an OO language at its core.  As such, we will refer to this style as functional-style programming.  We won't be able to write code consisting of only pure functions in Java, but we can write methods that has no side effects and objects that are immutable, as much as possible.</p>"},{"location":"30-functions.html#function-as-first-class-citizen-in-java","title":"Function as First-Class Citizen in Java","text":"<p>Let's explore functions as a first-class citizen in Java.  We have seen some examples of this when we use the <code>Comparator</code> interface.</p> <pre><code>void sortNames(List&lt;String&gt; names) {\n  Comparator&lt;String&gt; cmp = new Comparator&lt;String&gt;() {\n    public int compare(String s1, String s2) {\n    return s1.length() - s2.length();\n    }\n  };\n  names.sort(cmp);\n}\n</code></pre> <p>First, let's take a moment to appreciate the beauty of the <code>List::sort</code> method.  We can use this method to sort items of any type, in any defined order.  We achieve the generality of types with generics, and the generality of sorting order through passing in the comparison function as a parameter.  The latter is needed to write one sorting method for every possible sorting order for a list of strings, (<code>sortAlphabeticallyIncreasing</code>, <code>sortByLengthDecreasing</code>, etc..)</p> <p>The comparison function here is implemented as a method in an anonymous class that implements an interface.  We can think of an instance of this anonymous class as the function.  Since a function is now just an instance of an object in Java, we can pass it around, return it from a function, and assign it to a variable, just like any other reference type.</p> <p>Let's look at another example.  Consider the following interface: <pre><code>interface Transformer&lt;T, R&gt; {\n  R transform(T t);\n}\n</code></pre></p> <p><code>Transformer&lt;T, R&gt;</code> is a generic interface with two type parameters: <code>T</code> is the type of the input, <code>R</code> is the type of the result.  It has one abstract method <code>R transform(T t)</code> that applies the function to a given argument.</p> <p>We can use this interface to write any function that takes in a value and returns another value.  (Java has a similar interface called, unsurprisingly, <code>java.util.function.Function&lt;T, R&gt;</code>). For instance, a function that computes the square of an integer can be written as: <pre><code>new Transformer&lt;Integer, Integer&gt;() {\n  @Override\n  public Integer transform(Integer x) {\n    return x * x;\n  }\n};\n</code></pre></p> <p>We can write a method <code>chain</code> that composes two given computations together and returns the new computation: <pre><code>// The use of PECS is left as an exercise to the reader\n&lt;T, R, S&gt; Transformer&lt;T,R&gt; chain(Transformer&lt;T,S&gt; t1, Transformer&lt;S,R&gt; t2) {\n  return new Transformer&lt;T,R&gt;() {\n    public R transform(T value) {\n      return t2.transform(t1.transform(value));\n      // in mathematical notation, this is t2(t1(v))\n    }\n  }\n}\n</code></pre></p>"},{"location":"30-functions.html#lambda-expression","title":"Lambda Expression","text":"<p>While we have achieved functions as first-class citizens in Java, the code is verbose and ugly.  Fortunately, there is a much cleaner syntax to write functions that applies to interfaces with a single abstract method.</p> <p>An interface in Java with exactly one abstract method is called a functional interface.  Both <code>Comparator</code> and <code>Transformer</code> are functional interfaces.  It is recommended that, if a programmer intends an interface to be a functional interface, they should annotate the interface with the <code>@FunctionalInterface</code> annotation.</p> <pre><code>@FunctionalInterface\ninterface Transformer&lt;T, R&gt; {\n  R transform(T t);\n}\n</code></pre> <p>JShell Caveat</p> <p>The <code>@FunctionalInterface</code> annotation is not supported in JShell.  You can still create functional interfaces without the annotation.</p> <p>A key advantage of a functional interface is that there is no ambiguity about which method is being overridden by an implementing subclass.</p> <p>For instance, consider: <pre><code>Transformer&lt;Integer, Integer&gt; square = new Transformer&lt;&gt;() {\n  @Override\n  public Integer transform(Integer x) {\n    return x * x;\n  }\n};\nTransformer&lt;Integer, Integer&gt; incr = new Transformer&lt;&gt;() {\n  @Override\n  public Integer transform(Integer x) {\n    return x + 1;\n  }\n};\n</code></pre></p> <p>You can see that there is much boilerplate code in the two functions above that we can remove.  Since we are assigning it to a variable of type <code>Transformer</code> interface, we don't have to write <code>new Transformer&lt;&gt;() { .. }</code>.  And since <code>Transformer</code> is an interface, there is no constructor.  Since there is only one abstract method to overwrite, we don't have to write <code>@Override public Integer transform(..) { .. }</code>.</p> <p>What remain after we eliminate the obvious boilerplate code are (i) the parameter <code>Integer x</code> and (ii) the body of <code>transform</code>, which is <code>{ return x * x; }</code>.    We can use the Java arrow notation <code>-&gt;</code> to now link the parameter and the body:</p> <pre><code>Transformer&lt;Integer, Integer&gt; square = (Integer x) -&gt; { return x * x; };\nTransformer&lt;Integer, Integer&gt; incr = (Integer x) -&gt; { return x + 1; };\n</code></pre> <p>You might notice that the type of the parameter is redundant as well since the type argument to <code>Transformer</code> already tells us this function takes in an <code>Integer</code>. We can further simplify it to: <pre><code>Transformer&lt;Integer, Integer&gt; square = (x) -&gt; { return x * x; };\nTransformer&lt;Integer, Integer&gt; incr = (x) -&gt; { return x + 1; };\n</code></pre></p> <p>or simply: <pre><code>Transformer&lt;Integer, Integer&gt; square = x -&gt; { return x * x; };\nTransformer&lt;Integer, Integer&gt; incr = x -&gt; { return x + 1; };\n</code></pre></p> <p>where there is only one parameter.</p> <p>Since the body has only a single return statement, we can simplify it further: <pre><code>Transformer&lt;Integer, Integer&gt; square = x -&gt; x * x;\nTransformer&lt;Integer, Integer&gt; incr = x -&gt; x + 1;\n</code></pre></p> <p>Now, that's much better!</p> <p>The expressions above, including <code>x -&gt; x * x</code>, are called lambda expressions.  You can recognize one by the use of <code>-&gt;</code>.   The left-hand side lists the parameters (use <code>()</code> if there is no parameter), while the right-hand side is the computation.  We do not need the type in cases where Java can infer the type, nor need the return keyword and the curly brackets when there is only a single return statement.</p> <p>lambda</p> <p>Alonzo Church invented lambda calculus (\\(\\lambda\\)-calculus) in 1936, before electronic computers, as a way to express computation.  In \\(\\lambda\\)-calculus, all functions are anonymous.  The term lambda expression originated from there.</p>"},{"location":"30-functions.html#method-reference","title":"Method Reference","text":"<p>A lambda expression is useful for specifying a new anonymous method.  Sometimes, we want to use an existing method as a first-class citizen instead.</p> <p>Recall the <code>distanceTo</code> method in <code>Point</code>, which takes in another point as a parameter and returns the distance between this point and the given point.</p> <pre><code>class Point {\n    :\n\n  public double distanceTo(Point p) {\n      :\n  }\n}\n</code></pre> <p>We can write our <code>Transformer</code> like this using an anonymous class: <pre><code>Point origin = new Point(0, 0);\nTransformer&lt;Point, Double&gt; dist = new Transformer&lt;&gt;() {\n  @Override\n  public Double transform(Point p) {\n    return origin.distanceTo(p);\n  }\n}\n</code></pre></p> <p>or using a lambda expression: <pre><code>Point origin = new Point(0, 0);\nTransformer&lt;Point, Double&gt; dist = p -&gt; origin.distanceTo(p);\n</code></pre></p> <p>but since <code>distanceTo</code> takes in one parameter and returns a value, it already fits as a transformer, and we can write it as: <pre><code>Point origin = new Point(0, 0);\nTransformer&lt;Point, Double&gt; dist = origin::distanceTo;\n</code></pre></p> <p>The double-colon notation <code>::</code> is used to specify a method reference.  We can use method references to refer to a (i) static method in a class, (ii) instance method of a class or interface, (iii) constructor of a class.  Here are some examples (and their equivalent lambda expression)</p> <pre><code>Box::of            // x -&gt; Box.of(x)\nBox::new           // x -&gt; new Box(x)\nx::compareTo       // y -&gt; x.compareTo(y)\nA::foo             // (x, y) -&gt; x.foo(y) or (x, y) -&gt; A.foo(x,y)\n</code></pre> <p>The last example shows that the same method reference expression can be interpreted in two different ways.  The actual interpretation depends on how many parameters <code>foo</code> takes and whether <code>foo</code> is a class method or an instance method.  When compiling, Java searches for the matching method, performing type inferences to find the method that matches the given method reference.  A compilation error will be thrown if there are multiple matches or if there is ambiguity in which method matches.</p> <p>For example, suppose we have: <pre><code>class B {\n  static int bar(int x, int y) { ... }\n}\n\nclass C {\n  int bar(int x) { ... }\n}\n</code></pre></p> <p>Then <code>B::bar</code> can only be interpreted as <code>(x, y) -&gt; B.bar(x, y)</code>, while <code>C::bar</code> can only be interpreted as <code>(c, x) -&gt; c.bar(x)</code>.</p> <p>Note the difference between a lambda expression and a method reference.  A lambda expression defines a new anonymous function by explicitly specifying its parameters and computation, while a method reference refers to an existing method and reuses its implementation. Lambdas are used when we need to describe what computation to perform, whereas method references are used when an appropriate method already exists and we only want to treat it as a function value. </p>"},{"location":"30-functions.html#curried-functions","title":"Curried Functions","text":"<p>Mathematically, a function takes in only one value and returns one value (e.g., <code>square</code> above).  In programming, we often need to write functions that take in more than one argument (e.g., <code>add</code> above). Even though <code>Transformer</code> only supports functions with a single parameter, we can build functions that take in multiple arguments.  Let's look at this mathematically first.  Consider a binary function \\(f: (X, Y) \\rightarrow Z\\).  We can introduce \\(F\\) as a set of all functions \\(f': Y \\rightarrow Z\\), and rewrite \\(f\\) as \\(f: X \\rightarrow F\\), or \\(f: X \\rightarrow Y \\rightarrow Z\\).</p> <p>The arrow \\(\\rightarrow\\) is to be read from right to left.  So \\(f: X \\rightarrow Y \\rightarrow Z\\) is equivalent to \\(f: X \\rightarrow (Y \\rightarrow Z)\\).  But what does it actually mean?  It means that instead of having a function that takes in two arguments, we can instead have a function that takes in one argument (typically the first argument) and returns another function to accept the second argument.</p> <p>A trivial example of this is the <code>add</code> method that adds two <code>int</code> values. <pre><code>int add(int x, int y) {\n  return x + y;\n}\n</code></pre></p> <p>This can be written as <pre><code>Transformer&lt;Integer, Transformer&lt;Integer, Integer&gt;&gt; add = x -&gt; y -&gt; (x + y);\n</code></pre></p> <p>To calculate 1 + 1, we call <pre><code>add.transform(1).transform(1);\n</code></pre></p> <p>Let's break it down a little, <code>add</code> is a function that takes in an <code>Integer</code> object and returns a unary <code>Function</code> over <code>Integer</code>.  So <code>add.transform(1)</code> returns the function <code>y -&gt; 1 + y</code>.  We could assign this to a variable: <pre><code>Transformer&lt;Integer,Integer&gt; incr = add.transform(1);\n</code></pre></p> <p>Note that <code>add</code> is no longer a function that takes two arguments and returns a value.  It is a higher-order function.  A higher-order function is one that takes or returns another function.</p> <p>The technique that translates a general \\(n\\)-ary function to a sequence of \\(n\\) unary functions is called currying.  After currying, we have a sequence of curried functions.  </p> <p>Curry</p> <p>Currying is not related to food but rather is named after computer scientist Haskell Curry, who popularized the technique.</p> <p>How is currying useful?  Consider <code>add(1, 1)</code> \u2014 we have to have both arguments available at the same time to compute the function.  With currying, we no longer have to.  We can evaluate the different arguments at a different time (as the <code>incr</code> example above).  This feature is useful in cases where some arguments are not available until later.  We can partially apply a function first.  This is also useful if one of the arguments does not change often, or is expensive to compute.  We can save the partial results as a function and continue applying it later.  We can dynamically create functions as needed, save them, and invoke them later.</p>"},{"location":"30-functions.html#lambda-as-closure","title":"Lambda as Closure","text":"<p>In the example, we showed earlier, <pre><code>Point origin = new Point(0, 0);\nTransformer&lt;Point, Double&gt; dist = p -&gt; origin.distanceTo(p);\n</code></pre></p> <p>the variable <code>origin</code> is captured by the lambda expression <code>dist</code>.  Just like in local and anonymous classes, a captured variable must be either explicitly declared as <code>final</code> or is effectively final.</p> <p>A lambda expression stores more than just the function to invoke \u2014 it also stores the data from the environment where it is defined.  We call such a construct that stores a function together with the enclosing environment a closure.</p> <p>Being able to save the current execution environment, and then continue to compute it later, adds new power to how we can write our program.  We can make our code cleaner with fewer parameters to pass around and less duplicated code.  We can separate the logic to do different tasks in a different part of our program more easily.</p> <p>We will see more examples of this later.</p> <p>Another difference between a lambda expression and method reference, is that method reference does not capture the surrounding environment.  For instance, in the example above, if we wrote: <pre><code>Point origin = new Point(0, 0);\nTransformer&lt;Point, Double&gt; dist = origin::distanceTo;\norigin = new Point(1, 1);\ndouble diagonal = dist.transform(new Point(3, 4)); // 5.0\n</code></pre></p> <p><code>diagonal</code> will be 5.0.  Line 4 computes the distance with respect to the original <code>origin</code> at (0, 0).  So although <code>origin</code> is not effectively final, the method reference <code>origin::distanceTo</code> is pointing to exactly the method <code>distanceTo</code> within this particular instance when the assignment occurs.  So even if the variable <code>origin</code> is reassigned to another value, the method reference is still pointing to the old method.</p>"},{"location":"31-box-maybe.html","title":"Unit 31: Box and Maybe","text":"<p>Learning Objectives</p> <p>After completing this unit, students should be able to:</p> <ul> <li>explain how higher-order methods (e.g. map, filter) allow controlled manipulation of hidden state across an abstraction barrier</li> <li>apply <code>Box&lt;T&gt;</code>-style abstractions to build general, reusable containers parameterized by both types and behavior</li> <li>explain the role of <code>Maybe&lt;T&gt;</code> as an option type that preserves \u201cmissing value\u201d semantics without exposing null</li> <li>reason about how wrapping null inside <code>Maybe&lt;T&gt;</code> restores function purity by keeping return values within the declared codomain</li> <li>use map and filter on <code>Maybe&lt;T&gt;</code> to eliminate explicit <code>null</code> checks and prevent <code>NullPointerException</code></li> </ul> <p>Overview</p> <p>In earlier units, we learned how abstraction barriers protect internal state, how immutability simplifies reasoning, and how lambda expressions allow behavior to be passed around as values. We also saw how higher-order methods such as map and filter let us transform data without exposing its representation.</p> <p>In this unit, we bring these ideas together by studying <code>Box&lt;T&gt;</code> and <code>Maybe&lt;T&gt;</code>. These classes show how a container can remain fully encapsulated while still being highly flexible, by allowing clients to operate on hidden values using functions rather than direct access. In particular, <code>Maybe&lt;T&gt;</code> addresses a long-standing problem in Java: how to represent missing values without breaking function purity or relying on fragile null checks.</p> <p>By the end of this unit, you will see how combining generics and lambda expressions enables us to build general, safe abstractions that scale beyond concrete data structures, and how <code>Maybe&lt;T&gt;</code> helps us write code that is both more expressive and less error-prone.</p>"},{"location":"31-box-maybe.html#lambda-as-a-cross-barrier-state-manipulator","title":"Lambda as a Cross-Barrier State Manipulator","text":"<p>Recall that every class has an abstraction barrier between the client and the implementer.  The internal state of the class is protected and hidden.   The implementer selectively provides a set of methods to access and manipulate the internal states of instances.  This approach allows the implementer to control what the client can and cannot do to the internal states.  This is good if we want to build abstractions over specific entities such as shapes or data structures such as a stack, but it is not flexible enough to build general abstractions.</p> <p>Let's consider the following class:</p> <pre><code>class Box&lt;T&gt; {\n  private T item;\n}\n</code></pre> <p>It is a box containing a single item of type <code>T</code>.  Suppose that we want to keep the <code>item</code> hidden and we want to have certain rules and maintain some semantics about the use of the <code>item</code>.  Therefore, we don't want to provide any setter or getter, so that the client cannot voilate these rules.  What are some ways we can still operate on this <code>item</code>?</p> <p>The only way to operate on this hidden item is to provide methods that accept a lambda expression, apply the lambda expression on the item, and return the new box with the new value.  For instance,</p> <pre><code>class Box&lt;T&gt; {\n  private T item;\n    :\n\n  public &lt;U&gt; Box&lt;U&gt; map(Transformer&lt;? super T, ? extends U&gt; transformer) {\n    if (!isPresent()) {\n      return empty();\n    }\n    return Box.ofNullable(transformer.transform(this.item));\n  }\n    :\n\n  public Box&lt;T&gt; filter(BooleanCondition&lt;? super T&gt; condition) {\n    if (!isPresent() || !(condition.test(this.item))) {\n      return empty();\n    }\n    return this;\n  }\n    :\n}\n</code></pre> <p>The method <code>map</code> takes in a lambda expression and allows us to arbitrarily apply a function to the item, while the method <code>filter</code> allows us to perform an arbitrary check on the property of the item.</p> <p>Methods such as these, which accept a function as a parameter, allow the client to manipulate the data behind the abstraction barrier without knowing the internals of the object.  Here, we are treating lambda expressions as \"manipulators\" that we can pass in behind the abstraction barrier and modify the internals arbitrarily for us, while the container or the box tries to maintain the semantics for us.</p>"},{"location":"31-box-maybe.html#maybe","title":"Maybe","text":"<p>Let's now look at <code>Box&lt;T&gt;</code> in a slightly different light.  Let's rename it to <code>Maybe&lt;T&gt;</code>.  <code>Maybe&lt;T&gt;</code> is an option type, a common abstraction in programming languages (<code>java.util.Optional</code> in Java, <code>option</code> in Scala, <code>Maybe</code> in Haskell, <code>Nullable&lt;T&gt;</code> in C#, etc) that is a wrapper around a value that is either there or is <code>null</code>.  The <code>Maybe&lt;T&gt;</code> abstraction allows us to write code without about the possibility that our value is missing.  When we call <code>map</code> on a value that is missing, nothing happens.</p> <p>Recall that we wish to write a program that is as close to pure mathematical functions as possible, a mathematical function always has a well-defined domain and codomain.  If we have a method that looks like this: <pre><code>Counter c = bank.findCounter();\n</code></pre></p> <p>Then <code>findCounter</code> is mapping from the domain of banks to counters.  However, if we implement <code>findCounter</code> such that it returns <code>null</code> if no counter is available, then <code>findCounter</code> is not a function anymore.  The return value <code>null</code> is not a counter, as we cannot do things that we can normally do on counters to it.  So <code>findCounter</code> now maps to a value outside its codomain!  This violation of the purity of function adds complications to our code, as we now have to specifically filter out <code>null</code> value, and is a common source of bugs.</p> <p>One way to fix this is to have a special counter (say, <code>class NullCounter extends Counter</code>) that is returned whenever no counter is available.  This way, our <code>findCounter</code> remains a pure function.  But this is not a general solution.  If we adopt this solution, everywhere we return <code>null</code> in place of a non-null instance we have to create a special subclass.</p> <p>Another way, that is more general, is to expand the codomain of the function to include <code>null</code>, and wrap both <code>null</code> and <code>Counter</code> under a type called <code>Maybe&lt;Counter&gt;</code>.  We make <code>findCounter</code> returns a <code>Maybe&lt;Counter&gt;</code> instead <pre><code>Maybe&lt;Counter&gt; c = bank.findCounter();\n</code></pre></p> <p>With this design, <code>findCounter</code> is now a function with the domain <code>Bank</code> mapped to the codomain <code>Maybe&lt;Counter&gt;</code>, and it is pure.</p> <p>Another way to view the <code>Maybe&lt;T&gt;</code> class is that it internalizes all the checks for <code>null</code> on the client's behalf.  <code>Maybe&lt;T&gt;</code> ensures that if <code>null</code> represents a missing value, then the semantics of this missing value is preserved throughout the chain of <code>map</code> and <code>filter</code> operations.  Within its implementation, <code>Maybe&lt;T&gt;</code> does the right thing when the value is missing to prevent us from encountering <code>NullPointerException</code>.  There is a check for <code>null</code> when needed, internally, within <code>Maybe&lt;T&gt;</code>.  This internalization removes the burden of checking for <code>null</code> on the programmer and removes the possibility of runtime crashes due to missing <code>null</code> checks.</p>"},{"location":"32-lazy.html","title":"Unit 32: Lazy Evaluation","text":"<p>Learning Objectives</p> <p>After this unit, students should be able to:</p> <ul> <li>explain the difference between eager and lazy evaluation, and how lambda expressions can be used to delay computation in Java;</li> <li>use functional interfaces (such as <code>Producer&lt;T&gt;</code>) to defer evaluation and avoid unnecessary computation;</li> <li>implement memoization using a <code>Lazy&lt;T&gt;</code> abstraction and reason about when such laziness is safe and beneficial.</li> </ul> <p>Overview</p> <p>In earlier units, we learned how lambda expression allows us to treat behavior as data, enabling higher-order functions and more declarative code. In this unit, we build on that idea to explore when computations are performed.</p> <p>By default, Java evaluates expressions eagerly \u2014 values are computed immediately, even if they are never used. Lazy evaluation delays computation until the result is actually needed, allowing us to avoid unnecessary work and improve efficiency. We will see how lambda expressions, together with simple abstractions such as <code>Producer&lt;T&gt;</code> and <code>Lazy&lt;T&gt;</code>, allow us to implement laziness explicitly in Java.</p>"},{"location":"32-lazy.html#lambda-as-delayed-data","title":"Lambda as Delayed Data","text":"<p>When we write a lambda expression like this: <pre><code>Transformer&lt;Integer, Integer&gt; f = x -&gt; x + 1;\n</code></pre></p> <p>we are just defining a function rather than invoke it.  This is clear because invoking the function requires an argument for <code>x</code>, and no argument is supplied when we define <code>f</code>.</p> <p>Consider the following functional interfaces instead: <pre><code>@FunctionalInterface\ninterface Producer&lt;T&gt; {\n  T produce();\n}\n\n@FunctionalInterface\ninterface Task {\n  void run();\n}\n</code></pre></p> <p>These functional interfaces have a method that does not take in a parameter.  So, we would use them as follows:</p> <pre><code>i = 4;\nTask print = () -&gt; System.out.println(i);\nProducer&lt;String&gt; toStr = () -&gt; Integer.toString(i);\n</code></pre> <p>Keep in mind that the lambda expressions assigned to <code>print</code> and <code>toStr</code> are not executed when they are declared.  We are just saving them to be executed later.</p> <p>Lambda expressions, therefore, allows us to delay the execution of code, saving them until they are needed.  This enables another powerful mechanism called lazy evaluation.  We can build up a sequence of complex computations, without actually executing them, until we need to.  Expressions are evaluated on demand when their values are required.</p> <p>Consider the following class:</p> Logger v0.1 with Eager Evaluation<pre><code>class Logger {\n  enum LogLevel { INFO, WARNING, ERROR };\n\n  public static LogLevel currLogLevel = LogLevel.WARNING;\n\n  static void log(LogLevel level, String msg) {\n    if (level.compareTo(Logger.currLogLevel) &gt;= 0) {\n      System.out.println(\" [\" + level + \"] \" + msg);\n    }\n  }\n}\n</code></pre> <p>The <code>log</code> method checks the log level (i.e, how serious is the message) of the message against the current log level and only prints the message if the level of the message is the same or higher.  For instance, if the current log level is <code>WARNING</code>, then</p> <pre><code>Logger.log(Logger.LogLevel.INFO, \n    \"User \" + System.getProperty(\"user.name\") + \" has logged in\");\n</code></pre> <p>will not get printed.</p> <p>However, regardless of whether the log message will be printed, the method <code>System.getProperty(\"user.name\")</code> will be evaluated, which results in unnecessary computation.</p> <p>A better design is to wrap the message <code>msg</code> within a lambda expression so that it does not get evaluated eagerly when we pass it in as a parameter.  We can wrap the message with a <code>Producer&lt;String&gt;</code>.  The new <code>lazyLog</code> method looks like this:</p> Logger v0.2 with Message Producer<pre><code>class Logger {\n  enum LogLevel { INFO, WARNING, ERROR };\n\n  public static LogLevel currLogLevel = LogLevel.WARNING;\n\n  static void lazyLog(LogLevel level, Producer&lt;String&gt; msg) {\n    if (level.compareTo(Logger.currLogLevel) &gt;= 0) {\n      System.out.println(\" [\" + level + \"] \" + msg.produce());\n    }\n  }\n}\n</code></pre> <p>and is invoked like this: <pre><code>Logger.lazyLog(Logger.LogLevel.INFO, \n    () -&gt; \"User \" + System.getProperty(\"user.name\") + \" has logged in\");\n</code></pre></p> <p>The method <code>System.getProperty(\"user.name\")</code> is now lazily called, only if the message is going to be printed.</p>"},{"location":"32-lazy.html#memoization","title":"Memoization","text":"<p>We have so far seen one way of being lazy, i.e., procrastinating our computation until we really need the data.  Another way of being lazy is to avoid repeated computation.  If we have computed the value of a function before, we can cache (or memoize) the value and reuse it.  Memoization is useful only if the function is pure \u2014 it always returns the same value and has no side effects.  Here, we see another important advantage of keeping our code pure and free of side effects \u2014 so that we can be lazy!</p> <p>While other languages such as Scala has native support for lazy variables, Java does not.  So let's build a simple one here.  (You will build a more sophisticated one in Lab 6) </p> Lazy with Memoization<pre><code>class Lazy&lt;T&gt; {\n  private T value;\n  private boolean evaluated;\n  private Producer&lt;T&gt; producer;\n\n  public Lazy(Producer&lt;T&gt; producer) {\n    evaluated = false;\n    value = null;\n    this.producer = producer;\n  }\n\n  public T get() {\n    if (!evaluated) {\n      value = producer.produce();\n      evaluated = true;\n    }\n    return value;\n  }\n}\n</code></pre> <p>We can now rewrite our <code>Logger</code> as</p> Logger v0.3 using Lazy<pre><code>class Logger {\n  enum LogLevel { INFO, WARNING, ERROR };\n\n  public static LogLevel currLogLevel = LogLevel.WARNING;\n\n  static void lazyLog(LogLevel level, Lazy&lt;String&gt; msg) {\n    if (level.compareTo(Logger.currLogLevel) &gt;= 0) {\n      System.out.println(\" [\" + level + \"] \" + msg.get());\n    }\n  }\n}\n</code></pre> <p>and call it as follows: <pre><code>Lazy&lt;String&gt; loginMessage = new Lazy(\n    () -&gt; \"User \" + System.getProperty(\"user.name\") + \" has logged in\");\nLogger.lazyLog(Logger.LogLevel.INFO, loginMessage);\n</code></pre></p> <p>If <code>loginMessage</code> is used in multiple places, memoization ensures that <code>System.getProperty(\"user.name\")</code> and the string concatenation are performed only once.</p>"},{"location":"33-infinitelist.html","title":"Unit 33: Infinite List","text":"<p>Learning Objectives</p> <p>After completing this unit, students should be able to:</p> <ul> <li>Explain why an eagerly evaluated list cannot represent an unbounded sequence and how <code>InfiniteList</code> overcomes this limitation using lazy evaluation.</li> <li>Construct instances of <code>InfiniteList</code> using higher-order factory methods such as <code>generate</code> and <code>iterate</code>.</li> <li>Trace and reason about the evaluation order of <code>InfiniteList</code> operations, including <code>head</code>, <code>tail</code>, <code>get</code>, and <code>map</code>.</li> <li>Implement and reason about lazy transformations on <code>InfiniteList</code>, particularly <code>map</code> and <code>filter</code>.</li> <li>Identify design challenges in <code>InfiniteList</code> implementations (e.g. filtering, repeated evaluation) and motivate the use of abstractions such as <code>Maybe&lt;T&gt;</code> and <code>Lazy&lt;T&gt;</code> to address them.</li> </ul> <p>Overview</p> <p>In earlier units, we learned how higher-order functions and lambda expressions allow us to build flexible abstractions over data. We also introduced lazy evaluation, using <code>Producer</code> and <code>Lazy</code>, to delay computation until a value is needed.</p> <p>This unit brings these ideas together to construct an <code>InfiniteList</code>: a list that can represent an unbounded sequence of values. Such a structure cannot be implemented using eager evaluation, as attempting to generate all elements would never terminate. By using laziness, however, we can describe infinite sequences declaratively and compute only the elements we actually access.</p>"},{"location":"33-infinitelist.html#preliminary-an-eagerly-evaluated-list","title":"Preliminary: An Eagerly Evaluated List","text":"<p>We begin with an eagerly evaluated list not to propose it as a reusable abstraction, but to establish a familiar baseline. By contrasting an eagerly evaluated list with a lazily evaluated one, we can isolate exactly what must change when a list is allowed to be unbounded. </p> <p>Let's consider first how we can represent an eagerly evaluated, finite list, recursively.  </p> <p>A simple way is to treat the list as a recursive structure, containing a <code>head</code> and a <code>tail</code>, with the <code>tail</code> being a list itself.  We have a special terminating list called <code>Sentinel</code> that we use to terminate the EagerList.</p> An Eagerly Evaluated Finite List<pre><code>class EagerList&lt;T&gt; {\n  private final T head;\n  private final EagerList&lt;T&gt; tail;\n  private static EagerList&lt;?&gt; EMPTY = new Sentinel(); \n\n  public EagerList(T head, EagerList&lt;T&gt; tail) {\n    this.head = head;\n    this.tail = tail;\n  }\n\n  public T head() {    \n    return this.head;  \n  }\n\n  public EagerList&lt;T&gt; tail() { \n    return this.tail;          \n  }\n\n  public T get(int n) {\n    if (n == 0) {\n      return this.head();          \n    }                              \n    return this.tail().get(n - 1); \n  }\n\n  public static &lt;T&gt; EagerList&lt;T&gt; empty() {\n    @SuppressWarnings(\"unchecked\")\n    EagerList&lt;T&gt; temp = (EagerList&lt;T&gt;) EMPTY;\n    return temp;\n  }\n\n  private static class Sentinel extends EagerList&lt;Object&gt; {\n    Sentinel() {\n      super(null, null);\n    }\n\n    @Override\n    public Object head() {\n      throw new java.util.NoSuchElementException();\n    }\n\n    @Override\n    public EagerList&lt;Object&gt; tail() {\n      throw new java.util.NoSuchElementException();\n    }\n\n    @Override\n    public Object get(int n) {\n      throw new java.util.NoSuchElementException();\n    }\n  }\n}\n</code></pre> <p>Let's provide two factory methods called <code>generate</code> and <code>iterate</code>, that will populate our EagerList for us.</p> <pre><code>  public static &lt;T&gt; EagerList&lt;T&gt; generate(T t, int size) {\n    if (size == 0) {\n      return empty();\n    }\n    return new EagerList&lt;&gt;(t, generate(t, size - 1));\n  }\n\n  public static &lt;T&gt; EagerList&lt;T&gt; iterate(T init, BooleanCondition&lt;? super T&gt; cond, Transformer&lt;? super T, ? extends T&gt; op) {\n    if (!cond.test(init)) {\n      return empty();\n    }\n    return new EagerList&lt;&gt;(init, iterate(op.transform(init), cond, op));\n  }\n</code></pre> <p>Let's now provide the standard operation <code>map</code> so that we can transform the items in the list. The <code>map</code> method takes a lambda expression as the parameter, applies it recursively to every element in the list, and returns the resulting new list. </p> <pre><code>  public &lt;R&gt; EagerList&lt;R&gt; map(Transformer&lt;? super T, ? extends R&gt; mapper) {\n    return new EagerList&lt;&gt;(mapper.transform(this.head()), this.tail().map(mapper));\n  }\n</code></pre> <p>We can also provide the <code>filter</code> method, that takes in lambda expression as a parameter and tests if each element in the list passes the test.  We return the list containing only the elements that pass the given test.</p> <pre><code>  public EagerList&lt;T&gt; filter(BooleanCondition&lt;? super T&gt; cond) {\n    if (cond.test(this.head())) {\n      return new EagerList&lt;&gt;(this.head(), this.tail().filter(cond));\n    }\n    return this.tail().filter(cond);\n  }\n</code></pre> <p>We have the special <code>Sentinel</code> cases, <pre><code>  @Override\n  public &lt;R&gt; EagerList&lt;R&gt; map(Transformer&lt;? super Object, ? extends R&gt; mapper) {\n    return empty();\n  }\n\n  @Override\n  public EagerList&lt;Object&gt; filter(BooleanCondition&lt;? super Object&gt; cond) {\n    return empty();\n  }\n</code></pre></p> <p>The resulting list can be used this way: <pre><code>EagerList&lt;Integer&gt; l = EagerList.iterate(1, i -&gt; i &lt; 10, i -&gt; i + 1) // [1, ..., 9]\n    .filter(i -&gt; i % 3 == 0)  // [3, 6, 9]\n    .map(i -&gt; i * 2);  // [6, 12, 18]\nl.head();        // 6\nl.tail().head(); // 12\nl.tail().tail().head(); // 18\nl.get(2);               // 18\n</code></pre></p>"},{"location":"33-infinitelist.html#an-infinite-list","title":"An Infinite List","text":"<p>Lazy evaluation allows us to delay the computation that produces data until the data is needed.  This powerful concept enables us to build computationally efficient data structures.  We will focus on building a list with a possibly an infinite number of elements \u2014 something that couldn't be done without lazy evaluation.  Any eager-evaluation-based solution will just run in an infinite loop if the list is infinitely long.  For instance,</p> <pre><code>EagerList.iterate(\"\", s -&gt; s.length() &gt;= 0, s -&gt; s + \"a\"); // infinite loop\n</code></pre> <p>Just as we saw in the previous unit, we can delay a computation by using the <code>Producer</code> functional interface (or anything equivalent).  Instead of doing <code>compute()</code> which is immediately evaluated when executed, we replace it with a <code>Producer</code> <code>() -&gt; compute()</code>, which \"stores\" the computation in an instance of <code>Producer</code>, and we only call it when we invoke the <code>produce()</code> method.</p> <p>Instead of storing the head and tail of the list, we can think of an infinite list as consisting of two functions, the first is a function that generates the head, and the second is a function that generates the tail.  Our <code>InfiniteList</code> looks like this:</p> InfiniteList v0.1<pre><code>class InfiniteList&lt;T&gt; {\n  private final Producer&lt;T&gt; head;\n  private final Producer&lt;InfiniteList&lt;T&gt;&gt; tail;\n\n  public InfiniteList(Producer&lt;T&gt; head, Producer&lt;InfiniteList&lt;T&gt;&gt; tail) {\n    this.head = head;\n    this.tail = tail;\n  }\n\n  public T head() {             \n    return this.head.produce(); \n  }\n\n  public InfiniteList&lt;T&gt; tail() { // same here, method name\n    return this.tail.produce();   // is the same as field name\n  }\n\n  public T get(int n) {\n    if (n == 0) {\n      return this.head();          \n    }                              \n    return this.tail().get(n - 1); \n  }\n}\n</code></pre> <p>Note that we don't need a <code>Sentinel</code> for now.  We will need it if we have operations that truncate the list to a finite one, but let's not worry about it yet.</p> <p>We now change the <code>generate</code> method to be lazy, by passing in a producer instead.  We no longer need to pass in the size, since the list can be infinitely long! <pre><code>  public static &lt;T&gt; InfiniteList&lt;T&gt; generate(Producer&lt;T&gt; producer) {\n    return new InfiniteList&lt;T&gt;(producer,\n        () -&gt; generate(producer));\n  }\n</code></pre></p> <p>We can change <code>iterate</code> as well to only iterate through and generate the next element when we need it.  Note that we no longer need to provide the terminating condition <code>cond</code>. <pre><code>  public static &lt;T&gt; InfiniteList&lt;T&gt; iterate(T init, Transformer&lt;T, T&gt; next) {\n    return new InfiniteList&lt;T&gt;(() -&gt; init,\n        () -&gt; iterate(next.transform(init), next));\n  }\n</code></pre></p> <p>Here are some examples of how to use the two methods above:</p> <pre><code>InfiniteList&lt;Integer&gt; ones = InfiniteList.generate(() -&gt; 1); // 1, 1, 1, 1, ....\nInfiniteList&lt;Integer&gt; evens = InfiniteList.iterate(0, x -&gt; x + 2); // 0, 2, 4, 6, ...\nevens.head(); // -&gt; 0\nevens.get(5); // -&gt; 10\nevens = evens.tail(); \nevens.head(); // -&gt; 2\nevens.get(6); // -&gt; 14\n</code></pre> <p>Both the lists <code>ones</code> and <code>evens</code> are infinitely long, but due to lazy evaluation, we do not generate all the elements in advance, but only when an element is needed.  </p>"},{"location":"33-infinitelist.html#map","title":"Map","text":"<p>Let's now write the lazy version of the <code>map</code> method as well:</p> <pre><code>public &lt;R&gt; InfiniteList&lt;R&gt; map(Transformer&lt;? super T, ? extends R&gt; mapper) {\n  return new InfiniteList&lt;&gt;(\n      () -&gt; mapper.transform(this.head()),\n      () -&gt; this.tail().map(mapper));\n}\n</code></pre> <p>The <code>map</code> method is lazy. All it does is create a new list initialized with a new lambda expression that applies the given lambda expression <code>mapper</code> to the head and the tail.</p> <p>When we run: <pre><code>evens.map(x -&gt; x + 1);\nevens.map(x -&gt; x + 1).map(x -&gt; x * 2);\n</code></pre></p> <p>We get an infinite list with elements 1, 3, 5, 7, etc, but the values in the list are not realized until they are needed, just like before.  Only when we call <code>head()</code> will we evaluate the lambda expressions and obtain the results:</p> <pre><code>evens.map(x -&gt; x + 1).map(x -&gt; x * 2).head(); // 2\n</code></pre>"},{"location":"33-infinitelist.html#under-the-hood","title":"Under The Hood","text":"<p>This section explains how <code>InfiniteList</code> works at runtime by tracing the chain of <code>Producer</code> objects created by successive calls to iterate and map. The goal is to understand when computations are triggered and how values flow through a lazy pipeline. Focus in particular on how a single call to <code>head()</code> causes a sequence of deferred computations to execute.  It is thus worthwhile to trace through the code and understand how <code>head()</code> works.  For simplicity, let's put all our code together for easy reference.</p> InfiniteList v0.2 with generate, iterate, and map<pre><code>class InfiniteList&lt;T&gt; {\n  private final Producer&lt;T&gt; head;\n  private final Producer&lt;InfiniteList&lt;T&gt;&gt; tail;\n\n  public static &lt;T&gt; InfiniteList&lt;T&gt; generate(Producer&lt;T&gt; producer) {\n    return new InfiniteList&lt;T&gt;(producer,\n        () -&gt; InfiniteList.generate(producer));\n  }\n\n  public static &lt;T&gt; InfiniteList&lt;T&gt; iterate(T init, Transformer&lt;T, T&gt; next) {\n      return new InfiniteList&lt;T&gt;(() -&gt; init,\n      () -&gt; InfiniteList.iterate(next.transform(init), next));\n  }\n\n  public InfiniteList(Producer&lt;T&gt; head, Producer&lt;InfiniteList&lt;T&gt;&gt; tail) {\n    this.head = head;\n    this.tail = tail;\n  }\n\n  public T head() {             \n    return this.head.produce(); \n  }\n\n  public InfiniteList&lt;T&gt; tail() { // same here, method name\n    return this.tail.produce();   // is the same as field name\n  }\n\n  public T get(int n) {\n    if (n == 0) {\n      return this.head();          \n    }                              \n    return this.tail().get(n - 1); \n  }\n\n  public &lt;R&gt; InfiniteList&lt;R&gt; map(Transformer&lt;? super T, ? extends R&gt; mapper) {\n    return new InfiniteList&lt;&gt;(\n        () -&gt; mapper.transform(this.head()),\n        () -&gt; this.tail().map(mapper));\n  }\n}\n</code></pre> <p>Let's rewrite the statement <pre><code>evens.map(x -&gt; x + 1).map(x -&gt; x * 2).head(); // 2\n</code></pre></p> <p>into something uglier and more verbose, but with intermediate variables to help us explain what happens when the statement above is invoked.</p> <pre><code>InfiniteList&lt;Integer&gt; evens = InfiniteList.iterate(0, x -&gt; x + 2); // 0, 2, 4, 6, ...\nInfiniteList&lt;Integer&gt; odds = evens.map(x -&gt; x + 1); // 1, 3, 5, ...\nInfiniteList&lt;Integer&gt; altEvens = odds.map(x -&gt; x * 2); // 2, 6, 10, .. \naltEvens.head();\n</code></pre> <p>Let's look at what gets created on the heap when we run</p> <pre><code>InfiniteList&lt;Integer&gt; evens = InfiniteList.iterate(0, x -&gt; x + 2); // 0, 2, 4, 6, ...\n</code></pre> <p></p> <p>The figure above shows the objects created.  <code>evens</code> is an instance of <code>InfiniteList</code>, with two fields, <code>head</code> and <code>tail</code>, each pointing to an instance of <code>Producer&lt;T&gt;</code>.  The two instances of <code>Producer&lt;T&gt;</code> capture the variable <code>init</code>.  The <code>tail</code> additionally captures the variable <code>next</code>, which itself is an instance of <code>Transformer&lt;T, T&gt;</code>. </p> <p>Next, let's look at what gets created on the heap when we run</p> <pre><code>InfiniteList&lt;Integer&gt; odds = evens.map(x -&gt; x + 1); // 1, 3, 5, ...\n</code></pre> <p></p> <p>The figure above shows the objects added.  <code>odds</code> is an instance of <code>InfiniteList</code>, with two fields, <code>head</code> and <code>tail</code>, each pointing to an instance of <code>Producer&lt;T&gt;</code>.  The two instances of <code>Producer&lt;T&gt;</code> capture the local variables, <code>this</code> and <code>mapper</code>, of the method <code>map</code>.  <code>mapper</code> refers to an instance of <code>Transformer&lt;T, T&gt;</code>.  Since the method <code>map</code> of <code>evens</code> is called, the <code>this</code> reference refers to the object <code>evens</code>. </p> <p>After calling  <pre><code>InfiniteList&lt;Integer&gt; altEvens = odds.map(x -&gt; x * 2); // 2, 6, 10, .. \n</code></pre></p> <p>We have the following objects set up.</p> <p></p> <p>Let's now trace through what happens when we call <code>altEvens.head()</code>.  This method leads to the call <code>this.head.produce()</code>, where <code>this</code> refers to <code>altEvens</code>.  The call to <code>produce</code> invoked <code>mapper.transform(this.head.produce())</code> of the producer labeled 1 in the figure below.  This leads to <code>this.head.produce()</code> of this producer being called.  Within this producer, <code>this</code> refers to <code>odds</code>, and so <code>this.head.produce()</code> invoked <code>mapper.transform(this.head.produce())</code> of the producer labelled 2.   Now, <code>this</code> refers to <code>evens</code>, and <code>this.head.produce()</code> causes the producer <code>() -&gt;</code>init` (labeled 3) to produce 0.</p> <p></p> <p>The execution now returns to the invocation of <code>mapper.transform(this.head.produce())</code> and call <code>mapper.transform(0)</code> (labeled 4).  This returns the value 1, which we pass into the <code>mapper.transform(1)</code> (labeled 5).  The <code>mapper</code> is <code>x -&gt; x * 2</code> so we have the result 2, which we return from <code>altEvens.head()</code>.</p> <p>This process shows a very different order of execution than <code>EagerList</code>. If we run,  <pre><code>EagerList.iterate(0, x -&gt; x &lt; 10, x -&gt; x + 2)\n    .map(x -&gt; x + 1)\n    .map(x -&gt; x * 2)\n    .head();\n</code></pre></p> <p>The method <code>iterate</code> generates all the elements first, then all the elements get <code>map</code>-ed with <code>x -&gt; x + 1</code>, then with <code>x -&gt; x + 2</code>, and then the first element is retrieved.  </p> <p>When we run,  <pre><code>InfiniteList.iterate(0, x -&gt; x + 2)\n    .map(x -&gt; x + 1)\n    .map(x -&gt; x * 2)\n    .head();\n</code></pre></p> <p>The method calls <code>iterate</code> and <code>map</code> only set up the producers that call other producers.  The call to <code>head()</code> is the trigger that causes the chain of producers to produce a value.</p>"},{"location":"33-infinitelist.html#filtering-a-lazy-list","title":"Filtering A Lazy List","text":"<p>Filtering an <code>InfiniteList</code> is more subtle than mapping it. In an eagerly evaluated list, filtering naturally proceeds element by element until the list ends. In a lazy setting, however, neither the head nor the tail should be evaluated prematurely. A naive translation of the eager filter implementation will therefore break laziness and lead to incorrect behaviour.  The following naive version does not work.</p> <pre><code>  // wrong\n  public InfiniteList&lt;T&gt; filter(BooleanCondition&lt;? super T&gt; cond) {\n    if (cond.test(this.head())) {\n      return new InfiniteList&lt;&gt;(this.head, () -&gt; this.tail().filter(cond));\n    }\n    return this.tail().filter(cond);\n  }\n</code></pre> <p>There are two things wrong with this.  First,  Line 3 <code>cond.test(this.head()</code>)` is eager.  It computes the head to test if it passes the given condition.  Second, Line 6 is eager, it produces the tail to recursively filter it.</p> <p>To make <code>filter</code> lazy, we have to perform the test in the producer that produces the head. But if the test fails, we have to mark the head as filtered.</p> <pre><code>  public InfiniteList&lt;T&gt; filter(BooleanCondition&lt;? super T&gt; cond) {\n    Producer&lt;T&gt; newHead = () -&gt; cond.test(this.head()) ? this.head() : null;\n    return new InfiniteList&lt;&gt;(newHead, () -&gt; this.tail().filter(cond));\n  }\n</code></pre> <p>In the code above, we use <code>null</code> to indicate that the <code>head</code> is filtered for simplicity.  It is not a good practice, however, since <code>null</code> could be a valid value in an infinite list.</p> <p>Putting the abuse of <code>null</code> aside, the possibility that the head produces a value that is filtered affects other methods. The methods <code>head</code> and <code>tail</code> have to be changed to: <pre><code>  public T head() {\n    T h = this.head.produce();\n    return h == null ? this.tail.produce().head() : h;  \n  }\n\n  public InfiniteList&lt;T&gt; tail() {\n    T h = this.head.produce();\n    return h == null ? this.tail.produce().tail() : this.tail.produce();  \n  }\n</code></pre></p>"},{"location":"33-infinitelist.html#further-improvements","title":"Further Improvements","text":"<p>We have seen <code>Maybe&lt;T&gt;</code> as an abstraction that encapsulates a value that is either there or is missing.  Instead of using <code>null</code> to present a value that is not there, it is better to use <code>Maybe&lt;T&gt;</code> to encapsulate the value of the head.</p> <p>Further, our implementation of <code>InfiniteList&lt;T&gt;</code> so far does not make use of memoization.  The same value keeps getting produced repeatedly.  We have built the class <code>Lazy&lt;T&gt;</code> that encapsulates a value that is produced on-demand with memoization to guarantee that it is produced at most once.  It is better to use <code>Lazy&lt;T&gt;</code> to encapsulate the value of the head as well.</p> <p>We leave the construction of an <code>InfiniteList&lt;T&gt;</code> that uses <code>Lazy&lt;Maybe&lt;T&gt;&gt;</code> for its head as an exercise.</p>"},{"location":"34-stream.html","title":"Unit 34: Streams in Java","text":"<p>Learning Objectives</p> <p>After completing this unit, students should be able to:</p> <ul> <li>Construct and evaluate Java streams, explaining laziness and how terminal operations trigger execution. </li> <li>Use intermediate and terminal stream operations (map, filter, flatMap, limit, takeWhile, reduce, matching) to express computations declaratively. </li> <li>Reason about boundedness and statefulness of stream operations, and identify operations that are unsafe on infinite streams. </li> <li>Explain the key differences between Java Stream and InfiniteList, particularly single-use consumption and design trade-offs. </li> <li>Refactor loop-based imperative code into stream-based solutions, and judge when streams improve clarity versus when loops are more appropriate.</li> </ul> <p>Overview</p> <p>In the earlier units, we built our own functional abstractions such as <code>Lazy</code>, <code>Maybe</code>, and <code>InfiniteList</code> to understand how computation can be expressed declaratively using higher-order functions and laziness. While these abstractions helped us reason about program structure and evaluation, real Java programs rely on a richer, standardised library to work with large and potentially infinite sequences of data. In this unit, we study Java\u2019s <code>Stream</code> API, which generalises many ideas from <code>InfiniteList</code> while introducing important new constraints and capabilities, allowing us to write clearer, more expressive, and less error-prone code\u2014when used appropriately.</p>"},{"location":"34-stream.html#java-api","title":"Java API","text":"<p>Java provides its own version of functional interfaces that are comparable to ours, in the <code>java.util.function</code> package.  The table below shows some commonly used ones:</p> CS2030S java.util.function <code>BooleanCondition&lt;T&gt;::test</code> <code>Predicate&lt;T&gt;::test</code> <code>Producer&lt;T&gt;::produce</code> <code>Supplier&lt;T&gt;::get</code> <code>Consumer&lt;T&gt;::consume</code> <code>Consumer&lt;T&gt;::accept</code> <code>Transformer&lt;T, R&gt;::transform</code> <code>Function&lt;T, R&gt;::apply</code> <code>Transformer&lt;T, T&gt;::transform</code> <code>UnaryOp&lt;T&gt;::apply</code> <code>Combiner&lt;S, T, R&gt;::combine</code> <code>BiFunction&lt;S, T, R&gt;::apply</code> <p>Besides, some of the abstractions we have built have similar counterparts in Java as well:</p> CS2030S Java version <code>Box&lt;T&gt;</code> N/A <code>Maybe&lt;T&gt;</code> <code>java.util.Optional&lt;T&gt;</code> <code>Lazy&lt;T&gt;</code> N/A <code>InfiniteList&lt;T&gt;</code> <code>java.util.stream.Stream&lt;T&gt;</code> <p>We will focus this unit on <code>Stream</code> since the Java implementation of <code>Stream</code> is an infinite list with much more functionalities, some of which (such as parallel streams) are beyond what we can build ourselves in CS2030S.</p>"},{"location":"34-stream.html#building-a-stream","title":"Building a Stream","text":"<p>To start, let's see how we can build a stream object:</p> <ul> <li>We can use the static factory method <code>of</code> (e.g., <code>Stream.of(1, 2, 3)</code>)</li> <li>We can use the <code>generate</code> and <code>iterate</code> methods (similar to our <code>InfiniteList</code>)</li> <li>We can convert an array into a <code>Stream</code> using <code>Arrays::stream</code></li> <li>We can convert a <code>List</code> instance (or any <code>Collection</code> instance) into a <code>Stream</code> using <code>List::stream</code></li> </ul> <p>Many other APIs in Java return a <code>Stream</code> instance (e.g., <code>Files::lines</code>)</p>"},{"location":"34-stream.html#terminal-operations","title":"Terminal Operations","text":"<p>A <code>Stream</code> is lazy, just like <code>InfiniteList</code>.</p> <p>A terminal operation is an operation on the stream that triggers the evaluation of the stream; Without one, no computation occurs.  A typical way of writing code that operates on streams is to chain a series of intermediate operations together, ending with a terminal operation.  </p> <p>The <code>forEach</code> method is a terminal operation that takes in a stream and applies a lambda expression to each element. The lambda expression to apply does not return any value.  Java provides the <code>Consumer&lt;T&gt;</code> functional interface for this.   Typical use is <pre><code>Stream.of(1, 2, 3).forEach(System.out::println);\nStream.generate(() -&gt; 1).forEach(System.out::println); // infinite loop\n</code></pre></p>"},{"location":"34-stream.html#intermediate-stream-operations","title":"Intermediate Stream Operations","text":"<p>An intermediate operation on stream returns another <code>Stream</code>.  Java provides <code>map</code>, <code>filter</code>, <code>flatMap</code>, and other intermediate operations.  Intermediate operations are lazy and do not cause the stream to be evaluated.  </p>"},{"location":"34-stream.html#flatmapping-a-stream","title":"FlatMapping a Stream","text":"<p>You have seen <code>flatMap</code> for <code>Box&lt;T&gt;</code>, <code>Maybe&lt;T&gt;</code> and <code>Lazy&lt;T&gt;</code>.  The method <code>flatMap</code> in <code>Stream</code> behaves similarly \u2014 it takes a lambda expression that transforms every element in the stream into another stream.  The resulting stream of streams is then flattened and concatenated together.  </p> <p>For instance, <pre><code>Stream.of(\"hello\\nworld\", \"ciao\\nmondo\", \"Bonjour\\nle monde\", \"Hai\\ndunia\")\n    .map(x -&gt; x.lines()) // returns a stream of streams\n</code></pre></p> <pre><code>Stream.of(\"hello\\nworld\", \"ciao\\nmondo\", \"Bonjour\\nle monde\", \"Hai\\ndunia\")\n    .flatMap(x -&gt; x.lines()) // return a stream of strings\n</code></pre>"},{"location":"34-stream.html#stateful-and-bounded-operations","title":"Stateful and Bounded Operations","text":"<p>Some intermediate operations are stateful, i.e., they need to consider states from previously seen elements to operate.  Two examples are <code>sorted</code> and <code>distinct</code>.  In <code>distinct</code>, we need to remember all previously seen elements to determine if the current element is distinct.  In <code>sorted</code>, we need to see all elements before we can sort them.</p> <p><code>sorted</code> returns a stream with the elements in the stream sorted.  Without argument, it sorts according to the natural order as defined by implementing the <code>Comparable</code> interface.  You can also pass in a <code>Comparator</code> to tell <code>sorted</code> how to sort.</p> <p><code>distinct</code> returns a stream with only distinct elements in the stream. </p> <p><code>distinct</code> and <code>sorted</code> are also known as <code>bounded</code> operations, since they should only be called on a finite stream \u2014 calling them on an infinite stream is a bad idea!</p>"},{"location":"34-stream.html#truncating-an-infinite-list","title":"Truncating an Infinite List","text":"<p>There are several intermediate operations that convert from infinite stream to finite stream: </p> <ul> <li><code>limit</code> takes in an <code>long</code> \\(n\\) and returns a stream containing the first \\(n\\) elements of the stream;</li> <li><code>takeWhile</code> takes in a predicate and returns a stream containing the elements of the stream, until the predicate becomes false.  The resulting stream might still be infinite if the predicate never becomes false.</li> </ul> <p>For instance, </p> <pre><code>Stream.iterate(0, x -&gt; x + 1).takeWhile(x -&gt; x &lt; 5); \n</code></pre> <p>create a (lazy) finite stream of elements 0 to 4.</p>"},{"location":"34-stream.html#peeking-with-a-consumer","title":"Peeking with a <code>Consumer</code>","text":"<p>A particularly useful intermediate operation of <code>Stream</code> is <code>peek</code>.  <code>peek</code> takes in a <code>Consumer</code>, allowing us to apply a lambda on a \"fork\" of the stream.  For instance,</p> <pre><code>Stream.iterate(0, x -&gt; x + 1).peek(System.out::println).takeWhile(x -&gt; x &lt; 5).forEach(x -&gt; {});\n</code></pre>"},{"location":"34-stream.html#reducing-a-stream","title":"Reducing a Stream","text":"<p>One of the more powerful terminal operations in <code>Stream</code> is <code>reduce</code>, also known as <code>fold</code> or <code>accumulate</code> elsewhere, the <code>reduce</code> operation applies a lambda repeatedly on the elements of the stream to reduce it into a single value.  </p> <p>For instance, <pre><code>Stream.of(1, 2, 3).reduce(0, (x, y) -&gt; x + y);\n</code></pre> returns the sum of all elements in the stream.</p> <p>The method <code>reduce</code> takes in an identity value (<code>0</code> in the example above) and an accumulation function (<code>(x, y) -&gt; x + y</code> above) and returns the reduced value.  The process of reduction is equivalent to the following pseudocode:</p> <pre><code>result = identity\nfor each element in the stream\n     result = accumulator.apply(result, element)\nreturn result\n</code></pre> <p>Note that there are constraints on the identity and accumulation function, which are placed to ensure correctness when the stream is evaluated in parallel.   We will revisit this operation later.</p> <p>Java also overloaded <code>reduce</code> with two other versions \u2014 a simpler one (with <code>null</code> identity) and a more complex one, which supports a different returned type than the type of the elements in the stream.   You can read the java API for details.</p>"},{"location":"34-stream.html#element-matching","title":"Element Matching","text":"<p>Stream also provides terminal operations for testing if the elements pass a given predicate:</p> <ul> <li><code>noneMatch</code> returns true if none of the elements pass the given predicate.</li> <li><code>allMatch</code> returns true if every element passes the given predicate.</li> <li><code>anyMatch</code> returns true if at least one element passes the given predicate.</li> </ul>"},{"location":"34-stream.html#consumed-once","title":"Consumed Once","text":"<p>One of the greatest limitations of <code>Stream</code>, which does not apply to our <code>InfiniteList</code>, is that a stream can only be operated once.  We cannot iterate through a stream multiple times.  Doing so would lead to an <code>IllegalStateException</code> being thrown.  We have to recreate the stream if we want to operate on the stream more than once.</p> <p>Example, <pre><code>Stream&lt;Integer&gt; s = Stream.of(1,2,3);\ns.count();\ns.count(); // &lt;- error\n</code></pre></p>"},{"location":"34-stream.html#example-is-this-a-prime","title":"Example: Is this a prime?","text":"<p>Consider the method below, which checks if a given <code>int</code> is a prime:</p> <pre><code>boolean isPrime(int x) {\n  for (int i = 2; i &lt;= x-1; i++) {\n    if (x % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\n</code></pre> <p>Let's see how we can rewrite this with <code>Stream</code>.  Due to the overhead of wrapper classes, Java provides specialized streams on primitives: <code>IntStream</code>, <code>LongStream</code>, and <code>DoubleStream</code>, with a similar set of methods provided.  Since we are dealing with <code>int</code> here, we will use <code>IntStream</code>.  The code above can be rewritten as:</p> <pre><code>boolean isPrime(int x) {\n  return IntStream.range(2, x)\n      .noneMatch(i -&gt; x % i == 0);\n}\n</code></pre> <p>The <code>IntStream::range(x,y)</code> method generates a stream of <code>int</code> from <code>x</code> to <code>y-1</code>.</p>"},{"location":"34-stream.html#example-first-500-primes","title":"Example: First 500 primes","text":"<p>What if we want to print out the first 500 prime numbers, starting from 2?  Normally, we would do the following: <pre><code>void fiveHundredPrime() {\n  int count = 0;\n  int i = 2;\n  while (count &lt; 500) {\n    if (isPrime(i)) {\n      System.out.println(i);\n      count++;\n    }\n    i++;\n  }\n}\n</code></pre></p> <p>The code is still considered simple, and understandable for many, but I am sure some of us will encounter a bug the first time we write this (either forgot to increment the counter or put the increment in the wrong place).  If you look at the code, there are a couple of components:</p> <ul> <li>Lines 3 and 9 deal with iterating through different numbers for primality testing</li> <li>Line 5 is the test of whether a number is prime</li> <li>Lines 2, 4, and 7, deal with limiting the output to 500 primes</li> <li>Line 6 is the action to perform on the prime</li> </ul> <p>With streams, we can write it like the following: <pre><code>IntStream.iterate(2, x -&gt; x+1)\n    .filter(x -&gt; isPrime(x))\n    .limit(500)\n    .forEach(System.out::println);\n</code></pre></p> <p>Notice how each of the four components matches neatly with one operation on stream!  </p> <p>With a stream, we no longer have to write loops, we have moved the iterations to within each operation in the stream.  We no longer need to maintain states and counters, they are done within each operation as needed as well.  This has another powerful implication: our code becomes more declarative, we only need to be concerned about what we want at each step, much less about how to do it.  Doing so makes our code more succinct and less bug-prone.</p>"},{"location":"34-stream.html#caution-avoid-overusing-streams","title":"Caution: Avoid Overusing Streams","text":"<p>We will end this unit with a note of caution.</p> <p>Using streams in place of loops should make our code simpler, more elegant, and less bug-prone.  One should note that not all loops can be translated into stream elegantly.  A double-nested loop, for instance, stretches the elegance of streams.  A triple-nested loop should perhaps be best written as a loop with appropriate inner components written with lambdas and streams.</p> <p>The goal is not to replace all loops with streams, but to recognise when streams allow us to express intent more clearly and safely.</p> <p>As you go through exercises in using streams, you will find more examples of the limitations of streams.</p>"},{"location":"35-logger.html","title":"Unit 35: Loggable","text":"<p>Learning Objectives</p> <p>After completing this unit, students should be able to:</p> <ul> <li>explain why na\u00efve function composition breaks down when additional context (e.g. logging) is introduced</li> <li>construct a simple abstraction that combines a value with auxiliary information</li> <li>distinguish between <code>map</code> and <code>flatMap</code> in terms of what kinds of transformations they support</li> <li>use <code>flatMap</code> to compose computations that produce contextualised results</li> <li>generalise a concrete abstraction into a type-parameterised one using Java generics</li> </ul> <p>Overview</p> <p>In earlier units, we learned how to compose pure functions and use higher-order operations such as map to build more complex behaviour. This worked well as long as our functions only transformed values.</p> <p>In practice, however, computations often need to carry additional context, such as log messages. Once this extra information is introduced, simple function composition breaks down and map is no longer sufficient.</p> <p>In this unit, we start from a concrete logging example<sup>1</sup> and gradually build an abstraction that restores composability. Through this process, we uncover why <code>flatMap</code> is needed, where it comes from, and how it allows us to compose context-carrying computations in a disciplined way.</p>"},{"location":"35-logger.html#function-composition-with-logging","title":"Function Composition with Logging","text":"<p>In this unit, we are going to build a general abstraction step-by-step, reach a limitation, and see how <code>flatMap</code> resolves this issue.  Through this exercise, you will gain an appreciation of <code>flatMap</code>.</p> <p>Let's start with some methods that operate on <code>int</code> values.  Let's use some trivial functions so that we don't get distracted by its details.</p> <pre><code>int incr(int x) {\n  return x + 1;\n}\n\nint abs(int x) {\n  return x &gt; 0 ? x : -x;\n}\n</code></pre> <p>These methods are pure functions without side effects, they each takes one argument and produces a result. </p> <p>Just like mathematical functions, we can compose them together in arbitrary order to form more complex operations.</p> <pre><code>incr(abs(-4));\nabs(incr(incr(5)));\n</code></pre>"},{"location":"35-logger.html#loggable-with-pair","title":"<code>Loggable</code> with <code>Pair</code>","text":"<p>Suppose now we want to return not only an <code>int</code> but some additional information related to the operation on <code>int</code>.  For instance, let's suppose we want to return a string describing the operation (for logging).  Java does not support returning multiple values, so let's return a <code>Pair</code>.</p> <pre><code>Pair&lt;Integer,String&gt; incrWithLog(int x) {\n  return Pair.of(incr(x), \"; incr \" + x);\n}\n\nPair&lt;Integer,String&gt; absWithLog(int x) {\n  return Pair.of(abs(x), \"; abs \" + x);\n}\n</code></pre> <p>Now, we can no longer compose the logging methods as cleanly as before.  This is because the return value of <code>absWithLog</code> is a <code>Pair&lt;Integer, String&gt;</code> but <code>incrWithLog</code> accepts an <code>int</code> as its parameter.</p> <pre><code>incrWithLog(absWithLog(-4));  // error\n</code></pre> <p>We will need to change our methods to take in <code>Pair&lt;Integer, String&gt;</code> as the argument.</p> <pre><code>Pair&lt;Integer,String&gt; incrWithLog(Pair&lt;Integer,String&gt; p) {\n  return Pair.of(incr(p.first), p.second + \"; incr \" + p.first);\n}\n\nPair&lt;Integer,String&gt; absWithLog(Pair&lt;Integer,String&gt; p) {\n  return Pair.of(abs(p.first), p.second + \"; abs \" + p.first);\n}\n</code></pre> <p>We can now compose the methods. <pre><code>incrWithLog(absWithLog(Pair.of(-4, \"\"))); \n</code></pre></p>"},{"location":"35-logger.html#loggable-class","title":"<code>Loggable</code> Class","text":"<p>Let's do it in a more OO way, by writing a class to replace <code>Pair</code>.</p> Loggable v0.1<pre><code>class Loggable {\n  private final int value;\n  private final String log;\n\n  private Loggable(int value, String log) {\n    this.value = value;\n    this.log = log;\n  }\n\n  public static Loggable of(int value) {\n    return new Loggable(value, \"\");\n  }\n\n  Loggable incrWithLog() {\n    return new Loggable(incr(this.value), this.log + \"; incr \" + this.value);\n  }\n\n  Loggable absWithLog() {\n    return new Loggable(abs(this.value), this.log + \"; abs \" + this.value);\n  }\n\n  public String toString() {\n    return \"value: \" + this.value + \", log: \" + this.log;\n  }\n}\n</code></pre> <p>We can use the class above as follows: <pre><code>Loggable x = Loggable.of(4);\nLoggable z = x.incrWithLog().absWithLog();\n</code></pre></p> <p>Note that we can now chain the methods together to compose them.  Additionally, the log messages get passed from one call to another and get \"composed\" as well.</p>"},{"location":"35-logger.html#making-loggable-general","title":"Making <code>Loggable</code> general","text":"<p>There are many possible operations on <code>int</code>, and we do not want to add a method <code>fooWithLog</code> for every function <code>foo</code>.  One way to make <code>Loggable</code> general is to abstract out the <code>int</code> operation and provide that as a lambda expression to <code>Loggable</code>.  This is what the <code>map</code> method does. </p> <pre><code>  Loggable map(Transformer&lt;Integer,Integer&gt; transformer) {\n    return new Loggable(transformer.transform(this.value), this.log); \n  }\n</code></pre> <p>We can use it like this: <pre><code>Loggable.of(4).map(x -&gt; incr(x)).map(x -&gt; abs(x))\n</code></pre></p> <p>We can still chain the methods together to compose them.</p> <p>However, <code>map</code> only allows us to apply the function to the value.  What should we do to the log messages?  Since the given lambda returns an int, it is not sufficient to tell us what message we want to add to the log.</p> <p>To fix this, we will need to pass in a lambda expression that takes in an integer but returns us a pair of an integer and a string.  In other words, it returns us a <code>Loggable</code>.  We call our new method <code>flatMap</code>.</p> <pre><code>  Loggable flatMap(Transformer&lt;Integer,Loggable&gt; transformer) {\n    Loggable l = transformer.transform(this.value);\n    return new Loggable(l.value, l.log + this.log); \n  }\n</code></pre> <p>Note that the log from the new computation is prepended to the existing log to preserve execution order.</p> <p>By making <code>flatMap</code> take in a lambda that returns a pair of an integer and a string, <code>Loggable</code> can rely on these lambda expressions to tell it how to update the log messages.  Now, if we have methods like this:</p> <pre><code>Loggable incrWithLog(int x) {\n  return new Loggable(incr(x), \"; incr \" + x);\n}\n\nLoggable absWithLog(int x) {\n  return new Loggable(abs(x), \"; abs \" + x);\n}\n</code></pre> <p>We can write: <pre><code>Loggable.of(4)\n        .flatMap(x -&gt; incrWithLog(x))\n        .flatMap(x -&gt; absWithLog(x))\n</code></pre></p> <p>to now compose the methods <code>incr</code> and <code>abs</code> together, along with the log messages!</p>"},{"location":"35-logger.html#making-loggable-more-general","title":"Making <code>Loggable</code> More General","text":"<p>We started with an operation on <code>int</code>, but our <code>Loggable</code> class is fairly general and should be able to add a log message to any operation of any type.  We can make it so by making <code>Loggable</code> a generic class.</p> Loggable v0.2 (Generic with flatMap)<pre><code>class Loggable&lt;T&gt; {\n  private final T value;\n  private final String log;\n\n  private Loggable(T value, String log) {\n    this.value = value;\n    this.log = log;\n  }\n\n  public static &lt;T&gt; Loggable&lt;T&gt; of(T value) {\n    return new Loggable&lt;&gt;(value, \"\");\n  }\n\n  public &lt;R&gt; Loggable&lt;R&gt; flatMap(Transformer&lt;? super T, ? extends Loggable&lt;? extends R&gt;&gt; transformer) {\n    Loggable&lt;? extends R&gt; l = transformer.transform(this.value);\n    return new Loggable&lt;&gt;(l.value, l.log + this.log);\n  }\n\n  public String toString() {\n    return \"value: \" + this.value + \", log: \" + this.log;\n  }\n}\n</code></pre> <ol> <li> <p>This note is inspired by The Best Introduction to Monad. Another excellent note on category theory is by Bartosz Milewski \u21a9</p> </li> </ol>"},{"location":"36-monad.html","title":"Unit 36: Monad","text":"<p>Learning Objectives</p> <p>After this unit, students should be able to:</p> <ul> <li>recognize common structural patterns shared by <code>Maybe&lt;T&gt;</code>, <code>Lazy&lt;T&gt;</code>, <code>InfiniteList&lt;T&gt;</code>, and <code>Loggable&lt;T&gt;</code></li> <li>explain the role of <code>of</code>, <code>map</code>, and <code>flatMap</code> in structuring computations with side information</li> <li>state and apply the monad laws (left identity, right identity, associativity)</li> <li>reason about why violating these laws leads to unintuitive or unsafe behavior</li> <li>distinguish between functors and monads, and relate them to abstractions seen earlier in the course</li> </ul> <p>Overview</p> <p>In earlier units, we introduced abstractions such as <code>Maybe&lt;T&gt;</code>, <code>Lazy&lt;T&gt;</code>, and <code>InfiniteList&lt;T&gt;</code> to structure computations that may fail, be deferred, or be infinite. Although these classes appear different, they all support a similar style of programming: values are wrapped together with additional information, and computations are chained using methods like map and flatMap.</p> <p>In this unit, we step back and study the common pattern behind these abstractions. We formalize what it means for such classes to be well behaved, introducing the notion of monads and the laws they must obey. Understanding these laws explains why our earlier designs work, why some seemingly small changes can break them, and how these ideas generalize beyond Java to other programming languages and paradigms.</p>"},{"location":"36-monad.html#generalizing-loggablet","title":"Generalizing <code>Loggable&lt;T&gt;</code>","text":"<p>We now have a class <code>Loggable&lt;T&gt;</code> with a <code>flatMap</code> method that allows us to operate on the value encapsulated inside, along with some \"side information\".  <code>Loggable&lt;T&gt;</code> follows a pattern that we have seen many times before.  We have seen this in <code>Maybe&lt;T&gt;</code> and <code>Lazy&lt;T&gt;</code>, and <code>InfiniteList&lt;T&gt;</code>.  Each of these classes has:</p> <ul> <li>an <code>of</code> method to initialize the value and side information.</li> <li>a <code>flatMap</code> method to update the value and side information.</li> </ul> <p>Different classes above have different side information that is initialized, stored, and updated when we use the <code>of</code> and <code>flatMap</code> operations.  The class may also have other methods besides the two above.  Additionally, the methods may have different names.</p> Container Side-Information <code>Maybe&lt;T&gt;</code> The value might be there (i.e., <code>Some&lt;T&gt;</code>) or might not be there (i.e., <code>None</code>) <code>Lazy&lt;T&gt;</code> The value has been evaluated or not <code>Loggable&lt;T&gt;</code> The log describing the operations done on the value <p>These classes follow certain patterns that make them well-behaved.  In particular, they behave predictably when created with <code>of</code> and chained with <code>flatMap</code>.  Such \"well-behaved\" classes are examples of a programming construct called monads.  </p>"},{"location":"36-monad.html#identity-element-of-binary-operations","title":"Identity Element of Binary Operations","text":"<p>Before we examine what \"well behaved\" means, we first take a brief detour to look at algebraic structures in mathematics, particularly on the concept of identity element of a binary operation.</p> <p>Let's consider the addition operation \\(+\\) on integers.  We know that \\(+\\) is a binary operation that takes in two integers and produces another integer.  For any integer \\(x\\), \\(0 + x = x\\) and \\(x + 0 = x\\).  The integer \\(0\\) is called the identity element of the binary operation \\(+\\), because adding \\(0\\) to any integer \\(x\\) does not change the value of \\(x\\).</p> <p>Similarly, for the multiplication operation \\(\\times\\) on integers, we know that for any integer \\(x\\), \\(1 \\times x = x\\) and \\(x \\times 1 = x\\).  The integer \\(1\\) is the identity element of the binary operation \\(\\times\\). </p> <p>Now, consider the exponentiation operation on integers.  For any integer \\(x\\), we have \\(x^1 = x\\), but it is not true that \\(1^x = x\\) (unless \\(x\\) is 1).  So, 1 behaves like an identity element only when it is on the right side of the operation, but not on the left side.  In this case, we say that the 1 is the right identity of exponentiation, but not the left identity.  </p> <p>On the other hand, 0 is both the left and right identity of \\(+\\); 1 is both the left and right identity of \\(\\times\\).</p>"},{"location":"36-monad.html#algebraic-view-of-of-and-flatmap","title":"Algebraic View of <code>of</code> and <code>flatMap</code>","text":"<p>To help with the explanation below, we will now view a monad as a pair \\((x, c)\\), where \\(x\\) is the value and \\(c\\) is the side information.  </p> <p>The argument to <code>flatMap</code> is a lambda that maps \\(i\\) to \\((f(i), c_f)\\), where \\(f(i)\\) is the new value and \\(c_f\\) is the new side information produced by applying the lambda to \\(i\\).  The <code>flatMap</code> method applies the lambda to a target monad \\((x, c)\\) to produce a new monad \\((f(x), c \\oplus c_f)\\), where \\(\\oplus\\) is an operation that combines the side information.</p> <p>Notationally, we write the <code>flatMap</code> operation as:</p> \\[(x, c) \\text{ flatMap } \\bigl(i \\rightarrow (f(i), c_f)\\bigr) = \\bigl(f(x), c \\oplus c_f\\bigr)\\] <p>As a concrete example, consider the <code>Maybe&lt;T&gt;</code> monad. Here, the side information is whether the value is present or not.  The operation \\(\\oplus\\) is defined such that if either side information indicates absence of value (<code>false</code>), the combined side information also indicates absence of value (<code>false</code>).  If both side information indicates the presence of value (<code>true</code>), the combined side information also indicates the presence of value (<code>true</code>).  In other words, \\(\\oplus\\) is the AND operation on binary values.</p> <p>The <code>Loggable&lt;T&gt;</code> monad, on the other hand, has side information as a log string.  The operation \\(\\oplus\\) is string concatenation.</p> <p>The <code>of</code> method of a monad takes a value and creates a new monad instance that encapsulates the value and initialize the side information.  We can view <code>of</code> as a function that maps from a value \\(x\\) to a monad \\((x, c_0)\\), where \\(c_0\\) is the initialized side information.</p>"},{"location":"36-monad.html#identity-laws","title":"Identity Laws","text":"<p>For a monad to be well-behaved, it must obey certain laws.  The first two laws are about identity.  It says that the initialized side information \\(c_0\\) must be both the left identity and the right identity of the corresponding \\(\\oplus\\) operation on the side information.</p> <p>For instance, in our <code>Loggable&lt;T&gt;</code>, <pre><code>public static &lt;T&gt; Loggable&lt;T&gt; of(T value) {\n  return new Loggable&lt;&gt;(value, \"\");\n}\n</code></pre></p> <p>The logger is initialized with empty side information (e.g., empty string as a log message).  The empty string is the identity of string concatenation, because for any string <code>s</code>, <code>\"\" + s = s</code> and <code>s + \"\" = s</code>.</p> <p>Now, let's consider the lambda that we wish to pass into <code>flatMap</code>  \u2014 such a lambda takes in a value, computes it, and wraps it in a \"new\" monad, together with the corresponding side information.  For instance,</p> <pre><code>Loggable&lt;Integer&gt; incrWithLog(int x) {\n  return new Loggable&lt;&gt;(incr(x), \"incr \" + x + \"; \");\n}\n</code></pre> <p>What should we expect when we take a fresh new monad <code>Loggable.of(4)</code> and call <code>flatMap</code> with a function <code>incrWithLog</code>?  Since <code>Loggable.of(4)</code> is new with no operation performed on it yet, calling  <pre><code>Loggable.of(4).flatMap(x -&gt; incrWithLog(x)) \n</code></pre></p> <p>should result in the same value exactly as calling <code>incrWithLog(4)</code>.  So, we expect that, after calling the above, we have a <code>Loggable</code> with a value of 5 and a log message of <code>\"incr 4\"</code>.</p> <p>Our <code>of</code> method should not do anything extra to the value and side information \u2014 it should simply wrap the value 4 into the <code>Loggable</code>.  Our <code>flatMap</code> method should not do anything extra to the value and the side information, it should simply apply the given lambda expression to the value.</p> <p>Now, suppose we take an instance of <code>Loggable</code>, called <code>logger</code>, that has already been operated on one or more times with <code>flatMap</code>, and contains some side information.  What should we expect when we call: <pre><code>logger.flatMap(x -&gt; Loggable.of(x))\n</code></pre></p> <p>Since <code>of</code> should initialize the side information as the identity, it should not change the given side information.  The <code>flatMap</code> above should do nothing and the expression above should be the same as <code>logger</code>.</p> <p>What we have described above is called the left identity law and the right identity law of monads.  Using the notations earlier, </p> <p>The left identity law says:</p> \\[(x, c_0) \\text{ flatMap } \\bigl(i \\rightarrow (f(i), c)\\bigr) = (f(x), c)\\] <p>The right identity law says:</p> \\[(x, c) \\text{ flatMap } \\bigl(i \\rightarrow (i, c_0)\\bigr) = (x, c)\\] <p>The laws above hold because \\(c_0 \\oplus c = c\\) and \\(c \\oplus c_0 = c\\).</p> <p>To express this in Java, let <code>Monad</code> be a type that is a monad and <code>monad</code> be an instance of it.</p> <p>The left identity law says:</p> <ul> <li><code>Monad.of(x).flatMap(i -&gt; f(i))</code> must be the same as <code>f(x)</code></li> </ul> <p>The right identity law says:</p> <ul> <li><code>monad.flatMap(i -&gt; Monad.of(i))</code> must be the same as <code>monad</code></li> </ul>"},{"location":"36-monad.html#maybe-is-partially-well-behaved","title":"Maybe is Partially Well-Behaved <p>We have seen that <code>Loggable&lt;T&gt;</code> obey the identity laws, with \\(\\oplus\\) being the string concatenation and the identity \\(c_0\\) being the empty string.  <code>Maybe&lt;T&gt;</code> also obeys the identity laws, with \\(\\oplus\\) being the AND operation on binary values and \\(c_0\\) being <code>true</code> (indicating presence of value).</p> <p>Now consider <code>Maybe&lt;T&gt;</code>.  We have seen that \\(\\oplus\\) is the AND operation on binary values.  The AND operation has <code>true</code> as its identity, but not <code>false</code>.  This means that <code>Maybe&lt;T&gt;</code> only obeys the identity laws only when the initialized side information is <code>true</code>, i.e., when we create a <code>Some&lt;T&gt;</code> instance.  If we create a <code>None</code> instance, the identity laws do not hold.  </p> <p>For instance, <code>Maybe.none().flatMap(x -&gt; f(x))</code> equals to <code>Maybe.none()</code>, which is not always the same as <code>f(x)</code>.</p> <p>In other words, <code>Maybe&lt;T&gt;</code> is a monad with respect to <code>Maybe::some</code> and <code>Maybe::flatMap</code> operations, but not with respect to <code>Maybe::none</code> and <code>Maybe::flatMap</code>.</p>","text":""},{"location":"36-monad.html#associative-law","title":"Associative Law <p>We now return to the original <code>incr</code> and <code>abs</code> functions.  To compose the functions, we can write <code>abs(incr(x))</code>, explicitly one function after another.  Or we can compose them as another function:  <pre><code>int absIncr(int x) {\n  return abs(incr(x));\n}\n</code></pre></p> <p>and call it <code>absIncr(x)</code>.  The effects should be exactly the same.  It does not matter if we group the functions together into another function before applying it to a value x.</p> <p>Recall that after we built our <code>Loggable</code> class, we were able to compose the functions <code>incr</code> and <code>abs</code> by chaining the <code>flatMap</code>:</p> <pre><code>Loggable.of(4)\n        .flatMap(x -&gt; incrWithLog(x))\n        .flatMap(x -&gt; absWithLog(x))\n</code></pre> <p>We should get the resulting value as <code>abs(incr(4))</code>, along with the appropriate log messages.</p> <p>Another way to call <code>incr</code> and then <code>abs</code> is to write something like this: <pre><code>Loggable&lt;Integer&gt; absIncrWithLog(int x) {\n  return incrWithLog(x).flatMap(y -&gt; absWithLog(y));\n}\n</code></pre></p> <p>We have composed the methods <code>incrWithLog</code> and <code>absWithLog</code> and grouped them under another method.  Now, if we call: <pre><code>Loggable.of(4)\n    .flatMap(x -&gt; absIncrWithLog(x))\n</code></pre></p> <p>The two expressions above must have exactly the same effect on the value and its log message.</p> <p>This example leads us to the third law of monads: regardless of how we group those calls to <code>flatMap</code>, their behavior must be the same.  This law is called the associative law.  Using our notations earlier, the law says:</p> \\[\\begin{aligned} \\bigl((x, c) \\text{ flatMap } (i \\rightarrow (f(i), c_f))\\bigr) \\text{ flatMap } (j \\rightarrow (g(j), c_g) =\\\\  (x, c) \\text{ flatMap } (i \\rightarrow \\bigl((f(i), c_f) \\text{ flatMap } (j \\rightarrow (g(j), c_g)\\bigr)) \\end{aligned} \\] <p>If we unpack the notations above, we have the left hand side as:</p> \\[ \\begin{aligned} \\bigl((x, c) \\;\\text{flatMap}\\; (i \\to (f(i), c_f))\\bigr) \\;\\text{flatMap}\\; (j \\to (g(j), c_g)) &amp;= {}\\\\ (f(x), c \\oplus c_f) \\;\\text{flatMap}\\; (j \\to (g(j), c_g)) &amp;= {}\\\\ (g(f(x)), (c \\oplus c_f) \\oplus c_g)  \\end{aligned} \\] <p>and the right hand side as:</p> \\[ \\begin{aligned} (x, c) \\;\\text{flatMap}\\;   \\bigl(i \\to ((f(i), c_f) \\;\\text{flatMap}\\; (j \\to (g(j), c_g)))\\bigr) &amp;= \\\\   (x, c) \\;\\text{flatMap}\\; \\bigl(i \\to (g(f(i)), c_f \\oplus c_g)\\bigr) &amp;= \\\\   (g(f(x)), c \\oplus (c_f \\oplus c_g)) \\end{aligned} \\] <p>For both sides to be equivalent, the \\(\\oplus\\) operation on the side information must be associative, i.e., </p> \\[(c_1 \\oplus c_2) \\oplus c_3 = c_1 \\oplus (c_2 \\oplus c_3)\\] <p>Expressing it in Java, the law is:</p> <ul> <li><code>monad.flatMap(x -&gt; f(x)).flatMap(x -&gt; g(x))</code> must be the same as <code>monad.flatMap(x -&gt; f(x).flatMap(y -&gt; g(y)))</code></li> </ul> <p>In our examples, <code>Loggable&lt;T&gt;</code> is well-behaved, since string concatenation is associative.  <code>Maybe&lt;T&gt;</code> is also well-behaved, since the AND operation on binary values is associative.</p>","text":""},{"location":"36-monad.html#a-counter-example","title":"A Counter Example <p>Let's see why following the laws are important.</p> <p>If our monads follow the laws above, we can safely write methods that receive a monad from others, operate on it, and return it to others.  We can also safely create a monad and pass it to the clients to operate on.  Our clients can then call our methods in any order and operate on the monads that we create, and the effect on its value and side information is as expected.</p> <p>Let's try to make our <code>Loggable</code> misbehave a little.  Suppose we change our <code>Loggable&lt;T&gt;</code> to be as follows:</p> <pre><code>// version 0.3 (NOT a monad)\nclass Loggable&lt;T&gt; {\n  private final T value;\n  private final String log;\n\n  private Loggable(T value, String log) {\n    this.value = value;\n    this.log = log;\n  }\n\n  public static &lt;T&gt; Loggable&lt;T&gt; of(T value) {\n    return new Loggable&lt;&gt;(value, \"Logging starts: \");\n  }\n\n  public &lt;R&gt; Loggable&lt;R&gt; flatMap(Transformer&lt;? super T, ? extends Loggable&lt;? extends R&gt;&gt; transformer) {\n    Loggable&lt;? extends R&gt; logger = transformer.transform(this.value);\n    return new Loggable(logger.value, logger.log + this.log + \"\\n\");\n  }\n\n  public String toString() {\n    return \"value: \" + this.value + \", log: \" + this.log;\n  }\n}\n</code></pre> <p>Our <code>of</code> adds a little initialization message.  Our <code>flatMap</code> adds a little new line before appending with the given log message.  Now, our <code>Loggable&lt;T&gt;</code> is not that well-behaved anymore.</p> <p>Suppose we have two methods <code>foo</code> and <code>bar</code>, both take in an <code>x</code> and perform a series of operations on <code>x</code>.  Both return us a <code>Loggable</code> instance on the final value and its log.</p> <pre><code>Loggable&lt;Integer&gt; foo(int x) {\n  return Loggable.of(x)\n                 .flatMap(...)\n                 .flatMap(...)\n                   :\n  ;\n}\nLoggable&lt;Integer&gt; bar(int x) {\n  return Loggable.of(x)\n                 .flatMap(...)\n                 .flatMap(...)\n                   :\n  ;\n}\n</code></pre> <p>Now, we want to perform the sequence of operations done in <code>foo</code>, followed by the sequence of operations done in <code>bar</code>.  So we called: <pre><code>foo(4).flatMap(x -&gt; bar(x))\n</code></pre></p> <p>We will find that the string <code>\"Logging starts\"</code> appears twice in our logs and there is now an extra blank line in the log file!</p>","text":""},{"location":"36-monad.html#functors","title":"Functors <p>We will end this unit with a brief discussion on functors, another common abstraction in functional-style programming.  A functor is a simpler construction than a monad in that it only ensures lambdas can be applied sequentially to the value, without worrying about side information.</p> <p>Recall that when we build our <code>Loggable&lt;T&gt;</code> abstraction, we add a <code>map</code> that only updates the value but changes nothing to the side information, i.e.,</p> \\[(x, c) map (i \\rightarrow f(i)) = (f(i), c)\\] <p>One can think of a functor as an abstraction that supports <code>map</code>.</p> <p>A functor needs to adhere to two laws:</p> <ul> <li>preserving identity: <code>functor.map(x -&gt; x)</code> is the same as <code>functor</code></li> <li>preserving composition: <code>functor.map(x -&gt; f(x)).map(x -&gt; g(x))</code> is the same as <code>functor.map(x -&gt; g(f(x))</code>. </li> </ul> <p>Our classes from <code>cs2030s.fp</code>, <code>Lazy&lt;T&gt;</code>, <code>Maybe&lt;T&gt;</code>, and <code>InfiniteList&lt;T&gt;</code> are functors as well.</p>","text":""},{"location":"36-monad.html#monads-and-functors-in-other-languages","title":"Monads and Functors in Other Languages <p>Although we have explored monads through Java, monads are a language-independent abstraction for structuring computations that carry additional context or effects.</p> <p>In purely functional languages such as Haskell, monads play a central role. Because functions in Haskell are not allowed to produce side effects directly, monads provide a disciplined way to model effects such as failures, state, and input/output.  In other languages such as Scala, monads appear in everyday programming.  Collections, futures, and other abstractions support operations analogous to <code>map</code> and <code>flatMap</code>, allowing programmers to write chained computations in a clear, imperative-looking style, while still relying on the same monadic laws underneath.</p> <p>From a broader perspective, monads represent a shift in how we think about program design. Instead of scattering special cases, flags, or global state throughout our code, we localize complexity inside a well-defined abstraction. The monad laws then act as a contract, ensuring that code remains composable and refactorable.</p>","text":""},{"location":"37-parallel.html","title":"Unit 37: Parallel Streams","text":"<p>Learning Objectives</p> <p>After completing this unit, students should be able to:</p> <ul> <li>explain the difference between sequential, concurrent, and parallel execution</li> <li>identify when stream computations can be safely parallelized</li> <li>use Java parallel streams correctly, including ordered and unordered operations</li> <li>reason about correctness issues such as interference, state, and side effects</li> <li>evaluate the performance trade-offs of parallel stream execution</li> </ul> <p>Overview</p> <p>In earlier units, we focused on using abstraction, immutability, and the Stream API to write programs that are declarative, compositional, and easy to reason about. So far, however, all our stream pipelines have executed sequentially\u2014each element processed one at a time on a single thread.</p> <p>Modern computers rarely operate this way. They provide multiple cores and hardware support for running tasks concurrently and in parallel. To fully leverage this computational power, programmers must understand not only how to run computations in parallel, but also when doing so is correct and beneficial.</p> <p>In this unit, we extend our study of streams by introducing parallel streams in Java. You will see how a small change to a stream pipeline can enable parallel execution, why this works naturally for some computations but not others, and how issues such as state, side effects, and ordering affect both correctness and performance. This unit brings together ideas from earlier discussions on immutability, side effects, and functional-style programming, and shows how they become essential when programs run in parallel.</p>"},{"location":"37-parallel.html#parallel-and-concurrent-programming","title":"Parallel and Concurrent Programming","text":"<p>The programs that we have written in CS2030S so far execute sequentially.  At any one time, there is only one instruction of the program running on a processor.</p> <p> </p>"},{"location":"37-parallel.html#what-is-concurrency","title":"What is Concurrency?","text":"<p>A single-core processor can only execute one instruction at one time \u2014 this means that only one process (or less precisely speaking, one application) can run at a time.  Yet, when we use the computer, it appears as though multiple processes are running simultaneously.  The operating system, behind the scenes, is switching between the different processes, to give the user the illusion that they are running at the same time.</p> <p> </p> <p>We can write a program so that it runs concurrently \u2014 by dividing the computation into subtasks called threads. Such multi-thread programs are useful in two ways: (i) it allows us, the programmers, to separate unrelated tasks into threads, and write each thread separately; (ii) it improves the utilization of the processor.  For instance, if I/O is in one thread, and UI rendering is in another, then when the processor is waiting for I/O to complete, it can switch to the rendering thread to make sure that the slow I/O does not affect the responsiveness of UI.</p>"},{"location":"37-parallel.html#what-is-parallelism","title":"What is Parallelism?","text":"<p>While concurrency gives the illusion of subtasks running at the same time, parallel computing refers to the scenario where multiple subtasks are truly running at the same time \u2014 either we have a processor that is capable of running multiple instructions at the same time, or we have multiple cores/processors and dispatch the instructions to the cores/processors so that they are executed at the same time.</p> <p> </p> <p>All parallel programs are concurrent, but not all concurrent programs are parallel.</p> <p>Modern computers have more than one core/processor<sup>1</sup>.  As such, the line between parallelism and concurrency is blurred.</p>"},{"location":"37-parallel.html#parallel-computing","title":"Parallel Computing","text":"<p>Parallel computing is one of the major topics in computer science.  One can teach a whole course (or a focus area) on this topic alone.  The goal of this lecture is not to cover it in-depth but is to expose students in CS2030S to the concept of parallel computing in relation to the Stream abstraction in Java.</p>"},{"location":"37-parallel.html#parallel-stream","title":"Parallel Stream","text":"<p>We have seen that the Java <code>Stream</code> class is a powerful and useful class for processing data in a declarative style.  But, we have not fully unleashed the power of <code>Stream</code>.  The neatest thing about <code>Stream</code> is that it allows parallel operations on the elements of the stream in one single line of code.</p> <p>Let's consider the following program that prints out all the prime numbers between 2,030,000 and 2,040,000.</p> <pre><code>IntStream.range(2_030_000, 2_040_000)\n         .filter(x -&gt; isPrime(x))\n         .forEach(System.out::println);\n</code></pre> <p>We can parallelize the code by adding the call <code>parallel()</code> into the stream.</p> <pre><code>IntStream.range(2_030_000, 2_040_000)\n         .filter(x -&gt; isPrime(x))\n         .parallel()\n         .forEach(System.out::println);\n</code></pre> <p>You may observe that the output has been reordered, although the same set of numbers are still being produced.  This is because <code>Stream</code> has broken down the numbers into subsequences, and run <code>filter</code> and <code>forEach</code> for each subsequence in parallel.  Since there is no coordination among the parallel tasks on the order of the printing, whichever parallel tasks that complete first will output the result to screen first, causing the sequence of numbers to be reordered.</p> <p>If you want to produce the output in the order of input, use <code>forEachOrdered</code> instead of <code>forEach</code>, we will lose some benefits of parallelization because of this.</p> <p>Suppose now that we want to compute the number of primes between 2,030,000 and 2,040,000.  We can run:</p> <pre><code>IntStream.range(2_030_000, 2_040_000)\n         .filter(x -&gt; isPrime(x))\n         .parallel()\n         .count();\n</code></pre> <p>The code above produces the same output regardless if it is being parallelized or not.</p> <p>Note that the task above is stateless and does not produce any side effects.  Furthermore, each element is processed individually without depending on other elements.  Such computation is sometimes known as embarrassingly parallel.  The only communication needed for each of the parallel subtasks is to combine the result of <code>count()</code> from the subtasks into the final count (which has been implemented internally in <code>Stream</code>).</p>"},{"location":"37-parallel.html#how-to-parallelize-a-stream","title":"How to Parallelize a Stream","text":"<p>You have seen that adding <code>parallel()</code> to the pipeline of calls in a stream enables parallel processing of the stream.  Note that <code>parallel()</code> is a lazy operation \u2014 it merely marks the stream to be processed in parallel.  As such, you can insert the call to <code>parallel()</code> anywhere in the pipeline after the data source and before the terminal operation.</p> <p>sequential()</p> <p>There is a method <code>sequential()</code> which marks the stream to be process sequentially.  If you call both <code>parallel()</code> and <code>sequential()</code> in a stream, only the last call has an effect.  The example below processes the stream  sequentially: <pre><code>s.parallel().filter(x -&gt; x &lt; 0).sequential().forEach(..); \n</code></pre></p> <p>Another way to create a parallel stream is to call the method <code>parallelStream()</code> instead of <code>stream()</code> of the <code>Collector</code> class.  Doing so would create a stream that will be processed in parallel from the collection.</p>"},{"location":"37-parallel.html#what-can-be-parallelized","title":"What Can be Parallelized?","text":"<p>To ensure that the output of the parallel execution is correct, the stream operations must not interfere with the stream data, and most of the time must be stateless.  Side-effects should be kept to a minimum.</p>"},{"location":"37-parallel.html#interference","title":"Interference","text":"<p>Interference means that one of the stream operations modifies the source of the stream during the execution of the terminal operation.  For instance:</p> <pre><code>List&lt;String&gt; list = new ArrayList&lt;&gt;(List.of(\"Luke\", \"Leia\", \"Han\"));\nlist.stream()\n    .peek(name -&gt; {\n         if (name.equals(\"Han\")) {\n           list.add(\"Chewie\"); // they belong together\n         }\n      })\n    .forEach(i -&gt; {});\n</code></pre> <p>would cause <code>ConcurrentModificationException</code> to be thrown.  Note that this non-interference rule applies even if we are using <code>stream()</code> instead of <code>parallelStream()</code>.</p>"},{"location":"37-parallel.html#stateful-vs-stateless","title":"Stateful vs. Stateless","text":"<p>A stateful lambda is one where the result depends on any state that might change during the execution of the stream.</p> <p>For instance, the <code>generate</code> and <code>map</code> operations below are stateful, since they depend on the state of the standard input. Parallelizing this may lead to incorrect output.  To ensure that the output is correct, additional work needs to be done to ensure that state updates are visible to all parallel subtasks.</p> <pre><code>Stream.generate(scanner::nextInt)\n    .map(i -&gt; i + scanner.nextInt())\n    .forEach(System.out::println)\n</code></pre>"},{"location":"37-parallel.html#side-effects","title":"Side Effects","text":"<p>Side-effects can lead to incorrect results in parallel execution.  Consider the following code:</p> <pre><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;(\n    Arrays.asList(1,3,5,7,9,11,13,15,17,19));\nList&lt;Integer&gt; result = new ArrayList&lt;&gt;();\nlist.parallelStream()\n    .filter(x -&gt; isPrime(x))\n    .forEach(x -&gt; result.add(x));\n</code></pre> <p>The <code>forEach</code> lambda generates a side effect \u2014 it modifies <code>result</code>.  <code>ArrayList</code> is what we call a non-thread-safe data structure.  If two threads manipulate it at the same time, an incorrect result may result.</p> <p>There are three ways to resolve this.  One, we can use the <code>.collect</code> method. <pre><code>list.parallelStream()\n    .filter(x -&gt; isPrime(x))\n    .collect(Collectors.toList())\n</code></pre></p> <p>Second, we can use a thread-safe data structure.  Java provides several in <code>java.util.concurrent</code> package, including <code>CopyOnWriteArrayList</code>.</p> <pre><code>List&lt;Integer&gt; result = new CopyOnWriteArrayList&lt;&gt;();\nlist.parallelStream()\n    .filter(x -&gt; isPrime(x))\n    .forEach(x -&gt; result.add(x));\n</code></pre> <p>Lastly, in Java 21, there is a <code>.toList</code> method that simply returns a list in the same order as the stream. <pre><code>list.parallelStream()\n    .filter(x -&gt; isPrime(x))\n    .toList()\n</code></pre></p>"},{"location":"37-parallel.html#associativity","title":"Associativity","text":"<p>The <code>reduce</code> operation is inherently parallelizable.  Java provides three versions of <code>reduce</code> in <code>Stream</code>'s API. </p> <ul> <li>A <code>reduce</code> that takes in a single accumulator, using <code>null</code> as the identity.</li> <li>A <code>reduce</code> that takes in an identity and an accumulator.</li> <li>A <code>reduce</code> that takes in an identity, an accumulator, and a combiner.</li> </ul> <p>With the most-general, three-parameter version of <code>reduce</code> allowing <code>reduce</code> to return a different type than the type of the elements in the stream.   The <code>combiner</code> here is useful for parallel reduction.  While the <code>accumulator</code> is used to reduce each sub-stream, the <code>combiner</code> is used to combine the partial results from the different sub-streams into the final result.  </p> <p>Consider this example:</p> <pre><code>Stream.of(1,2,3,4).reduce(1, (x, y) -&gt; x * y, (x, y) -&gt; x * y);\n</code></pre> <p>In the case of two-parameter <code>reduce</code>, the <code>accumulator</code> is used both to reduce each sub-stream as well as to combine the partial results.</p> <p>For parallel streams, the result of <code>reduce</code> must be independent of how the stream is partitioned into sub-streams and the order in which the partial results are combined.  The result of parallel <code>reduce</code> must be the same as sequential <code>reduce</code>.</p> <p>To achieve this, the Java documentation gives are several rules that the <code>identity</code>, the <code>accumulator</code>, and the <code>combiner</code> must follow:</p> <ul> <li><code>combiner.apply(identity, i)</code> must be equal to <code>i</code>.</li> <li>The <code>combiner</code> and the <code>accumulator</code> must be associative \u2014 the order of applying must not matter.</li> <li>The <code>combiner</code> and the <code>accumulator</code> must be compatible \u2014 <code>combiner.apply(u, accumulator.apply(identity, t))</code> must equal to <code>accumulator.apply(u, t)</code></li> </ul> <p>The multiplication example above meets the three rules:</p> <ul> <li><code>i * 1</code> equals <code>i</code></li> <li><code>(x * y) * z</code> equals <code>x * (y * z)</code></li> <li><code>u * (1 * t)</code> equals <code>u * t</code></li> </ul> <p>Let's try to understand why the <code>accumulator</code> should be associative.  In the context of a two-parameter <code>reduce</code> API, the <code>accumulator</code> is used as the <code>combiner</code> as well.  To be able to combine partial results, we need the result to be the same regardless of how we parallelize them. For example, for accumulator \\(f\\), we need \\(f(f(a, b), f(c, d))\\) to be the same as f(a, f(b, f(c, d)))$ and \\(f(f(f(a, b), c), d)\\).</p> <p>Now, let's consider three-parameter version of <code>reduce</code> where a <code>combiner</code> is given. To ensure that we can combine the partial results in any order, the <code>combiner</code> must be associative.  But, in this case, it is no longer necessary that the accumulator is associative, as long as it is compatible with the combiner.  In other words, the <code>accumulator</code> being associative is a sufficient but not necessary condition for the three-parameter <code>reduce</code> to be parallelizable.  As long as the <code>combiner</code> is associative and compatible with the <code>accumulator</code>, the three-parameter <code>reduce</code> can be parallelized.</p>"},{"location":"37-parallel.html#performance-of-parallel-stream","title":"Performance of Parallel Stream","text":"<p>Let's go back to:</p> <pre><code>IntStream.range(2_030_000, 2_040_000)\n    .filter(x -&gt; isPrime(x))\n    .parallel()\n    .count();\n</code></pre> <p>How much time can we save by parallelizing the code above?</p> <p>Let's use the <code>Instant</code> and <code>Duration</code> class from Java to help us:</p> <pre><code>Instant start = Instant.now();\nlong howMany = IntStream.range(2_000_000, 3_000_000)\n                        .filter(x -&gt; isPrime(x))\n                        .parallel()\n                        .count();\nInstant stop = Instant.now();\nSystem.out.println(howMany + \" \" + Duration.between(start,stop).toMillis() + \" ms\");\n</code></pre> <p>The code above measures roughly the time it takes to count the number of primes between 2 million and 3 million.  On my iMac, it takes 450-550 ms.  If I remove <code>parallel()</code>, it takes slightly more than 1 second.  So with <code>parallel()</code> we gain about 50% performance.</p> <p>Can we parallelize some more?  Remember how we implement <code>isPrime</code><sup>2</sup></p> <pre><code>boolean isPrime(int n) {\n  return IntStream.range(2, (int)Math.sqrt(n) + 1)\n                  .noneMatch(x -&gt; n % x == 0);\n}\n</code></pre> <p>We can parallelize this to make this even faster:</p> <pre><code>boolean isPrime(int n) {\n  return IntStream.range(2, (int)Math.sqrt(n) + 1)\n                  .parallel()\n                  .noneMatch(x -&gt; n % x == 0);\n}\n</code></pre> <p>If you run the code above, however, you will find that the code is not as fast as we expect. On my iMac, it takes about 18s, about 18 times slower!</p> <p>Parallelizing a stream does not always improve the performance.  Creating a thread to run a task incurs some overhead, and the overhead of creating too many threads might outweigh the benefits of parallelization.</p>"},{"location":"37-parallel.html#ordered-vs-unordered-source","title":"Ordered vs. Unordered Source","text":"<p>Whether or not the stream elements are ordered or unordered also plays a role in the performance of parallel stream operations.  A stream may define an encounter order.  Streams created from <code>iterate</code>, ordered collections (e.g., <code>List</code> or arrays), from <code>of</code>, are ordered.  Streams created from <code>generate</code> or unordered collections (e.g., <code>Set</code>) are unordered.</p> <p>Some stream operations respect the encounter order.  For instance, both <code>distinct</code> and <code>sorted</code> preserve the original order of elements (if ordering is preserved, we say that an operation is stable).</p> <p>The parallel version of <code>findFirst</code>, <code>limit</code>, and <code>skip</code> can be expensive on an ordered stream, since it needs to coordinate between the streams to maintain the order.</p> <p>If we have an ordered stream and respecting the original order is not important, we can call <code>unordered()</code> as part of the chain command to make the parallel operations much more efficient.</p> <p>The following, for example, takes about 700 ms on my iMac:</p> <pre><code>Stream.iterate(0, i -&gt; i + 7)\n      .parallel()\n      .limit(10_000_000)\n      .filter(i -&gt; i % 64 == 0)\n      .forEachOrdered(i -&gt; { });\n</code></pre> <p>But, with <code>unordered()</code> inserted, it takes about 350ms, a 2x speedup!</p> <pre><code>Stream.iterate(0, i -&gt; i + 7)\n      .parallel()\n      .unordered()\n      .limit(10_000_000)\n      .filter(i -&gt; i % 64 == 0)\n      .forEachOrdered(i -&gt; { });\n</code></pre> <p>The speedup is a measure of how fast the parallel version is compared to the sequential version.  It is defined as the time taken by the sequential version divided by the time taken by the parallel version.</p> <ol> <li> <p>iPhone 12 comes with an A14 Bionic chip with six cores.  The fastest supercomputer in the world as of this writing, the Frontier, has 9,472 processors, each has 64 cores (total of 606,208 CPU cores) as well as 37,888 GPUs each has 220 cores (total of 8,335,360 GPU cores).\u00a0\u21a9</p> </li> <li> <p>This is a more efficient version of the code you have seen since it stops testing after the square root of the \\(n\\).\u00a0\u21a9</p> </li> </ol>"},{"location":"38-thread.html","title":"Unit 38: Threads","text":"<p>Learning Objectives</p> <p>After completing this unit, students should be able to:</p> <ul> <li>explain the limitations of synchronous programming and why blocking calls reduce program responsiveness</li> <li>describe what a thread is and how multiple threads can execute concurrently</li> <li>create and run simple threads using the <code>Thread</code> class and lambda expressions</li> <li>distinguish between synchronous and asynchronous execution in Java programs</li> <li>observe and reason about thread execution using thread names and basic thread APIs</li> </ul> <p>Overview</p> <p>In the previous unit, we saw how parallel streams allow us to exploit multiple cores with minimal changes to our code. While convenient, parallel streams give us little control over when and how different parts of a computation run, and they hide many important details of concurrent execution.</p> <p>In this unit, we step down one level of abstraction to study threads, the fundamental building blocks of concurrency in Java. Threads allow a program to perform multiple tasks at the same time, such as keeping a user interface responsive while a long-running computation is executing, by decoupling progress from blocking method calls.</p> <p>By understanding how threads are created, scheduled, and executed, you will gain a clearer mental model of asynchronous execution. This model will form the foundation for later units, where we learn about coordination in concurrent programs.</p>"},{"location":"38-thread.html#synchronous-programming","title":"Synchronous Programming","text":"<p>So far, when we invoke a method in Java, we expect the method to return a value when it is done.  If the method is not done, the execution of our program stalls, waiting for the method to complete its execution.  Only after the method returns can the execution of our program continue.</p> <p>We say that the method blocks until it returns.   Such a programming model is known as synchronous programming.</p> <p>Synchronous programming is not very efficient, especially when there are frequent method calls that block for a long period (such as methods that involve expensive computations or reading from a remote server over the Internet).</p> <p>What if we want our program to do something while we wait for the method to return?  For instance, refreshing the UI, or performing other computations?</p>"},{"location":"38-thread.html#threads","title":"Threads","text":"<p>One way to achieve this is to use threads.  A thread is a single flow of execution in a program.  Since the beginning of this course, we have been writing single-thread programs, except for parallel streams in Unit 37.</p> <p>Java provides a class called <code>java.lang.Thread</code> that we can use to encapsulate a function to run in a separate thread.  The following example showss how we can create and run two threads:</p> <pre><code>new Thread(() -&gt; {\n  for (int i = 1; i &lt; 100; i += 1) {\n    System.out.print(\"_\");\n  }\n}).start();\n\nnew Thread(() -&gt; {\n  for (int i = 2; i &lt; 100; i += 1) {\n    System.out.print(\"*\");\n  }\n}).start();\n</code></pre> <p>The <code>new Thread(..)</code> is our usual constructor to create a <code>Thread</code> instance.  The constructor takes a <code>Runnable</code> instance as an argument.  A <code>Runnable</code> is a functional interface with a method <code>run()</code> that takes in no parameter and returns <code>void</code>.</p> <p>With each <code>Thread</code> instance, we run <code>start()</code>, which causes the given lambda expression to run.  Note that <code>start()</code> returns immediately.  It does not wait to return until the given lambda expression completes its execution.  This property differs from what we are accustomed to, where a method blocks until the task given is completed.   This is known as asynchronous execution.</p> <p>The two threads above now run in two separate sequences of execution.  The operating system has a scheduler that decides which threads to run when, and on which core (or which processor).  You might see different interleaving of executions every time you run the same program.</p> <p>Note that we can only control the order in which we start the threads (by changing the order of <code>Thread::start</code> invocation).  We have no control over in what order the threads are run.  The scheduling is done by the operating system. </p> <p>Java provides more than one way to create a thread.  The <code>Thread</code> class also contains methods that we can use to query and control, in a finer-grained manner, how the thread could be executed.</p>"},{"location":"38-thread.html#names","title":"Names","text":"<p>Every thread in Java has a name. Printing out a thread's name is useful for inspecting the runtime behavior.  We can use the instance method <code>getName()</code> to find out the name of a thread, and the class method <code>Thread.currentThread()</code> to get the reference of the current running thread.</p> <pre><code>System.out.println(Thread.currentThread().getName());\nnew Thread(() -&gt; {\n  System.out.print(Thread.currentThread().getName());\n  for (int i = 1; i &lt; 100; i += 1) {\n    System.out.print(\"_\");\n  }\n}).start();\n\nnew Thread(() -&gt; {\n  System.out.print(Thread.currentThread().getName());\n  for (int i = 2; i &lt; 100; i += 1) {\n    System.out.print(\"*\");\n  }\n}).start();\n</code></pre> <p>Note that the above will also print the name of the thread called <code>main</code>, which is a thread created automatically for us every time our program runs and the class method <code>main()</code> is invoked.</p> <p>With this approach, you can now \"visualize\" how many parallel threads are created when you invoke a parallel stream.</p> <p>Try <pre><code>Stream.of(1, 2, 3, 4)\n      .parallel()\n      .reduce(0, (x, y) -&gt; { \n        System.out.println(Thread.currentThread().getName()); \n        return x + y; \n      });\n</code></pre></p> <p>and you will see something like this: <pre><code>main\nForkJoinPool.commonPool-worker-5\nForkJoinPool.commonPool-worker-5\nForkJoinPool.commonPool-worker-9\nForkJoinPool.commonPool-worker-3\nForkJoinPool.commonPool-worker-3\nForkJoinPool.commonPool-worker-3\n</code></pre></p> <p>being printed.  This shows four concurrent threads running to reduce the stream of 1, 2, 3, 4 (including <code>main</code>).</p> <p>If you remove the <code>parallel()</code> call:</p> <pre><code>Stream.of(1, 2, 3, 4)\n      .reduce(0, (x, y) -&gt; { \n        System.out.println(Thread.currentThread().getName()); \n        return x + y; \n      });\n</code></pre> <p>then only <code>main</code> is printed, showing the reduction being done sequentially in a single thread.</p> <pre><code>main\nmain\nmain\nmain\n</code></pre>"},{"location":"38-thread.html#sleep","title":"Sleep","text":"<p>Another useful method in the <code>Thread</code> class is <code>sleep</code>.  You can cause the current execution thread to pause execution immediately for a given period (in milliseconds).   After the sleep timer is over, the thread is ready to be chosen by the scheduler to run again.</p> <p>The following code prints a <code>\".\"</code> to the console every second while another expensive computation is running.</p> <pre><code>Thread findPrime = new Thread(() -&gt; {\n  System.out.println(\n      Stream.iterate(2, i -&gt; i + 1)\n          .filter(i -&gt; isPrime(i))\n          .limit(1_000_000L)\n          .reduce((x, y) -&gt; y)\n          .orElse(null));\n});\n\nfindPrime.start();\n\nwhile (findPrime.isAlive()) {\n  try {\n    Thread.sleep(1000);\n    System.out.print(\".\");\n  } catch (InterruptedException e) {\n    System.out.print(\"interrupted\");\n  }\n} \n</code></pre> <p>In our examples, we often use <code>Thread.sleep()</code> in our methods to simulate expensive computations.</p> <p>Two more things to note:</p> <ul> <li>The example above shows how we use <code>isAlive()</code> to periodically check if another thread is still running.</li> <li>The program exits only after all the threads created run to their completion.</li> </ul>"},{"location":"39-async.html","title":"Unit 39: Asynchronous Programming","text":"<p>Learning Objectives</p> <p>After completing this unit, students should be able to:</p> <ul> <li>explain the limitations of using <code>Thread</code> directly for coordinating concurrent tasks</li> <li>describe how task dependencies and execution order can be expressed using higher-level abstractions</li> <li>use <code>CompletableFuture</code> to compose and execute asynchronous computations</li> <li>distinguish between synchronous and asynchronous chaining operations in <code>CompletableFuture</code></li> <li>handle exceptions arising from asynchronous computations using <code>CompletableFuture</code></li> </ul> <p>Overview</p> <p>While working directly with <code>Thread</code> provides flexibility, it also places a significant burden on the programmer. Coordinating execution order, sharing results safely, handling exceptions, and managing thread lifecycles quickly become complex as the number of interacting tasks increases.</p> <p>In this unit, we move away from direct thread management and introduce asynchronous programming as a higher-level approach to concurrency. Rather than focusing on threads, we focus on tasks and their dependencies. Using <code>CompletableFuture</code>, we will see how asynchronous computations can be composed and executed concurrently in a structured way, with built-in support for combining results and handling errors. This approach leads to concurrent programs that are clearer, more expressive, and easier to reason about.</p>"},{"location":"39-async.html#limitations-of-thread","title":"Limitations of <code>Thread</code>","text":"<p>Writing code directly with the <code>Thread</code> class gives us control over how many threads to create, what they do, how they communicate with each other, and some level of control on which thread gets executed when.  Java's <code>Thread</code> is already a higher-level abstraction compared to, say, the <code>pthread</code> library in C and C++.  It, however, still takes significant effort to write complex multi-threaded programs in Java.</p> <p>Consider the situation where we have a series of tasks that we wish to execute concurrently and we want to organize them such that:</p> <ul> <li>Task A must start first.</li> <li>When Task A is done, we take the result from Task A, and pass it to Tasks B, C, and D.</li> <li>We want Task B and C to complete before we pass their results to Task E.  </li> </ul> <p>We also want to handle exceptions gracefully \u2014 if one of the tasks encounters an exception, the other tasks not dependent on it should still be completed.</p> <p>Implementing the above using <code>Thread</code> requires careful coordination.  Firstly, there are no methods in <code>Thread</code> that return a value.  We need the threads to communicate through shared variables.  Secondly, there is no mechanism to specify the execution order and dependencies between threads.  Finally, we have to consider the possibility of exceptions in each of our tasks.</p> <p>Another drawback of using <code>Thread</code> is its overhead \u2014 the creation of <code>Thread</code> instances takes up some resources in Java.  As much as possible, we should reuse our <code>Thread</code> instances to run multiple tasks.  For instance, the same <code>Thread</code> instance could have run Tasks A, B, and E in the example above.  Managing the <code>Thread</code> instances and deciding which <code>Thread</code> instance should run which task is a gigantic undertaking.</p>"},{"location":"39-async.html#a-higher-level-abstraction","title":"A Higher-Level Abstraction","text":"<p>What we need is a higher-level abstraction that allows programmers to focus on specifying the tasks and their dependencies, without worrying about the details.  Suppose we want to run the tasks in a single thread, we could do the following:</p> <pre><code>int foo(int x) {\n  int a = taskA(x);\n  int b = taskB(a);\n  int c = taskC(a);\n  int d = taskD(a);\n  int e = taskE(b, c);\n  return e;\n}\n</code></pre> <p>We could also use monads to chain up the computations.  Let's say that one of the tasks might not produce a value, then we can use the <code>Maybe&lt;T&gt;</code> monad:</p> <p><pre><code>Maybe&lt;Integer&gt; foo(int x) {\n  Maybe&lt;Integer&gt; a = Maybe.of(taskA(x));\n  Maybe&lt;Integer&gt; b = a.flatMap(i -&gt; taskB(i));\n  Maybe&lt;Integer&gt; c = a.flatMap(i -&gt; taskC(i));\n  Maybe&lt;Integer&gt; d = a.flatMap(i -&gt; taskD(i));\n  Maybe&lt;Integer&gt; e = b.combine(c, (i, j) -&gt; taskE(i, j));\n  return e;\n}\n</code></pre> with <code>taskA</code> to <code>taskD</code> now returns <code>Maybe&lt;T&gt;</code> instead of <code>T</code>.  </p> <p>If we want to perform the tasks lazily, then we can use the <code>Lazy&lt;T&gt;</code> monad:</p> <p><pre><code>Lazy&lt;Integer&gt; foo(int x) {\n  Lazy&lt;Integer&gt; a = Lazy.of(taskA(x));\n  Lazy&lt;Integer&gt; b = a.flatMap(i -&gt; taskB(i));\n  Lazy&lt;Integer&gt; c = a.flatMap(i -&gt; taskC(i));\n  Lazy&lt;Integer&gt; d = a.flatMap(i -&gt; taskD(i));\n  Lazy&lt;Integer&gt; e = b.combine(c, (i, j) -&gt; taskE(i, j));\n  return e;\n}\n</code></pre> with <code>taskA</code> to <code>taskD</code> modified to <code>Lazy&lt;T&gt;</code> instead of <code>T</code>.  </p> <p>It would be useful if there is a monad that allows us to perform the tasks concurrently.  <code>java.util.concurrent.CompletableFuture</code> is such monad.  Here is an example of how to use it:</p> <p><pre><code>CompletableFuture&lt;Integer&gt; foo(int x) {\n  CompletableFuture&lt;Integer&gt; a = CompletableFuture.completedFuture(taskA(x));\n  CompletableFuture&lt;Integer&gt; b = a.thenComposeAsync(i -&gt; taskB(i));\n  CompletableFuture&lt;Integer&gt; c = a.thenComposeAsync(i -&gt; taskC(i));\n  CompletableFuture&lt;Integer&gt; d = a.thenComposeAsync(i -&gt; taskD(i));\n  CompletableFuture&lt;Integer&gt; e = b.thenCombineAsync(c, (i, j) -&gt; taskE(i, j));\n  return e;\n}\n</code></pre> where <code>taskA</code> to <code>taskD</code> now returns <code>CompletableFuture&lt;T&gt;</code> instead of <code>T</code>.  </p> <p>We can then run <code>foo(x).get()</code> to wait for all the concurrent tasks to complete and return us the value.  <code>CompletableFuture&lt;T&gt;</code> is a monad that encapsulates a value that is either there or not there yet.  Such an abstraction is also known as a promise in other languages (e.g., <code>Promise</code> in JavaScript and <code>std::promise</code> in C++) \u2014 it encapsulates the promise to produce a value.</p>"},{"location":"39-async.html#the-completablefuture-monad","title":"The <code>CompletableFuture</code> Monad","text":"<p>Let's now examine the <code>CompletableFuture</code> monad in more detail.  A key property of <code>CompletableFuture</code> is whether the value it promises is ready \u2014 i.e., the tasks that it encapsulates have been completed or not.</p>"},{"location":"39-async.html#creating-a-completablefuture","title":"Creating a <code>CompletableFuture</code>","text":"<p>There are several ways we can create a <code>CompletableFuture&lt;T&gt;</code> instance:</p> <ul> <li>Use the <code>completedFuture</code> method.  This method is equivalent to creating a task that is already completed and return us a value.  </li> <li>Use the <code>runAsync</code> method that takes in a <code>Runnable</code> lambda expression.  <code>runAsync</code> has the return type of <code>CompletableFuture&lt;Void&gt;</code>.  The returned <code>CompletableFuture</code> instance completes when the given lambda expression finishes.</li> <li>Use the <code>supplyAsync</code> method that takes in a <code>Supplier&lt;T&gt;</code> lambda expression.  <code>supplyAsync</code> has the return type of <code>CompletableFuture&lt;T&gt;</code>.  The returned <code>CompletableFuture</code> instance completes when the given lambda expression finishes.</li> </ul> <p>We can also create a <code>CompletableFuture</code> that relies on other <code>CompletableFuture</code> instances.  We can use <code>allOf</code> or <code>anyOf</code> methods for this.  Both of these methods take in a variable number of other <code>CompletableFuture</code> instances.  A new <code>CompletableFuture</code> created with <code>allOf</code> is completed only when all the given <code>CompletableFuture</code> instances complete.  On the other hand, a new <code>CompletableFuture</code> created with <code>anyOf</code> is completed when any one of the given <code>CompletableFuture</code> instance completes.</p>"},{"location":"39-async.html#chaining-completablefuture","title":"Chaining <code>CompletableFuture</code>","text":"<p>The usefulness of <code>CompletableFuture</code> comes from the ability to chain them up and specify the dependencies of computations to be run.  We have the following methods:</p> <ul> <li><code>thenApply</code>, which is analogous to <code>map</code></li> <li><code>thenCompose</code>, which is analogous to <code>flatMap</code></li> <li><code>thenCombine</code>, which is analogous to <code>combine</code></li> </ul> <p>The methods above run the given lambda expression in the same thread as the caller.  There is also an asynchronous version (<code>thenApplyAsync</code>, <code>thenComposeAsync</code>, <code>thenCombineAsync</code>), which may cause the given lambda expression to run in a different thread (thus more concurrency).</p> <p><code>CompletableFuture</code> also has several methods that take in <code>Runnable</code>.</p> <ul> <li><code>thenRun</code> takes in a <code>Runnable</code>.  It executes the <code>Runnable</code> after the current stage is completed.</li> <li><code>runAfterBoth</code> takes in another <code>CompletableFuture</code><sup>1</sup> and a <code>Runnable</code>.  It executes the <code>Runnable</code> after the current stage completes and the input <code>CompletableFuture</code> is completed.</li> <li><code>runAfterEither</code> takes in another <code>CompletableFuture</code><sup>1</sup> and a <code>Runnable</code>.  It executes the <code>Runnable</code> after the current stage completes or the input <code>CompletableFuture</code> is completed.</li> </ul> <p>All of the methods that take in <code>Runnable</code> return <code>CompletableFuture&lt;Void&gt;</code>.  Similarly, they also have the asynchronous version (<code>thenRunAsync</code>, <code>runAfterBothAsync</code>, <code>runAfterEitherAsync</code>).</p> <p>Note that chaining of <code>CompletableFuture</code> instances is not limited to linear dependencies.  In the example above, <pre><code>  CompletableFuture&lt;Integer&gt; a = CompletableFuture.completedFuture(taskA(x));\n  CompletableFuture&lt;Integer&gt; b = a.thenComposeAsync(i -&gt; taskB(i));\n  CompletableFuture&lt;Integer&gt; c = a.thenComposeAsync(i -&gt; taskC(i));\n</code></pre></p> <p>There is a branch after <code>a</code> completes.  Both <code>b</code> and <code>c</code> depend on <code>a</code>, but they are independent of each other.  Since <code>a</code> calls <code>thenComposeAsync</code>, both <code>b</code> and <code>c</code> can run concurrently after <code>a</code> completes.</p> <p>An alternative is to call <code>thenCompose</code> instead of <code>thenComposeAsync</code>. <pre><code>  CompletableFuture&lt;Integer&gt; a = CompletableFuture.completedFuture(taskA(x));\n  CompletableFuture&lt;Integer&gt; b = a.thenCompose(i -&gt; taskB(i));\n  CompletableFuture&lt;Integer&gt; c = a.thenCompose(i -&gt; taskC(i));\n</code></pre> In that case, <code>b</code> and <code>c</code> would still run sequentially in the same thread as the caller, one after the other, after <code>a</code> completes.  The <code>CompletableFuture</code> implementation keeps a stack of tasks to run after it completes.  The tasks are run in the reverse order they were added to the stack.  Hence, in the example above, <code>taskC</code> would run first, followed by <code>taskB</code>.</p> <p>Besides branching, we can also merge two <code>CompletableFuture</code> instances.  For instance, the following merges <code>b</code> and <code>c</code> after they both complete: <pre><code>  CompletableFuture&lt;Integer&gt; e = b.thenCombineAsync(c, (i, j) -&gt; taskE(i, j));\n</code></pre></p> <p>The other merge method is <code>allOf</code>. <pre><code>CompletableFuture&lt;Void&gt; all = CompletableFuture.allOf(b, c);\n</code></pre> which completes when both <code>b</code> and <code>c</code> complete.  Note that the return type of <code>allOf</code> is <code>CompletableFuture&lt;Void&gt;</code> since there is no single value to return.</p>"},{"location":"39-async.html#getting-the-result","title":"Getting the Result","text":"<p>After we have set up all the tasks to run asynchronously, we have to wait for them to complete.  We can call <code>get()</code> to get the result.  Since <code>get()</code> is a synchronous call, i.e., it blocks until the <code>CompletableFuture</code> completes, to maximize concurrency, we should only call <code>get()</code> as the final step in our code.</p> <p>The method <code>CompletableFuture::get</code> throws a couple of checked exceptions: <code>InterruptedException</code> and <code>ExecutionException</code>, which we need to catch and handle.  The former refers to an exception indicating the the thread was interrupted, while the latter refers to errors/exceptions during execution.</p> <p>An alternative to <code>get()</code> is <code>join()</code>.  <code>join()</code> behaves just like <code>get()</code> except that no checked exception is thrown.</p>"},{"location":"39-async.html#example","title":"Example","text":"<p>Let's look at some examples.  We reuse our method that computes the i-th prime number.</p> <pre><code>int findIthPrime(int i) {\n  return Stream\n          .iterate(2, x -&gt; x + 1)\n          .filter(x -&gt; isPrime(x))\n          .limit(i)\n          .reduce((x, y) -&gt; y)\n          .orElse(0);\n}\n</code></pre> <p>Given two numbers i and j, we want to find the difference between the i-th prime number and the j-th prime number.  We can first do the following:</p> <pre><code>CompletableFuture&lt;Integer&gt; ith = CompletableFuture.supplyAsync(() -&gt; findIthPrime(i));\nCompletableFuture&lt;Integer&gt; jth = CompletableFuture.supplyAsync(() -&gt; findIthPrime(j));\n</code></pre> <p>These calls would launch two concurrent threads to compute the i-th and the j-th primes.   The method call to <code>supplyAsync</code> returns immediately without waiting for <code>findIthPrime</code> to complete.</p> <p>Next, we can say, that, when <code>ith</code> and <code>jth</code> are complete, take the value computed by them, and take the difference.  We can use the <code>thenCombine</code> method: <pre><code>CompletableFuture&lt;Integer&gt; diff = ith.thenCombine(jth, (x, y) -&gt; x - y);\n</code></pre></p> <p>This statement creates another <code>CompletableFuture</code> that runs asynchronously and computes the difference between the two prime numbers.  At this point, we can move on to run other tasks, or if we just want to wait until the result is ready, we call <pre><code>diff.join();\n</code></pre></p> <p>to get the difference between the two primes<sup>2</sup>.</p>"},{"location":"39-async.html#handling-exceptions","title":"Handling Exceptions","text":"<p>One of the advantages of using <code>CompletableFuture&lt;T&gt;</code> instead of <code>Thread</code> to handle concurrency is its ability to handle exceptions.  <code>CompletableFuture&lt;T&gt;</code> has three methods that deal with exceptions: <code>exceptionally</code>, <code>whenComplete</code>, and <code>handle</code>.   We will focus on <code>handle</code> since it is the most general.</p> <p>Suppose we have a computation inside a <code>CompletableFuture&lt;T&gt;</code> that might throw an exception.  Since the computation is asynchronous and could run in a different thread, the question of which thread should catch and handle the exception arises.  <code>CompletableFuture&lt;T&gt;</code> keeps things simpler by storing the exception and passing it down the chain of calls, until <code>join()</code> is called.  <code>join()</code> might throw <code>CompletionException</code> and whoever calls <code>join()</code> will be responsible for handling this exception.  The <code>CompletionException</code> contains information on the original exception.</p> <p>For instance, the code below would throw a <code>CompletionException</code> with a <code>NullPointerException</code> contained within it.</p> <pre><code>CompletableFuture.&lt;Integer&gt;supplyAsync(() -&gt; null)\n                 .thenApply(x -&gt; x + 1)\n                 .join();\n</code></pre> <p>Suppose we want to continue chaining our tasks despite exceptions.  We can use the <code>handle</code> method, to handle the exception.  The <code>handle</code> method takes in a <code>BiFunction</code> (similar to <code>cs2030s.fp.Combiner</code>).  The first parameter of the <code>BiFunction</code> is the value, the second is the exception.  The funtion's return value becomes the result of the new <code>CompletableFuture</code> returned by <code>handle</code>.</p> <p>Only one of the first two parameters is not <code>null</code>.  If the value is <code>null</code>, this means that an exception has been thrown.  Otherwise, the exception is <code>null</code><sup>3</sup>.    </p> <p>Here is a simple example where we use <code>handle</code> to replace a default value. <pre><code>cf.thenApply(x -&gt; x + 1)\n  .handle((t, e) -&gt; (e == null) ? t : 0)\n  .join();\n</code></pre></p> <ol> <li> <p>Actually, this is a <code>CompletionStage</code> which is a supertype of <code>CompletableFuture</code>.\u00a0\u21a9\u21a9</p> </li> <li> <p>There is repeated computation in primality checks between the two calls to <code>findIthPrime</code> here, which one could optimize.  We don't do that here to keep the example simple.\u00a0\u21a9</p> </li> <li> <p>This is another instance where Java uses <code>null</code> to indicate a missing value.  We can't use <code>null</code> as a legitimate value due to this flawed design.\u00a0\u21a9</p> </li> </ol>"},{"location":"40-forkjoin.html","title":"Unit 40: Fork and Join","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>understand the task deque and work stealing</li> <li>understand the behaviour of <code>fork</code> and <code>join</code> (and <code>compute</code>)</li> <li>be able to order <code>fork</code> and <code>join</code> efficiently</li> <li>be able to use <code>RecursiveTask</code></li> </ul>"},{"location":"40-forkjoin.html#thread-pool","title":"Thread Pool","text":"<p>We now look under the hood of parallel <code>Stream</code> and <code>CompletableFuture&lt;T&gt;</code> to explore how Java manages its threads.  Recall that creating and destroying threads is not cheap, and as much as possible we should reuse existing threads to perform different tasks.  This goal can be achieved by using a thread pool. </p> <p>A thread pool consists of (i) a collection of threads, each waiting for a task to execute, and (ii) a collection of tasks to be executed.  Typically the tasks are put in a shared queue, and an idle thread picks up a task from the shared queue to execute.</p> <p>To illustrate this concept, here is a trivial thread pool with a single thread:</p> <pre><code>Queue&lt;Runnable&gt; queue;\nnew Thread(() -&gt; {\n  while (true) {\n    if (!queue.isEmpty()) {\n      Runnable r = queue.dequeue();\n      r.run();\n    }\n  }\n}).start();\n\nfor (int i = 0; i &lt; 100; i++) {\n  int count = i;\n  queue.add(() -&gt; System.out.println(count));\n}\n</code></pre> <p>We assume that <code>Queue&lt;T&gt;</code> can be safely modified concurrently (i.e., it is thread-safe) in the sample code above.  Otherwise, just like the example you have seen in parallel streams with <code>List</code>, items might be lost.</p>"},{"location":"40-forkjoin.html#fork-and-join","title":"Fork and Join","text":"<p>Java implements a thread pool called <code>ForkJoinPool</code> that is fine-tuned for the fork-join model of recursive parallel execution.  </p> <p>The Fork-join model is essentially a parallel divide-and-conquer model of computation.  The general idea for the fork-join model is to solve a problem by breaking up the problem into identical problems but with a smaller size (fork), then solve the smaller version of the problem recursively, and then combine the results (join).   This repeats recursively until the problem size is small enough \u2014 we have reached the base case and so we just solve the problem sequentially without further parallelization.</p> <p>In Java, we can create a task that we can fork and join as an instance of the abstract class <code>RecursiveTask&lt;T&gt;</code>.  <code>RecursiveTask&lt;T&gt;</code> supports the methods <code>fork()</code>, which submits a smaller version of the task for execution, and <code>join()</code> (which waits for the smaller tasks to complete and return).   <code>RecursiveTask&lt;T&gt;</code> has an abstract method <code>compute()</code>, which we, as the client, have to define to specify what computation we want to compute.</p> <p>Here is a simple <code>RecursiveTask&lt;T&gt;</code> that recursively sums up the content of an array: <pre><code>class Summer extends RecursiveTask&lt;Integer&gt; {\n  private static final int FORK_THRESHOLD = 2;\n  private int low;\n  private int high;\n  private int[] array;\n\n  public Summer(int low, int high, int[] array) {\n    this.low = low;\n    this.high = high;\n    this.array = array;\n  }\n\n  @Override\n  protected Integer compute() {\n    // stop splitting into subtask if array is already small.\n    if (high - low &lt; FORK_THRESHOLD) {\n      int sum = 0;\n      for (int i = low; i &lt; high; i++) {\n        sum += array[i];\n      }\n      return sum;\n    }\n\n    int middle = (low + high) / 2;\n    Summer left = new Summer(low, middle, array);\n    Summer right = new Summer(middle, high, array);\n    left.fork();\n    return right.compute() + left.join();\n  }\n}\n</code></pre></p> <p>To run this task, we run: <pre><code>Summer task = new Summer(0, array.length, array);\nint sum = task.compute();\n</code></pre></p> <p>The line <code>task.compute()</code> above is just like another method invocation.  It causes the method <code>compute()</code> to be invoked, and if the array is big enough, two new <code>Summer</code> instances, <code>left</code> and <code>right</code>, are created.  <code>left</code>.  We then call <code>left.fork()</code>, which adds the tasks to a thread pool so that one of the threads can call its <code>compute()</code> method.  We subsequently call <code>right.compute()</code> (which is a normal method call).  Finally, we call <code>left.join()</code>, which blocks until the computation of the recursive sum is completed and returned.  We add the result from <code>left</code> and <code>right</code> together and return the sum.</p> <p>There are other ways we can combine and order the execution of <code>fork()</code>, <code>compute()</code>, and <code>join()</code>.  Some are better than others.  We will explore more in the exercises.</p>"},{"location":"40-forkjoin.html#forkjoinpool","title":"<code>ForkJoinPool</code>","text":"<p>Let's now explore the idea behind how Java manages the thread pool with fork-join tasks.  The details are beyond the scope of this course, but it would be interesting to note a few key points, as follows:</p> <ul> <li>Each thread has a deque<sup>1</sup> of tasks.  </li> <li>When a thread is idle, it checks its deque of tasks.  If the deque is not empty, it picks up a task at the head of the deque to execute (e.g., invoke its <code>compute()</code> method).  Otherwise, if the deque is empty, it picks up a task from the tail of the deque of another thread to run.  The latter is a mechanism called work stealing.</li> <li>When <code>fork()</code> is called, the caller adds itself to the head of the deque of the executing thread.  This is done so that the most recently forked task gets executed next, similar to how normal recursive calls.</li> <li>When <code>join()</code> is called, several cases might happen.  If the subtask to be joined hasn't been executed, its <code>compute()</code> method is called and the subtask is executed.  If the subtask to be joined has been completed (some other thread has stolen this and completed it), then the result is read, and <code>join()</code> returns.  If the subtask to be joined has been stolen and is being executed by another thread, then the current thread either finds some other tasks to work on from its local deque, or steals another task from another deque.</li> </ul> <p>The beauty of the mechanism here is that the threads always look for something to do and they cooperate to get as much work done as possible.</p> <p>The mechanism here is similar to that implemented in .NET and Rust.</p>"},{"location":"40-forkjoin.html#order-of-fork-and-join","title":"Order of <code>fork()</code> and <code>join()</code>","text":"<p>One implication of how <code>ForkJoinPool</code> adds and removes tasks from the deque is the order in which we call <code>fork()</code> and <code>join()</code>.  Since the most recently forked task is likely to be executed next, we should <code>join()</code> the most recent <code>fork()</code> task first.  In other words, the order of forking should be the reverse of the order of joining.</p> <p>In the class <code>Summer</code> above, <pre><code>    left.fork();  // &gt;-----------+\n    right.fork(); // &gt;--------+  | should have\n    return right.join() // &lt;--+  | no crossing\n         + left.join(); // &lt;-----+\n</code></pre></p> <p>is more efficient than <pre><code>    left.fork();  // &gt;-------------+\n    right.fork(); // &gt;----------+  | there is crossing\n    return left.join()   // &lt;---|--+\n         + right.join(); // &lt;---+\n</code></pre></p> <p>In other words, your <code>fork()</code>, <code>compute()</code>, <code>join()</code> order should form a palindrome and there should be no crossing.  Additionally, there should only be at most a single <code>compute</code> and it should be in the middle of the palindrome.</p> <p>For example, the following is ok. <pre><code>    left.fork();  // &gt;-----------+\n    return right.compute() //    | compute in middle\n         + left.join(); // &lt;-----+\n</code></pre></p> <p>But the following is not. <pre><code>    return left.compute()   // this is practically\n         + right.compute(); // not even concurrent\n</code></pre></p> <ol> <li> <p>A deque is a double-ended queue.  It behaves like both a stack and a queue.\u00a0\u21a9</p> </li> </ol>"},{"location":"environments.html","title":"The CS2030S Programming Environment","text":"Figure 1: The CS2030S Programming Environment.  TL;DR: All work should be done on the PE nodes.  You can access the nodes via `ssh` through lab PCs or your personal devices.  If you need to access them outside SoC, you need to go through SoC VPN."},{"location":"environments.html#java-version","title":"Java version","text":"<p>Java is a language that continues to evolve.  A new version is released every six months.  For CS2030S, we will only use Java 21.  Specifically, we use <code>javac 21.0.9</code> on Ubuntu 20.04.6.</p>"},{"location":"environments.html#pe-hosts","title":"PE Hosts","text":"<p>The school has provided a list of computing servers with the above environments for you to use ( in Figure 1).  All the required software for CS2030S has been installed on the servers.  To access the server, we connect to a host called <code>pelogin</code>   (<code>pe</code> stands for \"programming environment\"), which will then redirect us to one of the servers.  We will refer to these servers generally as the PE hosts.</p> <p>We cannot choose which of the servers to use.  The host <code>pelogin</code> acts as a load balancer and will automatically assign you to the appropriate host.  You share the same home directory across all the hosts (this home directory, however, is different from that of <code>stu</code>).</p>"},{"location":"environments.html#accessing-the-pe-hosts","title":"Accessing the PE Hosts","text":"<p>While you can complete the programming assignments on your own computers, the practical exams are done in a controlled environment using servers similar to the PE hosts.  It is therefore advisable for you to familiarize yourself with accessing the PE servers via <code>ssh</code> and edit your program with either <code>vim</code>, <code>micro</code> or <code>emacs</code> (<code>vim</code> is recommended and supported).</p>"},{"location":"environments.html#account","title":"Account","text":"<p>Basic requirements:</p> <ol> <li> <p>To access the hosts, you need an SoC Unix account.  If you do not have one, you can apply for one online.</p> </li> <li> <p>Once you have an account, you need to activate your access to the computer clusters, which are part of the SoC computer clusters.</p> </li> <li> <p>To access PE Hosts from your computer ( or  in Figure 1) you need</p> <ul> <li>a command line <code>ssh</code> client.  Windows 10/11, macOS, and Linux users should already have <code>ssh</code> installed by default.  If your OS does come with <code>ssh</code> (i.e., it cannot find the <code>ssh</code> command when you type <code>ssh</code> into your terminal), look for instructions on how to install OpenSSH client on your operating system.</li> <li>a terminal emulator.  The default terminal emulator that comes with Windows and Mac supports only basic features.  For Windows 10/11 users, CS2030S recommends either PowerShell (pre-installed) or Windows Terminal.  For macOS users, CS2030S recommends iTerm2.</li> </ul> </li> </ol>"},{"location":"environments.html#the-command-to-ssh","title":"The Command to SSH","text":"<p>You can access the PE hosts remotely via <code>ssh</code> (Secure SHell).</p> <p>In general, to connect to a remote host, run the following in your terminal on your local computer:</p> <pre><code>ssh &lt;username&gt;@&lt;hostname&gt;\n</code></pre> <p>Replace <code>&lt;username&gt;</code> with your SoC Unix username and <code>&lt;hostname&gt;</code> with <code>pelogin</code>. For instance, I would do: <pre><code>ssh ooiwt@pelogin.comp.nus.edu.sg\n</code></pre></p> <p>After the command above, follow the instructions on the screen.  The first time you ever connect to <code>pelogin.comp.nus.edu.sg</code>, you will be warned that you are connecting to a previously unknown host.  Answer <code>yes</code>.  After that, you will be prompted with your SoC Unix password.  Note that nothing is shown on the screen when your password is being entered.</p>"},{"location":"environments.html#accessing-the-pe-hosts-from-outside-soc","title":"Accessing The PE Hosts from Outside SoC","text":"<p>The PE hosts can only be accessed from within the School of Computing networks.  If you want to access it from outside the network, you need to connect through SoC VPN ( in Figure 1).  Note that even if you are physically within SoC, but you are connected to the Internet through mobile network tethering, the NUS_GUEST WiFi network, or any other external networks, you still need to connect through SoC VPN.  To connect to the School of Computing network within the premise of School of Computing, you need to connect to NUS_STU.</p> <p>First, you need to set up a Virtual Private Network (VPN) (See instructions here).  The staff at the IT helpdesk in COM1, Level 1, will be able to help you with setting up if needed.  You can also contact them via the NUS IT RT system at https://rt.comp.nus.edu.sg.</p> <p>SoC VPN vs NUS VPN</p> <p>Note that SoC VPN is different from NUS VPN.  Connecting to NUS VPN only allows you access to the NUS internal network, but not the SoC internal network.</p> <p>FortiClient VPN vs FortiClient</p> <p>When you setup the SoC VPN client, please make sure that you download and install \"FortiClient VPN Only\", and not \"FortiClient\".  The latter is a commercial product that would stop working after the free trial is over.   On the other hand, \"FortiClient VPN\" is a free product.</p>"},{"location":"environments.html#accessing-the-pe-hosts-from-soc-lab-pcs","title":"Accessing The PE Hosts from SoC Lab PCs","text":"<p>CS2030S practical exams will be conducted in the programming labs in COM1, COM4, and AS6 using the Ubuntu environment on the lab PCs.  Students are advised to use the lab PCs during regular lab sessions to familiarize themselves with the environment ( in Figure 1).  </p> <p>To access the PE hosts from the lab PCs during lab sessions:</p> <ul> <li>Boot into Ubuntu if the PC is not already running Ubuntu</li> <li>Log into the PC using the SoC Unix account</li> <li>Launch the terminal and use <code>ssh</code> command above.</li> </ul> <p>Warning</p> <p>The local home directory on the lab PCs will be cleaned regularly.  Do not expect that files stored in the lab PCs to be persistent.  You can copy your files to external drive, to your home directory on the PE hosts, or to a cloud storage.</p>"},{"location":"environments.html#copying-files-between-pe-nodes-and-local-computer","title":"Copying Files between PE Nodes and Local Computer","text":"<p>As the PE hosts are meant to simulate the practical exam environments, <code>scp</code> and <code>sftp</code> are blocked on <code>pelogin</code>.  We recommend working on <code>pelogin</code> directly as it will be a good practice to prepare for your practical.</p>"},{"location":"environments.html#troubleshooting-ssh-connection","title":"Troubleshooting SSH Connection","text":"<p>Some common error messages you may receive when you <code>ssh</code> and what they mean:</p> <ol> <li> <p><code>ssh: Could not resolve hostname pelogin.comp.nus.edu.sg</code></p> <p><code>ssh</code> cannot recognize the name <code>pelogin</code>. Likely, you tried to connect to the PE hosts directly from outside of the SoC network.</p> </li> <li> <p><code>error : Unable to allocate resources : Invalid account or account/partition combination specified</code></p> <p>You have connected to the PE host, but you are kicked out because you have no permission to use the host.</p> <p>Make sure you have activated your access to \"SoC computer clusters\" here.</p> </li> <li> <p><code>Permission denied, please try again</code></p> <p>You did not enter the correct password or username.  Please use the username and password of your SoC Unix account which you have created here.</p> <p>Check that you have entered your username correctly.  It is case-sensitive.</p> <p>If you have lost your password, go here (to reset your password)[https://mysoc.nus.edu.sg/~myacct/resetpass.cgi).</p> </li> <li> <p><code>Could not chdir to home directory /home/o/ooiwt: Permission denied</code></p> <p>This error means that you have successfully connected to the PE hosts, but you have no access to your home directory. </p> <p>This should not happen.  Please file a service request with SoC IT Unit. Include the error message, the PE hosts that you connected to, and your username.  The system administrator can reset the permission of your home directory for you.</p> </li> </ol>"},{"location":"environments.html#setting-up-ssh-keys","title":"Setting up SSH Keys","text":"<p>The next step is not required but is a time-saver and a huge quality-of-life improvement.  You need to be familiar with basic Unix commands, including how to copy files to remote hosts (using <code>scp</code>), how to check/change file permissions (using <code>ls -l</code> and <code>chmod</code>), and how to open, edit, and save a file using <code>vim</code>.  If you are still not comfortable with these commands, make sure you play with the basic Unix commands and <code>vim</code>.  You can come back and complete this step later. </p> <p>Our goal here is to set up a pair of public/private keys for authentication so that you do not need to type your password every time you log into a PE host.</p> <p>You can use the following command on your local computer to generate a pair of keys: <pre><code>ssh-keygen -t rsa\n</code></pre></p> <p>This command will generate two keys, a private key <code>id_rsa</code>, and a public key <code>id_rsa.pub</code>.  You will be prompted for a passphrase.  This is the passphrase to protect your private key on your local computer.  You can enter an empty passphrase (at the cost of weaker security) to avoid being prompted for the passphrase whenever you access the private key<sup>1</sup>. Keep the private key <code>id_rsa</code> on your local machine in the hidden <code>~/.ssh</code> directory and copy the public key <code>id_rsa.pub</code> to your account on PE <code>pelogin</code>.</p> <p>The following are the steps to copy <code>id_rsa.pub</code> to the PE hosts.</p> <ul> <li> <p>On a PE host, create a directory named <code>.ssh</code> in your home directory if it does not already exist.</p> </li> <li> <p>Edit the file named <code>authorized_keys</code> under the <code>.ssh</code> directory.</p> </li> </ul> <pre><code>vim ~/.ssh/authorized_keys\n</code></pre> <ul> <li> <p>Once in vim, enter INSERT mode, and copy-and-paste the content of <code>id_rsa.pub</code> from the local machine into <code>authorized_keys</code> using your terminal copy-and-paste feature (the actual keys to copy and to paste depends on your OS and Terminal).  Make sure that the content is pasted as a single line without any extra spaces.  Save <code>authorized_keys</code> and exit vim.</p> </li> <li> <p>Make sure that the permission for <code>.ssh</code> both on the local machine and on PE is set to <code>700</code> and the files <code>~/.ssh/id_rsa</code> on the local machine and <code>~/.ssh/authorized_keys</code> on the remote machine are set to <code>600</code>.  See the guide on using <code>ls</code> and <code>chmod</code> if you are unsure how to do this.</p> </li> </ul> <p>Once set up, you need not enter your password every time you run <code>ssh pelogin</code> from your personal computer.</p>"},{"location":"environments.html#stability-of-network-connection","title":"Stability of Network Connection","text":"<p>Note that a stable network connection is required to use the PE hosts for a long period without interruption.   If you encounter frequent disconnections while working at home or on campus while connected wirelessly, please make sure that your Wi-Fi signal is strong and that there is no interference from other sources. </p> <p>If your connection is disconnected in the middle of editing, <code>vim</code> saves the state of the buffer for you.  See the section on recovery files on how to recover your files.</p> <ol> <li> <p>Alternatively you can read more about setting up <code>ssh-agent</code> with a passphrase for better security.\u00a0\u21a9</p> </li> </ol>"},{"location":"exercises.html","title":"Guide to Programming Exercises","text":"<p>Programming exercises aim to help you practice the concepts taught in the course.  They are designed to be completed within a day.  You are encouraged to discuss and seek help from others if you get stuck.  However, you should ensure that you understand the resulting code and the concepts behind them, and not just copying the code blindly.</p>"},{"location":"exercises.html#github-setup","title":"GitHub Setup","text":"<p>You need a one-time setup at the beginning of the semester to link your PE account to your GitHub account.  Follow the instructions here to set up your GitHub account for CS2030S.</p>"},{"location":"exercises.html#vim-setup","title":"Vim Setup","text":"<p>You need a one-time setup at the beginning of the semester to install the standard vim configuration, color schemes, and plugins.  Follow the instructions here to set up your Vim for CS2030S.</p> <p>You will not be able to retrieve an exercise if the expected Vim-related directory cannot be found. </p>"},{"location":"exercises.html#github-classroom","title":"GitHub Classroom","text":"<p>We will use GitHub Classroom for our exercise release and submission for CS2030S.</p> <p>Here are what you need to do for every exercise:</p>"},{"location":"exercises.html#1-accept-the-exercise","title":"1. Accept the Exercise","text":"<p>Make sure that you have logged into GitHub.</p> <p>If you have multiple GitHub accounts, make sure you use the one with the same GitHub username you have submitted to us.</p> <p>Click on the given URL to accept the exercise. </p> <p>A repo will be created automatically for you.</p> <p>WARNING</p> <p>Do not interact with the repo directory using GitHub or other <code>git</code> commands.</p>"},{"location":"exercises.html#3-get-a-copy-on-pe-hosts","title":"3. Get a Copy on PE Hosts","text":"<p>Run the command <code>/opt/course/cs2030s/get exX</code> (where X is the exercise number) to clone a copy of the exercise on your home directory.  You will see a new directory named something like <code>exX-username</code> created, with the skeleton files inside.</p>"},{"location":"exercises.html#read-the-task","title":"Read the Task","text":"<ul> <li>The exercise task will be given in a markdown file named <code>exX-task.md</code> in the exercise directory.</li> <li>You can open it using the command <code>view exX-task.md</code> or <code>/opt/course/cs2030s/bin/glow -p exX-task.md</code>.  Alternatively, you can view it through the web browser on your GitHub repository.  We suggest that you get use to viewing it on the command line, as you will need to do so during the practical exams.</li> <li>Read through the question carefully before starting to complete the task.</li> </ul>"},{"location":"exercises.html#solving-the-task","title":"Solving the Task","text":"<p>You need to edit, compile, run, and test your code on the PE hosts.</p> <p>WARNING</p> <p>Do not edit your code directly on GitHub.</p>"},{"location":"exercises.html#testing-your-code","title":"Testing your Code","text":"<p>In CS2030S exercises, there are two types of test cases: unit tests to test individual classes or methods, and integration tests to test the whole program.  The task statements will indicate which type of tests are provided for each exercise.</p> <ul> <li> <p>The unit tests are given as part of the skeleton code in a file named <code>exX-test.jar</code>.  The command to run the unit tests is given in the task statements.</p> </li> <li> <p>The integration tests are given as input and expected output files in the <code>tests</code> sub-directory.  The command to run the integration tests is given in the task statements.  Typically, you run <code>/opt/course/cs2030s/test-main exX</code> to run the integration tests.</p> </li> </ul> <p>Students typically go through the edit-compile-test cycle multiple times to complete the exercise.</p>"},{"location":"exercises.html#4-submit-a-copy","title":"4. Submit a Copy","text":"<p>When you are ready to submit, run <code>/opt/course/cs2030s/submit exX</code> (where X is the exercise number).  This will do the following:</p> <ul> <li>Reformat your code according to the style guide </li> <li>Runs a checker on your code (see details below)</li> <li>Generate a report </li> <li>Submit a copy of the code and the report to GitHub.  </li> </ul> <p>You can submit multiple times, but your tutor is only obligated to read the last copy submitted before the deadline.</p> <p>If your submission is successful, you will see an output like this: <pre><code>submitting &lt;exercise&gt; for &lt;your name&gt;\nreformatting Java files...done\ncompiling...done\ntesting individual classes...done\ntesting Main...done\nlinting...done\nchecking style...done\ngenerating report...done\nsubmitting...\nupdating master branch...\n  :\n  :\npushing to GitHub...\nsubmitted.\n</code></pre></p> <p>If your code generates any warning or error during the pre-submission check, the errors will be displayed on the terminal.  You should fix them and submit again.</p> <p>WARNING</p> <p>Do not use <code>git push</code> or other <code>git</code> commands to submit your code to GitHub.</p> <p>Alias</p> <p>You may shorten the commands by creating aliases:</p> <pre><code>alias get=\"/opt/course/cs2030s/get\"\nalias submit=\"/opt/course/cs2030s/submit\"\n</code></pre>"},{"location":"exercises.html#pre-submission-check","title":"Pre-submission Check","text":"<p>The pre-submission check runs the following to properly validate your code before submission:</p> <ol> <li>It checks if your code compiles without errors.</li> <li>It runs all unit tests and integration tests (where applicable). </li> <li>It checks if your code follows the style guide (we used <code>checkstyle</code> with a custom configuration)</li> <li>It runs a linter to check for common mistakes (we used <code>pmd</code> with a custom configuration)</li> </ol> <p>WARNING</p> <p>In some exercises, some support files are provided to you as part of the skeleton code.  The task statements will clearly state that you are not supposed to modify these files.  If you run the <code>check</code> command, it may restore these files to their original versions.</p> <p>If you want to run the checker on your own without submission, run <code>/opt/course/cs2030s/check exX</code> (where X is the exercise number).  </p> <pre><code>After this, you can simply run `get exX`, `submit exX`, or `check exX`.  To setup these aliases automatically, you can put the three lines above in your `~/.bash_profile` (it will take effect the next time you log in).\n</code></pre> <p>You should fix any compilation errors, test failures, style errors, or linter warnings before submission.</p>"},{"location":"exercises.html#5-receiving-feedback","title":"5. Receiving Feedback","text":"<p>The tutors will provide feedback on your submission via Github after the deadline.  You can reply to their comment, etc, on GitHub as well. </p> <p>WARNING</p> <p>You should not change your code on GitHub after the deadline (by either re-running <code>submit</code> or using <code>git</code> commands directly) to avoid interfering with the feedback process.</p>"},{"location":"exercises.html#6-feedback-report-and-achievement-badges","title":"6. Feedback Report and Achievement Badges","text":"<p>A file named <code>feedback.md</code> that contains auto-graded output will be placed into your GitHub repo after your submission.  </p> <p>We will assign an achievement badge, which can be one of the following:</p> <ul> <li>Excellent Compiles without warning or style errors. Pass all test cases.</li> <li>Good Compiles with one or more warnings or style errors. Pass all test cases.</li> <li>Need Improvement Fail one or more test cases (including internal test cases)</li> <li>N/A Late submission; Submitted skeleton only; No submission; Submitted non-compilable code.</li> </ul> <p>These achievement badges help us keep track of the students' progress and give students a sense of their learning.  They do not contribute to the final grade.</p>"},{"location":"exercises.html#warning","title":"Warning","text":"<p>Let us repeat: You should only interact with your submissions on GitHub using the provided scripts <code>get</code> and <code>submit</code>.  Failure to do so will break our workflow and will not be appreciated.</p> <p>If you accidentally break your repo by running <code>git</code> commands on it or edit it directly on GitHub, you should save a copy of your code elsewhere, then reset your exercise directory, by (i) requesting your tutor to delete the repo on GitHub, (ii) deleting the corrupted directory on PE nodes, (iii) go through Steps 1 and 2 again, then copy back your edited code into the directory.</p>"},{"location":"exercises.html#timeline","title":"Timeline","text":"<p>The exercise is usually due on Tuesday afternoon, in the week following its released.  You must submit each exercise before the deadline to receive feedback from your tutors.</p> <p>The tutors have the right to refuse to read and give feedback on late submissions.</p>"},{"location":"exercises.html#general-advice","title":"General Advice","text":"<p>You are advised to (i) spend some time thinking before you begin coding, (ii) practice incremental coding, and (iii) test your programs thoroughly.</p> <p>Remember to spend some time thinking about the design and approach to solving each question.</p> <p>Incremental coding means do NOT type in the whole long program in a single session and then compile it. Instead, type your program in bits and pieces and compile it incrementally. Try to maintain a compilable program even while you are working on it. Submitting a compilable program that partially works is better than submitting an un-compilable one; this is especially important for your practical exams.</p> <p>You should test your program thoroughly with your test data before submission.</p> <p>You may assume that all input data are correct unless otherwise stated. Hence, you do NOT need to do input data validation. This is to allow you to focus on getting the program right, instead of worrying about making your program fool-proof.</p>"},{"location":"exercises.html#seeking-help-from-others","title":"Seeking Help from Others","text":"<p>We encourage students to discuss and seek help from each other, from the lab tutors, or from an AI, if they are stuck.  However, do note that students are responsibile to ensure that they understand the resulting code they produce and the concepts behind them, and not just copying the code blindly.  </p> <p>The exercises are meant to help you learn and practice the concepts taught in the course.  The exercises do not contribute to the final grade and therefore there is no point in plagiarizing code to solve the questions.  </p> <p>All exercises are designed to be completed within half a day.  If you get stuck on an issue for longer than that, you should talk to others.</p>"},{"location":"exercises.html#method-of-submission","title":"Method of Submission","text":"<p>Please follow the instructions above to submit your code to the tutors for comments.  Programs submitted through other means, such as emails, will NOT be accepted.</p>"},{"location":"exercises.html#use-of-ed","title":"Use of Ed","text":"<p>If you have doubts about the problem statements of an exercise, you may raise them on Ed.  But before that, please read through the problem statements carefully first, and check if the same questions have been asked and answered on the forum.</p> <p>Please exercise discretion when posting to Ed.  Before the deadline, if you need to post your solution, complete or partial, please use the spoiler\" feature.</p>"},{"location":"github.html","title":"Linking Your PE Account to Your GitHub Account","text":""},{"location":"github.html#prerequisites","title":"Prerequisites","text":"<ol> <li>You should already have your SoC Unix account, cluster access, and SoC VPN set up, and be able to <code>ssh</code> into one of the PE hosts.  If you are not able to do this, please look at the guide on programming environments.</li> <li>You should feel comfortable running basic UNIX commands.  If you have not gone through the UNIX guide and got your hands dirty, please look at the guide and play with the various basic Unix commands.</li> <li>You should already have a GitHub account and can log into GitHub.com.</li> <li>You have set up vim according to the set up instruction</li> </ol>"},{"location":"github.html#purpose","title":"Purpose","text":"<p>You will be using <code>git</code> (indirectly) for retrieving skeleton code and submitting completed assignments.  We will set up your accounts on a PE host below so that <code>git</code> will be associated with your GitHub account.  This is a one-time setup.  You don't have to do this for every programming exercise.</p>"},{"location":"github.html#1-setting-up-gitconfig","title":"1. Setting up <code>.gitconfig</code>","text":"<p>Run the following commands to configure <code>git</code>:</p> <pre><code>git config --global user.name &lt;your name&gt;\ngit config --global user.email &lt;your email&gt;\ngit config --global github.user &lt;your github user name&gt;\n</code></pre> <p>Your email should be whatever you used to sign up on GitHub (which may not be your SoC or NUS email).</p> <p>For example, </p> <pre><code>git config --global user.name \"Ah Beng\"\ngit config --global user.email \"ahbeng@example.com\"\ngit config --global github.user \"ahbeng67\"\n</code></pre> <p>After the above, you can check if the configuration is set correctly by running the following commands:</p> <pre><code>git config --get github.user\n</code></pre> <p>It should print your GitHub username as already set.  If there is a typo, you can rerun the corresponding command to edit the configuration.</p> <p>You can also check the file <code>~/.gitconfig</code> by running: <pre><code>cat ~/.gitconfig\n</code></pre></p> <p>It should show something like: <pre><code>[user]\n    name = Ah Beng\n    email = ahbeng@example.com\n[github]\n    user = ahbeng67\n</code></pre></p>"},{"location":"github.html#2-setting-up-password-less-login","title":"2. Setting up Password-less Login","text":"<ul> <li> <p>Login to GitHub.com using your account.  Ensure that you are using the account you registered for CS2030S.</p> </li> <li> <p>Go to the URL https://github.com/settings/tokens. Alternatively, Click on Your Profile Avatar -&gt; Settings -&gt; Developer Settings -&gt; Personal Access Tokens -&gt; Tokens (classic)</p> </li> </ul> <p>The page should say \"Personal access tokens (classic)\" at the top.</p> <ul> <li> <p>Click on \"Generate new token\" (on the top-right), then Generate new token (classic)  You will be asked to enter the following information:</p> </li> <li> <p>Note: Enter something meaningful to you to explain what this token is for</p> </li> <li>Expiration: Set a Custom duration that covers until the end of the semester (e.g., 15/05/2026)</li> <li>Select scopes: Select \"repo\" (all the subscopes will be selected automatically)</li> </ul> <p>After setting the above, click on the \"Generate token\" button at the bottom of the page.  </p> <p>Your personal access token will be created.  Copy-paste this to somewhere safe and private. We will be using it in the next step.</p> <p>Students who are actively using GitHub for other work and prefer to have finer control over the token permissions may choose to create fine-grain personal access token instead, and configure its permission to your personal preference.   </p>"},{"location":"github.html#3-accept-and-retrieve-a-test-skeleton-from-github","title":"3. Accept and Retrieve a Test Skeleton from GitHub","text":""},{"location":"github.html#31-accept-the-test-assignment","title":"3.1 Accept the Test Assignment","text":"<p>We have created an empty lab for you to test if you can correctly retrieve future lab files from GitHub.  Complete the following steps:</p> <ul> <li>Click here https://classroom.github.com/a/mdTUrnes to accept the assignment.  You should see the following page:</li> </ul> <p></p> <ul> <li>Click the accept button.  Wait a bit and then refresh until you see a \"You're ready to go\" message.</li> </ul> <p>If you see an error message saying \"Repository Access Issue\", check your email for an invitation message from github-classroom.  Click the link in the email to accept the invitation.  After accepting the invitation, go back to the link above and refresh the page again.  You should see a \"You're ready to go\" message.</p>"},{"location":"github.html#32-configure-the-pe-host-to-store-your-credentials","title":"3.2 Configure the PE Host to Store Your Credentials","text":"<p>Now, on your PE host, run <pre><code>git config --global credential.helper store\n</code></pre></p> <p>This step ensures that your GitHub credentials (username and personal access token) will be stored securely on the PE host so that you don't have to enter them every time you interact with GitHub.</p>"},{"location":"github.html#33-retrieve-the-test-skeleton","title":"3.3 Retrieve the Test Skeleton","text":"<p>Now, run <pre><code>/opt/course/cs2030s/get setup-test\n</code></pre></p>"},{"location":"github.html#34-authentication","title":"3.4 Authentication","text":"<p>You will then be asked for your username and password.</p> <p>For the username, enter your GitHub username.  For the password, paste your token from Step 2 above.  Note that there will be nothing shown on the screen when you type your token.  Just paste it and press Enter.</p>"},{"location":"github.html#35-results","title":"3.5 Results","text":"<p>If everything works well, you should see:</p> <p><pre><code>Cloning into 'setup-test-&lt;username&gt;'...\nUsername for 'https://github.com': &lt;username&gt;\nPassword for 'https://&lt;username&gt;@github.com': &lt;token&gt;\nremote: Enumerating objects: 9, done.\nremote: Counting objects: 100% (9/9), done.\nremote: Compressing objects: 100% (5/5), done.\nremote: Total 9 (delta 1), reused 6 (delta 0), pack-reused 0 (from 0)\nReceiving objects: 100% (9/9), done.\nResolving deltas: 100% (1/1), done.\n</code></pre> Change your working directory into <code>setup-test-&lt;username&gt;</code> and look at the directory content.  It should contain a file <code>README.md</code>. </p> <p>If you have followed the steps above correctly, any subsequent cloning of github repository does not require username and password to be inserted anymore.  Only Steps 3.1 and 3.3 need to be repeated for each programming exercise (but with different links and different exercise ID).  </p> <p>You can test by accepting ex0 and cloning it once it is ready.</p>"},{"location":"javadoc.html","title":"Javadoc","text":""},{"location":"javadoc.html#why-is-documentation-important","title":"Why is documentation important","text":"<p>One of the goals of CS2030S is to move you away from the mindset that you are writing code that you will discard after it is done (e.g., in CS1101S labs) and you are writing code that no one else will read except you.  CS2030S prepares you to work in software engineering teams in many ways, and one of the ways is to get you to document your code.</p> <p><code>javadoc</code> is a tool used to document Java code.  It automatically generates HTML documentation from the comments in your code.  The Java API that you have seen are generated from <code>javadoc</code>.</p>"},{"location":"javadoc.html#how-to-comment-for-javadoc","title":"How to comment for javadoc","text":"<p><code>javadoc</code> distinguishes between normal comments and comments meant for <code>javadoc</code> by how we \"fence\" the comments.  A <code>javadoc</code> comment always starts with <code>/**</code> (note the double asterisks) and ends with <code>*/</code> and is always placed immediately before a class, an interface, a constructor, a method, or field declaration.</p> <p>Example: <pre><code>/**\n * Encapsulates a circle on a 2D plane.  The operators supported \n * includes (i) checking if a point is contained in the circle,\n * and (ii) moving the circle to a new position.\n */\n</code></pre></p> <p>The first sentence is the summary sentence.  We should follow some style guidelines when writing the summary sentence (see below).</p> <p><code>javadoc</code> comments supports HTML tags.  If you are not familiar with HTML, that is fine.  We will tell you what you need to know below.</p>"},{"location":"javadoc.html#tags","title":"Tags","text":"<p><code>javadoc</code> supports tags.  Below are some tags that we would like you to use.  We use curly bracket (e.g., <code>{name}</code>) to indicate information that need to be filled in by you.</p> <ul> <li><code>@param {name} {description}</code>: describe the parameter <code>{name}</code></li> <li><code>@param &lt;{name}&gt; {description}</code>: describe the type parameter <code>{name}</code></li> <li><code>@return {description}</code> describe the return value</li> <li><code>@throws {class name} {description}</code> describe what the exception <code>{class name}</code> being thrown and what are the possible reasons</li> </ul> <p>Example</p> <pre><code>/** \n * Generate the content of the list.\n *\n * @param &lt;T&gt; The type of the elements in the list.\n * @param n The number of elements.\n * @param seed The first element.\n * @param f The transformation function on the elements.\n * @return The created list.\n */\npublic static &lt;T&gt; EagerList&lt;T&gt; generate(int n, T seed, Transformer&lt;T, T&gt; f) {\n  EagerList&lt;T&gt; eagerList = new EagerList&lt;&gt;(new ArrayList&lt;&gt;());\n  T curr = seed;\n  for (int i = 0; i &lt; n; i++) {\n    eagerList.list.add(curr);\n    curr = f.transform(curr);\n  }\n  return eagerList;\n}\n</code></pre> <p>Note how the <code>@param</code> are ordered.</p>"},{"location":"javadoc.html#style","title":"Style","text":"<ol> <li> <p>If you want to break your comments into paragraphs, insert one blank line between paragraphs.  Start a new paragraph with HTML tag <code>&lt;p&gt;</code> with no space after, and end your paragraph with HTML tag <code>&lt;/p&gt;</code>.</p> </li> <li> <p>You should use the tags <code>@param</code> <code>@return</code> and <code>@throws</code> in that order, and they should never appear without a description.</p> <ul> <li>The order of <code>@param</code> should follow how the parameters (including type parameters) appear in your method.</li> </ul> </li> <li> <p>The summary should be short and succinct.  It may not be a complete sentence, but it should still be capitalized and ends with a period.  E.g., <code>/** Encapsulates a circle on 2D plane. .. */</code></p> </li> <li> <p>You don't need to write <code>javadoc</code> for self-explanatory, simple, obvious, methods.  e.g., <code>getX()</code>, unless you want to explain what <code>x</code> means.  </p> </li> </ol>"},{"location":"javadoc.html#how-to-generate-javadoc","title":"How to generate javadoc","text":"<p>In its simplest form, you can generate <code>javadoc</code> like this:</p> <pre><code>javadoc *.java\n</code></pre> <p>This will generate the HTML files in your current directory.  </p> <p>To avoid clutters, I recommend that you specify the output directory, e.g.,</p> <pre><code>javadoc *.java -d docs\n</code></pre> <p>This will generate the documentation and put it under the <code>docs</code> subdirectory.</p> <p><code>javadoc</code> by default generates documents only for public classes, fields, and methods.  To generate documentation for everything, run</p> <pre><code>javadoc *.java -d docs -private\n</code></pre> <p>If you generate the documentation on your computer, you can view it by opening up the file <code>index.html</code> in your browser.</p>"},{"location":"javadoc.html#see-also","title":"See Also","text":"<ul> <li>Oracle's <code>javadoc</code> guide</li> </ul>"},{"location":"style.html","title":"CS2030/S Java Style Guide","text":""},{"location":"style.html#why-coding-style-is-important","title":"Why Coding Style is Important","text":"<p>One of the goals of CS2030/S is to move you away from the mindset that you are writing code that you will discard after it is done (e.g., in CS1101S missions) and you are writing code that no one else will read except you and your tutor.  CS2030/S prepares you to work in a software engineering team in many ways. One of the ways is to enforce a consistent coding style.</p> <p>If everyone on the team follows the same style, the intent of the programmer can become clear (e.g., is this a class or a field?), the code is more readable and less bug-prone (e.g., see the Apple <code>goto fail</code> bug for an example of buggy program due to style_).  Empirical studies support this:</p> <p>Quote</p> <p>\"It is not merely a matter of aesthetics that programs should be written in a particular style. Rather there is a psychological basis for writing programs in a conventional manner: programmers have strong expectations that other programmers will follow these discourse rules. If the rules are violated, then the utility afforded by the expectations that programmers have built up over time is effectively nullified. The results from the experiments with novice and advanced student programmers and with professional programmers described in this paper provide clear support for these claims.\"</p> <p>Elliot Soloway and Kate Ehrlich. \"Empirical studies of programming knowledge.\" IEEE Transactions on Software Engineering 5 (1984): 595-609.</p> <p>Many major companies enforce coding styles, and some have published them.  For CS2030, we base our (simplified) coding style on Google's Java Coding Style.  You should bookmark the link because you need to come back to it again and again.</p>"},{"location":"style.html#spacing-and-indentation","title":"Spacing and Indentation","text":"<ol> <li> <p>No tabs.  Use only whitespace.</p> <p>VIM Setting</p> <p>For <code>vim</code> users, the following setting in your <code>~/.vimrc</code> file:</p> <pre><code>set expandtab\n</code></pre> <p>causes Tab to be expanded to whitespace.</p> <p>For CS2030S</p> <p>This option is already included in the <code>~/.vimrc</code> file if you follow the Vim setup guide. In fact, we recommend you follow the Vim setup guide instead and don't manually manage your own version of your <code>~/.vimrc</code> file.</p> <p>Most other source code editors have similar configurations.</p> </li> <li> <p>Block indentation is exactly two spaces.</p> <pre><code>if (x == 0) {\n  x++;\n  for (i = 0; i &lt; x; i++) {\n    x += i;\n  }\n}\n</code></pre> <p>VIM Setting</p> <p>For <code>vim</code> users, in <code>~/.vimrc</code>, add the following:</p> <pre><code>set tabstop=2\nset shiftwidth=2\nset autoindent\nset smartindent\n\" For Java: enabling this includes Java-specific indentation settings that handle annotations like @Override\nfiletype plugin indent on\n</code></pre> <p>To help you with indentation.</p> <p>For CS2030S</p> <p>These options are already included in the <code>~/.vimrc</code> file if you follow the Vim setup guide. In fact, we recommend you follow the Vim setup guide instead and don't manually manage your own version of your <code>~/.vimrc</code> file.</p> <p>Most other source code editors have similar configurations.</p> </li> <li> <p>Each line is limited to 100 characters in length.     line into multiple lines to enhance readability, this is called line wrapping.  When you do so, each continuation line is indented at least 4 spaces from the original line.</p> <p>Good Example</p> <pre><code>void foo(double a, double b, double c, double d\n    double e, double f) {\n  if ((a &gt; b) &amp;&amp; (b &gt; c) &amp;&amp; (c &gt; d) &amp;&amp; (d &gt; e) &amp;&amp;\n      (e &gt; f)) {\n  }\n}\n</code></pre> <p>Bad Example</p> <pre><code>void foo(double a, double b, double c, double d\n  double e, double f) {\n    if ((a &gt; b) &amp;&amp; (b &gt; c) &amp;&amp; (c &gt; d) &amp;&amp; (d &gt; e) &amp;&amp;\n      (e &gt; f)) {\n    }\n}\n</code></pre> <pre><code>void foo(double a, double b, double c, double d\ndouble e, double f) {\n    if ((a &gt; b) &amp;&amp; (b &gt; c) &amp;&amp; (c &gt; d) &amp;&amp; (d &gt; e) &amp;&amp;\n    (e &gt; f)) {\n    }\n}\n</code></pre> </li> <li> <p>Indent comments at the same level as the surrounding code.  For multiple comments, align <code>*</code> with the previous line.</p> <p>Good Example</p> <pre><code>/*\n * Good style\n */\n</code></pre> <pre><code>/**\n * Good style for JavaDoc\n */\n</code></pre> <p>Bad Example</p> <pre><code>/*\n* Not a good style\n*/\n</code></pre> <pre><code>/**\n* Not a good style for JavaDoc\n*/\n</code></pre> <pre><code>/**\n  * Also not a good style for JavaDoc\n  */\n</code></pre> </li> <li> <p>White space should separate Java keywords from parenthesis and braces, and be added on both sides of binary operators (<code>+</code>, <code>-</code>, <code>/</code>, etc) as well as <code>:</code> in enhanced for-loop.  Space should also appear before and after <code>//</code> comments</p> <p>Good Example</p> <pre><code>if (x == 0) {\n    x++; // to make sure x is at least one.\n    for (i = 0; i &lt; x; i++) {\n        x += i;\n    }\n}\n</code></pre> <p>Bad Example</p> <p><code>Java if(x==0){     x++;//to make sure x is at least one.     for(i=0;i&lt;x;i++){     x+=i;     } }</code></p> </li> </ol>"},{"location":"style.html#classes","title":"Classes","text":"<ol> <li> <p>Each file contains exactly one top-level (i.e., non-nested) class.</p> </li> <li> <p>Each top-level class resides in a source file of its own.</p> </li> <li> <p>When a class has overladed methods (e.g., multiple constructors or methods of the same name), they appear sequentially with no other code in between.</p> </li> </ol>"},{"location":"style.html#braces","title":"Braces","text":"<ol> <li> <p>Braces are always used (even if the body is empty or contains a single statement)</p> </li> <li> <p>Use \"Egyptian brackets\":</p> <ul> <li>Opening brace has no line break before; but has a line break after</li> <li>Closing brace has a line break before; and has a line break after (except when there is <code>else</code> or comma following a closing brace).</li> </ul> <p>Good Example</p> <pre><code>if (x == 0) {\n    x++;\n}\n</code></pre> <p>Bad Example</p> <p><pre><code>if (x == 0) { x++; }\n</code></pre> <pre><code>if (x == 0) // Allman style (do not use)\n{\n    x++;\n}\n</code></pre> <pre><code>if (x == 0) // Pico style (do not use)\n{\n    x++; }\n</code></pre></p> </li> </ol>"},{"location":"style.html#lines","title":"Lines","text":"<ol> <li> <p>Exactly one blank line after <code>import</code> statements.</p> </li> <li> <p>Each statement is followed by a line break, no matter how short the statement is.</p> <p>Good Example</p> <pre><code>x++;\ni++;\n</code></pre> <p>Bad Example</p> <pre><code>x++; i++;\n</code></pre> </li> <li> <p>There should be a blank line between constructors, methods, nested classes and static initializers.  Blank lines can be used between fields to create logical groupings.</p> </li> </ol>"},{"location":"style.html#identifies","title":"Identifies","text":"<ol> <li> <p>One variable per declaration.</p> <p>Good Example</p> <pre><code>int x;\nint y;\n</code></pre> <p>Bad Example</p> <pre><code>int x, y;\n</code></pre> </li> <li> <p>No C-style array declaration</p> <p>Good Example</p> <pre><code>String[] args;\n</code></pre> <p>Bad Example</p> <pre><code>String args[];\n</code></pre> </li> <li> <p>Class modifiers appear in the following order:</p> <pre><code>public protected private abstract default static final transient volatile synchronized native strictfp\n</code></pre> <p>Good Example</p> <pre><code>public static void main(String[] args)\n</code></pre> <p>Bad Example</p> <pre><code>static public void main(String[] args)\n</code></pre> </li> <li> <p>Class names are written in UpperCamelCase; method names and field names in lowerCamelCase; and constant names in ALL_CAPS_SNAKE_CASE.  Type parameters in single capital letters.</p> </li> <li> <p>Static fields and methods must be accessed with their corresponding class names.</p> </li> </ol>"},{"location":"style.html#statements-and-annotations","title":"Statements and Annotations","text":"<ol> <li> <p>Switch statements always include a <code>default</code> case.</p> </li> <li> <p>One annotation per line.</p> </li> <li> <p>Always use <code>@Override</code>.</p> <pre><code>@Override\npublic boolean equals(Object o) {\n    :\n}\n</code></pre> </li> <li> <p>Caught exceptions should not be ignored.</p> </li> <li> <p>Avoid <code>import</code> using wildcards <code>*</code>.  Always import the specific class you need.     !!! success \"Good Example\"</p> <pre><code>```Java\nimport java.util.ArrayList;\nimport java.util.List;\n```\n</code></pre> <p>Bad Example</p> <pre><code>import java.util.*;\n</code></pre> </li> <li> <p>Import statement should be in alphabetical order.     !!! success \"Good Example\"</p> <pre><code>```Java\nimport java.util.ArrayList;\nimport java.util.List;\n```\n</code></pre> <p>Bad Example</p> <pre><code>import java.util.List;\nimport java.util.ArrayList;\n</code></pre> </li> </ol>"},{"location":"style.html#using-checkstyle","title":"Using <code>checkstyle</code>","text":"<p>To automatically check for style violations, we use a tool called <code>checkstyle</code>.</p> <p>Example of how to run:</p> <pre><code>java -jar /opt/course/cs2030s/bin/checkstyle.jar -c /opt/course/cs2030s/bin/checkstyle.xml *.java\n</code></pre> <p>The exercises and exams may have different stylecheck configurations.  See the corresponding instructions in the exercises/exam papers.</p> <p>Hint: put the command into a <code>bash</code> script so that you do not need to type such a long string all the time.</p>"},{"location":"style.html#using-google-java-format","title":"Using <code>google-java-format</code>","text":"<p>To automatically formar your code, we use a tool called <code>google-java-format</code></p> <p>We will automatically format your code using this tool when you submit your code.  As such, what you submit may be look different from the version of code that you have written.</p>"},{"location":"micro/operations.html","title":"Micro HOWTO: Common Code Editing Operations","text":""},{"location":"micro/operations.html#micro-as-a-source-code-editor","title":"Micro as a Source Code Editor","text":"<p>A source code editor is more than a text editor.  A source code editor is designed and optimized for common operations performed by a programmer while programming.  In this article, we summarize some common operations that you will likely perform and how you will perform them in Micro.</p>"},{"location":"micro/operations.html#code-browsing","title":"Code Browsing","text":"<p>Reading vs. Writing</p> <p>\u201c.. the ratio of time spent reading versus writing is well over 10 to 1. We are constantly reading old code as part of the effort to write new code.\" </p> <p>\u2015 Robert C. Martin, Clean Code: A Handbook of Agile Software Craftsmanship</p>"},{"location":"micro/operations.html#navigation-within-a-file","title":"Navigation Within a File","text":"<p>You need to go beyond using arrow keys to move character-by-character or line-by-line for better efficiency and productivity.  Some useful operations are:</p> Operation Cursor Position Forward Backward Move word-by-word Anywhere Alt+Right Alt+Left (Might not work on macOS due to conflict in keyboard shortcut) Move page-by-page Anywhere Page Down Page Up Move block-by-block Anywhere Alt+} Alt+{ (Might not work on macOS due to conflict in keyboard shortcut).  A block (or paragraph) is defined as consucutive non-empty lines.  This is useful for instance to navigate method-by-method, provided you have blank lines between two methods Next occurance of word A word Useful for looking for where a variable or method is defined/used Matching bracket A bracket Beginning/End of the file Anywhere Ctrl+Home Ctrl+End Might not work on macOS.  Useful for jump to the end of the file (e.g., to append a new method) or to the beginning of the file (e.g., to add comments) <p>To jump to a particular line, Ctrl+E to open the command bar, and issue the command <code>goto linenumber</code>.  For example, <code>goto 42</code> would jump to Line 42.</p>"},{"location":"micro/operations.html#navigation-between-files","title":"Navigation Between Files","text":""},{"location":"micro/operations.html#multiple-buffers","title":"Multiple Buffers","text":"<p>Scenario: Suppose you are reading the code about <code>Simulator</code> and you find that it uses a class called <code>Event</code>.  You want to read the definition <code>Event.java</code>.  </p> <p>You can use the command Ctrl+E to open the command bar, and issue the command <code>open Event.java</code> to tell Micro that you want to edit the file named <code>Event.java</code> now.  </p>"},{"location":"micro/operations.html#multiple-windows","title":"Multiple Windows","text":"<p>If you want to look at <code>Event.java</code> without closing <code>Simulator.java</code>, you can split the window.  Type Ctrl+E to open the command bar and issue the command <code>hsplit Event.java</code> or <code>vsplit Event.java</code> to split the buffer (horizontally and vertically).</p> <p>Use Ctrl+W to navigate between windows.</p>"},{"location":"micro/operations.html#multiple-tabs","title":"Multiple Tabs","text":"<p>Or you can open the file in a new tab with Ctrl+E <code>tab Event.java</code>.  Use Ctrl+E <code>tabswitch</code> to navigate between tabs.</p>"},{"location":"micro/operations.html#looking-for-things","title":"Looking for Things","text":"<p>When reading code, we often need to look for a specific variable, method, or type.  For instance, you might wonder, what a method does, or which line sets a field to <code>null</code>.  In such scenarios, it is useful to ask Micro to search for it, rather than just scrolling through the code and eyeballing it yourself.</p>"},{"location":"micro/operations.html#searching-for-a-string-in-the-current-file","title":"Searching for a String in the Current File","text":"<p>To search for a string, type, Ctrl+F followed by the string you are looking for.  The cursor will jump to the first occurrence of the string after the current cursor.  </p> <p>You can use Ctrl+N or Ctrl+P to jump to the next or previous occurrence of the string respectively.</p>"},{"location":"micro/operations.html#searching-for-a-string-across-files","title":"Searching for a String Across Files","text":"<p>Not supported by micro.  Need to install additional plugin (such as findinfolder.</p>"},{"location":"micro/operations.html#moving-things-around","title":"Moving Things Around","text":"<p>Often we need to move statements/blocks/methods/classes around, either to fix bugs or to tidy up our code.   This often involves two steps: (i) cutting/deleting what you want to move at the source, and (ii) pasting it to the destination.</p>"},{"location":"micro/operations.html#swapping-lines","title":"Swapping lines","text":"<p>Suppose we have two statements that are out of order.  For instance, we might write <pre><code>i = 2 * j;\nint j = 0;\n</code></pre> which does not compile.  We should, of course, declare and initialize <code>j</code> first before using it.  Placing the cursor on the line <code>i = 2 * j</code>, we can move this line down with Alt+Down (or Option+Down on macOS)</p>"},{"location":"micro/operations.html#reordering-multiple-lines","title":"Reordering Multiple Lines","text":"<p>If you want to cut multiple lines, place the cursor at the beginning of the line you want to cut.  Press Shift+Down to select the lines you want to move.   Then Alt+Down or Alt+Up to move it to the destination.</p> <p>Note that you cannot move the lines to a different file.  You can use the standard cut-and-paste keys Ctrl+X Ctrl+C for this purpose.</p> <p>Reformatting After Pasting</p> <p>After pasting a block of code, the indentation of the pasted code might be inconsistent.  You can use Tab or Shift+Tab to fix the indentation level of the selected text manually.</p>"},{"location":"micro/operations.html#changing-names","title":"Changing Names","text":""},{"location":"micro/operations.html#changing-the-name-of-one-typevariablemethod-call","title":"Changing the name of one type/variable/method call","text":"<p>Occasionally, we mix up our variable or our method name, and we need to fix it before the code runs correctly or compiles.  Suppose we have</p> <pre><code>double perimeter = circle.getArea();\n</code></pre> <p>and we realize that we should be calling <code>getPerimeter</code> instead. </p> <p>To change, (i) place the cursor at the beginning of <code>getArea</code>.  You can use the mouse or navigate word-by-word.   (ii) use Shift+Ctrl+Right to select the word <code>getArea</code> and Ctrl+X to cut.  Now type <code>getPerimeter</code> to replace the method name.</p>"},{"location":"micro/operations.html#changing-multiple-names-on-the-same-line","title":"Changing multiple names on the same line","text":"<p>Sometimes we have multiple occurrences that we wish to change on the same line.  Let's say:</p> <pre><code>Shape s = new Shape();\n</code></pre> <p>and we realize that we should be creating a <code>Circle</code> instead of a <code>Shape</code>.</p> <p>You only have one option, which is to repeat the above twice.  </p>"},{"location":"micro/operations.html#changing-multiple-occurrences-in-a-block","title":"Changing multiple occurrences in a block","text":"<p>Let's say that we copy the following method from a class <code>LeaveEvent.java</code> to <code>JoinEvent.java</code>:</p> <pre><code>  void updateTime(int now) {\n      if (this.time &gt; 1200) {\n          this.time = now;\n      } else {\n          this.time = 1200;\n      }\n  }\n</code></pre> <p>and we realize that, in <code>JoinEvent</code> the corresponding field is called <code>joinTime</code> instead of just <code>time</code>.  Now we need to rename all occurrences of <code>time`` within this block to become</code>joinTime`.  </p> <p>To do this, type Ctrl+E and issue the command <code>replace time joinTime</code>.  This will replace all occurances of <code>time</code> with <code>joinTime</code>.  By default, it will prompt the users to confirm each replacement. </p> <p>Go through each <code>time</code> to replace one-by-one, and confirm the replacement of those that falls within the block.  </p>"},{"location":"micro/operations.html#changing-all-occurrences-in-a-file","title":"Changing all occurrences in a file","text":"<p>Let's say that you have a type in the file <code>Rectangel.java</code>.  You have named your class <code>Rectangel</code> instead of <code>Rectangle</code>, and you want to fix all occurrences of this in the file.</p> <p>The command <code>replace Rectangel Rectangle -a</code> to replace all occurances for you.</p>"},{"location":"micro/operations.html#typing-long-java-names","title":"Typing Long Java Names","text":"<p>It is a good habit to give meaningful names to the variables, methods, and types in our programs.  To avoid cryptic names such as <code>noc</code>, it is recommended that we use English words, such as <code>numOfCustomers</code>.  Such names can get very long.  Even if you are a master in naming and avoid such long names in your own code, you will inevitably use Java libraries with long names.  Having a long name has several disadvantages.  First, it takes more keystrokes to type.  Second, it increases the likelihood of typos. </p> <p>Here is a useful trick that can save you from typing long names.  Abbreviation is not supported in Micro.</p>"},{"location":"micro/operations.html#auto-completion","title":"Auto-completion","text":"<p>You can type Tab to auto-complete a word.  So you only need to type the long name the first time.  Subsequently, type the prefix and auto-complete.  </p>"},{"location":"micro/operations.html#compiling-without-leaving-micro","title":"Compiling without Leaving Micro","text":"<p>During development, we go through many iterations of the edit-compile-test cycles.  It would save time if we could do so without leaving Micro.  </p>"},{"location":"micro/operations.html#terminal-mode","title":"TERMINAL mode","text":"<p>It is often useful to split your Micro window to open up a terminal.  First split your window by Ctrl+E <code>vsplit</code> or <code>hsplit</code>.  Then Ctrl+E <code>term</code> to launch the terminal.  From the terminal, you can run <code>javac</code> to compile and <code>java</code> to test.  You can either Ctrl+W to switch back to edit your code or Ctrl+D to close the terminal.</p>"},{"location":"micro/operations.html#invoking-shell-commands","title":"Invoking Shell Commands","text":"<p>You can use Ctrl+B to run a shell command without the terminal.  So Ctrl+B <code>javac *.java</code> would let you compile your code without even leaving Micro.</p>"},{"location":"unix/index.html","title":"Using Unix CLI","text":"<ul> <li>Background and Philosophy of Unix</li> <li>Essential Unix Commands</li> <li>Advanced Unix Commands</li> </ul>"},{"location":"unix/advanced.html","title":"Unix CLI: Advanced","text":"<p>This article is adapted from the notes of the Unix@Home Workshop  held in August 2020.</p> <p>Learning Objectives</p> <p>Students should</p> <ul> <li>appreciate the philosophy of Unix where small utility programs can be composed together to perform a complex task using the pipe <code>|</code> operator.</li> <li>be aware of basic Unix utilities: <code>echo</code>, <code>sort</code>, <code>uniq</code>, <code>grep</code>, <code>head</code>, and <code>tail</code>.</li> <li>be able to use basic pattern matching <code>*</code> <code>?</code> <code>[]</code> and <code>{}</code> in <code>bash</code>.</li> <li>know how to use Tab, Ctrl+P, and Ctrl+N to work more efficiently in <code>bash</code>.</li> <li>know how to save time and effort by automating long complex commands using <code>bash</code> scripts.</li> </ul>"},{"location":"unix/advanced.html#composing-programs-with","title":"Composing Programs with <code>|</code>","text":"<p>Another key innovation of Unix that led to its success is the invention of the <code>|</code> operator.</p> <p>Before Unix, operating systems tend to provide complex, monolithic, programs.  The philosophy of Unix, however, is to provide many small, simple, utility programs, that can be composed to complete a more complex task.  These small programs each do one thing only (and do it well) and so are easier to write and less prone to bugs.</p> <p>The composition of these utility programs relies on two things.  First, plain text is often used as input and output of the programs.  These allow the programs to understand each other easily.  Second, they use <code>|</code> to communicate with each other.  The <code>|</code> operator takes the standard output from one program and redirects it as the standard input of another program.</p> <p>For instance, <pre><code>$ cat test.txt | wc\n       1      11      64\n</code></pre> compose <code>cat</code> and <code>wc</code> together.  Recall that <code>cat</code> reads the content of the file and prints it to standard output.  Here, we pipe the standard output from <code>cat</code> to <code>wc</code>.  So now, these printed texts are redirected as the standard input to <code>wc</code>.</p> <p>But this is just the same as <pre><code>$ wc &lt; test.txt\n</code></pre> that we have seen before.  What's the power in <code>|</code>?  </p> <p>Now, recall that we have made copies of <code>test.txt</code> earlier, into <code>foo.txt</code> and <code>bar.txt</code>.  If you have not done so or have removed them, you can quickly reproduce the files with: <pre><code>$ cp test.txt foo.txt\n$ cp test.txt bar.txt\n</code></pre></p> <p>Let's suppose now I want to count the total number of words for all three files.  Instead of calling <code>wc</code> on each file one by one, and sum them up myself.  I can just run:</p> <pre><code>$ cat test.txt foo.txt bar.txt | wc\n       3      33     192\n</code></pre> <p>Here, <code>cat</code> reads the three files, concatenates their content, and passes the output to <code>wc</code> for counting.</p>"},{"location":"unix/advanced.html#useful-utilities","title":"Useful Utilities","text":"<p>Before we see more interesting examples of using <code>|</code>, let's move beyond <code>cat</code> and <code>wc</code>, and see what other simple tools are there in Unix.</p>"},{"location":"unix/advanced.html#head-and-tail","title":"<code>head</code> and <code>tail</code>","text":"<p><code>head</code> and <code>tail</code> print out the first \\(k\\) lines and last \\(k\\) lines from a file (or standard input if the file name is not given).  By default, \\(k\\) is 10, but you can pass in an argument to specify \\(k\\).</p> <pre><code>$ cat test.txt foo.txt bar.txt\nThis is a test file for learning Unix file management commands.\nThis is a test file for learning Unix file management commands.\nThis is a test file for learning Unix file management commands.\n$ cat test.txt foo.txt bar.txt | tail -1\nThis is a test file for learning Unix file management commands.\n</code></pre>"},{"location":"unix/advanced.html#echo","title":"<code>echo</code>","text":"<p><code>echo</code> simply prints out the command-line argument to the standard output.</p> <pre><code>$ echo \"hello world!\"\nhello world!\n</code></pre>"},{"location":"unix/advanced.html#sort","title":"<code>sort</code>","text":"<p><code>sort</code> rearrange the input lines in alphabetical order. <pre><code>$ sort\njohn\njane\npeter\nmary^D\njane\njohn\nmary\npeter\n</code></pre></p> <p>In the example above, I entered <code>john</code>, <code>jane</code>, <code>peter</code>, <code>mary</code> followed by Ctrl+D to signify the end of input.  <code>sort</code> prints out <code>jane</code>, <code>john</code>, <code>mary</code>, <code>peter</code>, in that order.</p>"},{"location":"unix/advanced.html#uniq","title":"<code>uniq</code>","text":"<p><code>uniq</code> remove any two consecutive lines that are the same.</p> <pre><code>$ uniq\n1\n2\n2\n2\n1\n1^D\n1\n2\n1\n</code></pre> <p>For instance, in the above, there are three consecutive lines of <code>2</code>, so only one remained.  There are also two consecutive lines of <code>1</code>, so only one remained.`</p>"},{"location":"unix/advanced.html#grep","title":"<code>grep</code>","text":"<p><code>grep</code> returns the lines of text from the given file (or the standard input) that matches the given string.  For instance, run</p> <pre><code>$ grep abc\n</code></pre> <p>and start typing in some lines of text, some containing <code>abc</code>, some do not.  <code>grep</code> will spew out into the standard output all the lines that contain the text <code>abc</code> somewhere.  As usual, hit Ctrl+D when you are done.</p>"},{"location":"unix/advanced.html#pipe-example","title":"Pipe Example","text":"<p>To give you an example of how useful <code>|</code> is, here is a real example.  When processing the registration of the workshop, I have quite a few registrations that are duplicates \u2014 students registered more than once.  I need a quick way to count how many unique registrants are there. So I keep the student ID of all registrants in a file called <code>ID</code>.  For instance, the file <code>ID</code> contains (not real data, of course)</p> <pre><code>A1234567X,CS\nA1234559A,CEG\nA1239999J,CEG\nA1234580K,CEG\nA1233210O,CS\nA1234567X,CS\nA1234581Q,ISC\nA1233216T,ISC\nA1239999J,CEG\n</code></pre> <p>Now, to count how many unique registrants, I just need to run:</p> <pre><code>$ cat ID | sort | uniq | wc -l\n    7\n</code></pre> <p>To count how many uniq registrants are <code>CEG</code> students, I just change it to: <pre><code>$ cat ID | sort | uniq | grep CEG | wc -l\n    3\n</code></pre></p>"},{"location":"unix/advanced.html#pattern-matching-in-bash","title":"Pattern Matching in <code>bash</code>","text":"<p>We now show you another productivity shortcut.  In an example earlier, you have seen how we passed in more than one file name into <code>cat</code>.  Recall that we can use Tab to auto-complete the file names, so we can hit fewer keys on the keyboards. Now, we show you there is an even faster way.</p> <p>Instead of <pre><code>$ cat test.txt foo.txt bar.txt | wc\n</code></pre></p> <p>We could just run <pre><code>$ cat *.txt | wc\n</code></pre></p> <p>The <code>*</code> is a special character in <code>bash</code> that represents 0 or more characters.  So, this command essentially says, <code>cat</code> any files that contain 0 or more characters, followed by <code>.txt</code>.</p> <p>The table below summarizes the useful patterns:</p> Pattern Matches <code>*</code> 0 or more characters <code>?</code> one character <code>[..]</code> one character, coming from the given set between <code>[</code> and <code>]</code>, <code>-</code> to indicate a range. <code>{.., ..}</code> Either one of the names, separated by <code>,</code>."},{"location":"unix/advanced.html#example-1","title":"Example 1:","text":"<pre><code>$ ls ???.txt\nbar.txt foo.txt\n</code></pre> <p>Since we use three <code>?</code>, it matches any file name with three characters followed by <code>.txt</code>.</p>"},{"location":"unix/advanced.html#example-2","title":"Example 2:","text":"<pre><code>$ ls [f-t]*t\nfoo.txt test.txt\n</code></pre> <p>The expression <code>[f-t]*t</code> matches all file names that start with the alphabet <code>f</code>, <code>g</code>, etc., until <code>t</code>, followed by zero or more characters, followed by <code>t</code>.</p>"},{"location":"unix/advanced.html#example-3","title":"Example 3:","text":"<pre><code>$ ls *.txt\nbar.txt foo.txt test.txt\n$ ls {fo,ba}??txt   \nbar.txt foo.txt\n</code></pre> <p>The expression <code>{fo,ba}??txt</code> matches any file names the start with either <code>fo</code> or <code>ba</code>, followed by two characters, followed by <code>txt</code>.</p>"},{"location":"unix/advanced.html#leveling-up-your-productivity-with-cli","title":"Leveling Up Your Productivity with CLI","text":""},{"location":"unix/advanced.html#minimizing-hand-movements","title":"Minimizing Hand Movements","text":"<p>You have seen how you can manage files and navigate around the directory structure, all by interacting with the command-line interface.  No windows. No mouse.  Just you, the keyboard, and the terminal.  You do not even need to use any arrow keys or function keys.  </p> <p>Why is this a big deal?  Let's look at the image of the keyboard below:</p> <p></p> <p>We only need to use the keys colored in pink.  And since these keys are concentrated in a small region on the keyboard, for most of us, we can reach the keys if we just position our hands over the keyboard<sup>1</sup>, we only need to move our fingers to type.  </p> <p></p>"},{"location":"unix/advanced.html#minimizing-typing","title":"Minimizing Typing","text":"<p>We can even minimize the movement of our fingers in several ways by typing less.  We have seen several ways where we have achieved these:</p> <ul> <li>Unix commands are named economically \u2014 they are often only a few characters long.</li> <li>We can use Tab to auto-complete a command or a file name.</li> <li>We can use Ctrl+P or Ctrl+N to repeat a previous command.</li> </ul> <p>There are many more <code>bash</code> shortcuts for productivity, if you are keen, take a look at this cheat sheet.</p> <p>You have also seen that Unix has many small, simple, utilities that we can compose to solve a task.  But composing them requires much typing:</p> <pre><code>$ cat ID | sort | uniq | grep CEG | wc -l\n</code></pre> <p>If we need to run this over and over again or share this command with someone, we can simply put these commands in a file, and then run it by invoking its name.  Such a file containing commands for the shell is called a shell script.</p> <p>For example, let's create a file named <code>hello.sh</code> containing the line <code>echo hello!</code> by: <pre><code>$ cat &gt; hello.sh\necho hello!^D\n</code></pre></p> <p>The extension <code>.sh</code> is not necessary, but it is just something I use so that I can tell that this file contains a shell script.  In the example above, <code>cat</code> will wait for me to enter something on the keyboard.  So I entered <code>echo hello!</code> followed by Ctrl+D to indicate the end of the input.</p> <p>Now, to execute this file, we run: <pre><code>$ bash hello.sh\nhello!\n</code></pre> or <pre><code>$ bash &lt; hello.sh\nhello!\n</code></pre></p> <p>Recall that we said Unix shells do not necessarily interact with the users.  This is an example.  We pass the file <code>hello.sh</code> to a new instance of <code>bash</code>, asking it to interpret the lines inside this file as commands to execute.  </p> <p>Remember that we want to minimize typing.  What if we can just pass the filename directly to <code>bash</code> to execute?</p> <pre><code>$ ./hello.sh\nbash: ./hello.sh: Permission denied\n</code></pre> <p>Here, we specify the relative path of the script <code>hello.sh</code>, including the prefix <code>./</code> (for reasons that we will explain later).  But we should get an error telling us <code>Permission defined</code>.  Recall from the <code>File Permissions</code> section that a file needs to have the executable <code>x</code> permission to be executed.  So we need to add this permission for ourselves: <pre><code>$ chmod u+x hello.sh\n$ ./hello.sh\nhello!\n</code></pre></p> <ol> <li> <p>The recommended placement of hands over the keyboard is so that the thumbs are over the Space bar, the left fingers are over A S D F, and the right fingers are over J K L ;.\u00a0\u21a9</p> </li> </ol>"},{"location":"unix/background.html","title":"Unix CLI: Background","text":"<p>This article is a replication of the notes from the Unix@Home Workshop held in August 2020.</p> <p>Learning Objectives</p> <p>Students should</p> <ul> <li>understand the basic terms: CLI, terminal, shell, command prompt.</li> <li>appreciate why CLI is more efficient.</li> <li>aware of the commonly used terminal control sequences.</li> </ul>"},{"location":"unix/background.html#what-is-command-line-interfaces","title":"What is Command-Line Interfaces?","text":"<p>The command-line interface, or just CLI for short, is an important interface that we, as computing professionals, interact with the computer for most of our day-to-day tasks.</p> <p>In contrast to graphical user interfaces where users use a mouse to click/drag on menus and windows to interact with a computer, the command-line interface uses a keyboard and text.  The users would type a command to instruct the computer to do something, and the computer would respond by displaying the reply to the user.</p> <p>CLI evolves from teletypes machines where users would interact with the computer through a typewriter-like machine (see Figure 2.2. of this article for an example).  Users would type a command on the keyboard, and the typewriter would print out, line-by-line, the output on a piece of paper.  This is the era before monitors and mice.  Again, driven by constraints and necessity, CLI interfaces are designed to be simple and economical.  The commands are short and fast to type; the responses are succinct.</p> <p> Figure 2.1.: A teletype device (Model 33 ASR) to interact with a computer. </p>"},{"location":"unix/background.html#why-cli-over-gui","title":"Why CLI over GUI?","text":"<p>Since CLI is designed to be economical, CLI is much more efficient and productive to use, in particular when we are interacting with a remote computer over the network \u2014 sending text back and forth is much more efficient than sending graphical elements over the network.  Each character takes up to two bytes, but each pixel alone takes up 3 bytes of data.</p> <p>Another reason why using CLI is faster and more productive is that user can keep their hands on the keyboard at all times and does not need to switch frequently between keyboard and mouse._  While research has shown that GUI and mouse are great for casual users, for software developers that need to type on the keyboard most of the time, having to switch between keyboard and mouse is a productivity-killer.</p> <p>Further, CLI commands typically provide a host of options that is accessible directly (in contrast to clicking through preference dialogues) from the command line, making these commands flexible and customizable.</p> <p>Finally, since these commands are just text, we can put together a sequence of commands easily as a script, to automate highly repetitive tasks.</p>"},{"location":"unix/background.html#what-is-a-terminal","title":"What is a Terminal?","text":"<p>With the advances in Cathode-ray tube (CRT), the teletype machine is replaced with computer terminals in the late 1970s.  Instead of printing the output on paper, the output from CLI is now printed on a monitor supporting 24x80 characters on screen in black and white (or green).</p> <p> Figure 2.2.: The VT100 Computer Terminal. </p> <p>In modern days, operating systems still use similar underlying functionalities to read in keyboard inputs and print the output as text to show to the users, but instead of these clunky special purpose devices, the functionality of a terminal is replaced by programs called terminal emulator or virtual terminal.  Examples include <code>Terminal</code> and <code>iTerm2</code> on macOS; <code>Windows Terminal</code> on Microsoft; <code>xterm</code> and <code>konsole</code> on Ubuntu, etc.  Many legacy control commands on these teletype machines remain in today's computing environment, such as the terminal control sequence.</p>"},{"location":"unix/background.html#what-is-a-shell","title":"What is a Shell?","text":"<p>The term CLI refers to a type of user interface.  To realize this interface, Unix computing environments rely on another type of program called shell.</p> <p>A shell usually works closely with a terminal to get inputs from the users, interpret the meaning of the inputs, execute the tasks (perhaps through the invocation of other programs), and returned the output to the user through the terminal.</p> <p>Note that a shell can run on its own without a terminal (it can read input from a file, and write the output to a file, for instance).</p> <p>There are many shells available, each with different bells and whistles to help improve our productivity.</p> <p>The most popular shell that comes as default on many Unix systems is <code>bash</code> or Bourne Again Shell.  This is the shell that we will use in this workshop and as default in the SoC Unix computing environment.</p> <p>Other popular shells are <code>fish</code> and Oh-my-zsh (<code>zsh</code>).</p>"},{"location":"unix/background.html#command-prompt","title":"Command Prompt","text":"<p>A shell has a command prompt. It typically looks something like this, but will be different depending on the default configuration on your machine:</p> <pre><code>ooiwt@pe111:~$\n</code></pre> <p>The prompt is where you type in a command for the shell to interpret and execute.</p> <p>In <code>bash</code>, the command prompt can be customized to include information such as the username, hostname, time, current working directory, etc.  It is customary to use the <code>$</code> sign as the final character of the prompt.  In our examples, we will just show <code>$</code> to indicate the command prompt.</p> <p>Depending on the habit, sometimes you are asked to type in a command \"into the terminal\", \"into the shell\", or \"into bash\".  They all mean the same thing: type in the command at the command prompt of the shell.</p>"},{"location":"unix/background.html#terminal-control-sequence","title":"Terminal Control Sequence","text":"<p>On the old teletype machines, a user can send special commands to the teletype machines to control their operation.  Many of these special commands still exist today, and can be triggered by hitting a combination of Ctrl and another key (i.e., a control sequence).</p> <p>The following lists some of the most useful control sequences to know:</p> <ul> <li> Ctrl+D signal the end of input to a program.  This is also used to exit from a shell (by telling the shell that you have no more input to send, and you are done with it). </li> <li> Ctrl+Z suspend the current running program.  This pauses the execution of the program (but not terminates it).  In the <code>bash</code> shell, the most recently suspended program can resume executing in the background with the command <code>bg</code> or be brought back to execution in the foreground again with the command <code>fg</code>.    </li> <li> Ctrl+C terminate the current running program. </li> <li> Ctrl+S freeze the terminal.  This is a legacy control command that pauses the output printing of a teletype machine.  You shouldn't need to use this control sequence. </li> <li> Ctrl+Q resume the terminal.  This is a legacy control command that resumes the printing of a teletype machine.  You shouldn't need to use this control sequence unless you accidentally hit Ctrl+S </li> </ul> <p>Ctrl+Z vs. Ctrl+C</p> <p>A common mistake for new students is to hit Ctrl+Z frequently if something goes wrong with their program \u2014 this behavior could lead to multiple suspended programs (which still occupy resources such as memory on the computer).  The right sequence to use is Ctrl+C \u2014 which terminates the program (and frees up the resources).</p> <p>Ctrl+S accidents</p> <p>Since Ctrl+S is used as the \"save\" shortcut in non-Unix environment, many students accidentally hit this control sequence, causing their terminal to freeze.  Don't panic if this happens.  Just hit Ctrl+Q and things will be back to normal.</p>"},{"location":"unix/background.html#references","title":"References","text":"<ul> <li>The Art of Unix Usability: Command Line Interfaces, by Eric Steven Raymond</li> </ul>"},{"location":"unix/essentials.html","title":"Unix CLI: The Essentials","text":"<p>This article is adapted from the notes of the Unix@Home Workshop held in August 2020.  It contains the essential knowledge that a CS2030S students need to survive using the PE nodes to do the labs (and to use a Unix CLI in general).</p> <p>Learning Objectives</p> <p>Students should</p> <ul> <li>be able to navigate comfortably in a Unix file system using shell commands <code>cd</code>, <code>pwd</code>, and <code>ls</code>.</li> <li>be able to use <code>.</code>, <code>..</code>, <code>~</code> or <code>/</code> to form a relative or absolute path name to a file.</li> <li>be able to organize files in a Unix file system using shell commands <code>mkdir</code>, <code>rmdir</code>, <code>mv</code>, <code>rm</code>, and <code>cp</code>.</li> <li>be able to view the content of the file using <code>cat</code>, <code>more</code> or <code>less</code>.</li> <li>be able to manage the permission of a file using <code>chmod</code>.</li> <li>be able to perform standard input/output redirection with <code>&lt;</code> and <code>&gt;</code>.</li> </ul>"},{"location":"unix/essentials.html#unix-directory","title":"Unix Directory","text":"<p>Unix organizes files according to a directory structure.  The following shows an example.</p> <p></p> <p>This structure is also known as a directory tree.  There are two important directories that you need to know.</p>"},{"location":"unix/essentials.html#root-directory","title":"Root Directory","text":"<p>The root directory is the directory at the top of the directory tree<sup>1</sup>. It is simply referred to as <code>/</code>, without any name.  Under the root directory are many other system directory, which a casual user does not normally need to (and have no permission to) modify.</p>"},{"location":"unix/essentials.html#home-directory","title":"Home Directory","text":"<p>Each user has his/her own home directory.  The above figure shows where the home directory of the user <code>ooiwt</code> resides in the directory tree. The user <code>ooiwt</code> may create files or directories in his/her home directory, but not elsewhere unless permission is given.</p> <p>The home directory is referred to with the symbol <code>~</code> in <code>bash</code>.  Sometimes we add the username behind <code>~</code> to indicate the home directory of the other user. E.g., <code>~bob</code> means the home directory of a user named <code>bob</code>.</p>"},{"location":"unix/essentials.html#current-working-directory","title":"Current Working Directory","text":"<p>A user can navigate around the directory tree.  The current working directory is the directory that the user is currently in.  In contrast to the root and home directory, which are fixed<sup>2</sup>, the current working directory changes as the user moves around.  Knowing the current working directory is important since this is the default location in the directory tree a command executes.  As such, many systems by default display the current working directory as part of the <code>bash</code> command prompt.</p> <p>The current working directory is referred to with the symbol <code>.</code> in <code>bash</code>.</p>"},{"location":"unix/essentials.html#parent-directory","title":"Parent Directory","text":"<p>The parent directory is directory one layer up from the current directory.</p> <p>The parent directory is referred to with the symbol <code>..</code> in <code>bash</code>.</p> <p>To summarize, here are the short form representations:</p> Symbol Meaning <code>/</code> the root directory <code>~</code> the home directory <code>.</code> the current working directory <code>..</code> the parent directory"},{"location":"unix/essentials.html#specifying-a-path","title":"Specifying a Path","text":"<p>To specify a directory or a file in the Unix directory tree, we can use either the absolute path or the relative path.</p>"},{"location":"unix/essentials.html#absolute-path","title":"Absolute path","text":"<p>The absolute path is constructed as follows, starting from the root of the directory structure, find a path (a sequence of directories) to the location that you want to specify, then concatenate the names of the directories together, separated by the forward-slash <code>/</code>.  This is a similar notation used for Website URLs, so you should already be familiar with it.  For instance, the path <code>/home/o/ooiwt</code> is the absolute path of the directory named <code>ooiwt</code> in the figure above.</p> <p>An absolute path is independent of the current working directory and always start with <code>/</code> or <code>~</code></p>"},{"location":"unix/essentials.html#relative-path","title":"Relative path","text":"<p>The relative path is dependent on the current working directory.  To refer to another location, start from the current directory, and find a path (a sequence of directories) to the location that you refer to.  When we go up a tree, we use <code>..</code> to represent the directory.</p> <p>For example, referring to the figure above, if we are in the directory <code>/home/b</code>, and we wish to refer to <code>/home/o/ooiwt</code>, we can use the relative path <code>../o/ooiwt</code>.  If we wish to refer to <code>/home/b/bob</code>, we can use the relative path <code>bob</code>.</p> <p>A relative path never starts with <code>/</code>.</p>"},{"location":"unix/essentials.html#directory-related-commands","title":"Directory-related Commands","text":"<p>Now, let's take a look at some basic commands available in <code>bash</code> that deals with navigation and directories.</p>"},{"location":"unix/essentials.html#pwd-print-current-working-directory","title":"<code>pwd</code>: Print Current Working directory","text":"<p><code>pwd</code> shows you which directory you are currently in.  Type <code>pwd</code> into the command prompt, and it will print the absolute path to your current working directory. For instance, Suppose you are in <code>/home/o/ooiwt</code>, entering</p> <pre><code>pwd\n</code></pre> <p>will give the output</p> <pre><code>/home/o/ooiwt\n</code></pre>"},{"location":"unix/essentials.html#ls-list-content-of-a-directory","title":"<code>ls</code>: LiSt content of a directory","text":"<p>The <code>ls</code> list the content in the current working directory.</p> <p>Rule of Silence</p> <p>Unix follows the economical rule of silence: programs should not print unnecessary output, to allow other programs and users to easily parse the output from one program.  So, if <code>ls</code> has nothing to list, it will list nothing (as opposed to, say, printing \"This is an empty directory.\")</p> <p>In Unix, a file or directory with a name that starts with <code>.</code> is hidden from <code>ls</code>.  Common hidden files are <code>.vimrc</code>, the configuration file for <code>vim</code>, and <code>.ssh</code>, the directory to store your SSH keys and configuration.  To view all the files, including hidden files, run <code>ls</code> with the <code>-a</code> flag (<code>a</code> stands for all).</p>"},{"location":"unix/essentials.html#mkdir-make-a-subdirectory","title":"<code>mkdir</code>: MaKe a subDIRectory","text":"<p>The <code>mkdir</code> command creates a subdirectory with the given name in the current directory.</p> <p>In the example below, we assume that we start with an empty directory.</p> <pre><code>$ ls\n$ mkdir workshop\n$ ls\nworkshop\n$ ls -F\nworkshop/\n</code></pre> <p>Here, we create a directory called <code>workshop</code>.  Now, when we <code>ls</code>, you can see the directory listed.</p> <p>You may also use <code>ls -F</code> for more information (<code>-F</code> is one of the many options/flags available for the <code>ls</code> command. To see a complete list of the options, refer to the man pages, i.e., <code>man ls</code>).</p> <p>The slash <code>/</code> beside the filename tells you that the file is a directory.  A normal file does not have a slash beside its name when \"ls -F\" is used.</p> <p>You may also use the <code>ls -l</code> command (hyphen el, not hyphen one) to display almost all the file information, include the size of the file and the date of modification.</p> <p>Use Up Arrow for Command History</p> <p><code>bash</code> maintains a history of your previously executed commands, and you may use the Ctrl+P (previous) and Ctrl+N (next) to go through it. Press the Ctrl+P until you find a previously executed command. You may then press Enter to execute it or edit the command before executing it. This is handy when you need to repeatedly execute a long <code>bash</code> command.</p>"},{"location":"unix/essentials.html#cd-change-directory","title":"<code>cd</code>: Change Directory","text":"<p>To navigate in the directory tree, changing the current working directory from one to another, we use the <code>cd</code> command.</p> <pre><code>$ pwd\n/home/o/ooiwt\n$ cd workshop\n$ pwd\n/home/o/ooiwt/workshop\n</code></pre> <p>Suppose our starting working directory is <code>/home/o/ooiwt</code>, after we <code>cd</code> into <code>workshop</code>, the current working directory becomes <code>/home/o/ooiwt/workshop</code>.  Note that <code>cd</code> can take in either an absolute path or a relative path.  The example above takes in a relative path as the argument.</p> <p>As mentioned in \"Unix CLI: Background\", it is common to include the current working directory into the shell's prompt.  So, you may see your command prompt updated to include the new working directory.</p> <p>Entering <code>cd</code> alone (without argument) brings you back to your home directory.  </p>"},{"location":"unix/essentials.html#rmdir-remove-a-subdirectory","title":"<code>rmdir</code>: ReMove a subDIRectory","text":"<p><code>rmdir</code> removes a subDIRectory in the current directory \u2014 note that a directory must be empty before it can be removed.</p> <p>The command</p> <pre><code>$ rmdir workshop\n</code></pre> <p>will remove the directory that you just created.</p>"},{"location":"unix/essentials.html#file-management","title":"File Management","text":"<p>This note assumes that you are familiar with navigation with the Unix directory structure.</p> <p>We will now learn some commands to help us deal with files.</p> <p>Let's recreate the <code>workshop</code> directory in case you have already deleted it with the <code>rmdir</code> at the end of the last unit.</p> <pre><code>$ mkdir -p workshop\n$ cd workshop\n$ ls\n</code></pre> <p>All the above commands should complete successfully and silently.  Let's populate the directory with a new file.  Cut-and-paste the command below into the command prompt:</p> <pre><code>wget https://www.comp.nus.edu.sg/~ooiwt/unix-workshop/test.txt\n</code></pre> <p>You should see a file being downloaded and saved with an output similar to below:</p> <pre><code>--2020-07-27 15:26:49--  https://raw.githubusercontent.com/nus-unix-workshop/2021-s1/master/test.txt\nResolving raw.githubusercontent.com (raw.githubusercontent.com)... 151.101.0.133, 151.101.64.133, 151.101.128.133, ...\nConnecting to raw.githubusercontent.com (raw.githubusercontent.com)|151.101.0.133|:443... connected.\nHTTP request sent, awaiting response... 200 OK\nLength: 64 [text/plain]\nSaving to: \u2018test.txt\u2019\n\ntest.txt              100%[======================&gt;]      64  --.-KB/s    in 0s\n\n2020-07-27 15:26:50 (2.35 MB/s) - \u2018test.txt\u2019 saved [64/64]\n</code></pre> <p>Now run <code>ls</code>, and you should see that <code>ls</code> returns <code>test.txt</code> as the content of the current working directory.</p> <pre><code>$ ls\ntest.txt\n</code></pre>"},{"location":"unix/essentials.html#cp-copy-files","title":"<code>cp</code>: CoPy files","text":"<p>Now let's try to copy this file to another name.</p> <pre><code>$ cp test.txt foo.txt\n$ ls\ntest.txt foo.txt\n</code></pre> <p>The command above copies the file <code>test.txt</code> into <code>foo.txt</code>.</p> <p>If you want to copy the whole directory, use <code>-r</code> flag, where <code>r</code> stands for copying recursively.</p> <p>Now let's create another directory called <code>copy</code>.</p> <pre><code>$ cd ..\n$ mkdir copy\n$ cd copy\n$ ls\n</code></pre> <p>Run <code>pwd</code> to double-check that you are in the directory called <code>copy</code> that is at the same level as <code>workshop</code>.</p> <p>Now, we are going to use <code>cp</code> with the <code>-r</code> flag, to copy recursively the whole of <code>workshop</code> directory over.</p> <pre><code>$ cp -r ../workshop .\n</code></pre> <p>The command <code>cp</code> takes in two arguments, the first is the source, and the second is the destination.</p> <p>Note that we use <code>.</code> above to indicate that we wish to copy the whole subtree of <code>workshop</code> over the current directory.  The command should complete without any message.  Upon completion, you can run <code>ls</code> to double-check that the workshop directory exists under <code>workshop</code>.</p> <p><code>cp</code> Overwrites</p> <p>If there is an existing file with the same name, <code>cp</code> will overwrite the existing file without warning.</p>"},{"location":"unix/essentials.html#mv-move-or-rename-files","title":"<code>mv</code>: MoVe or rename files","text":"<p>Now, let's change directory back to <code>workshop</code>.</p> <pre><code>$ cd ../workshop\n</code></pre> <p>and use the <code>mv</code> command to rename <code>foo.txt</code> into <code>bar.txt</code>.</p> <pre><code>$ ls\nfoo.txt test.txt\n$ mv foo.txt bar.txt\n$ ls\nbar.txt test.txt\n</code></pre> <p>As you can see above, just like <code>cp</code>, <code>mv</code> takes in two arguments, the first is the source and the second is the destination.</p> <p>If the destination of <code>mv</code> is a directory, however, instead of renaming, the <code>mv</code> commands move the source to the destination directory.</p> <pre><code>$ ls\nbar.txt test.txt\n$ mv ../copy/workshop/foo.txt .\n$ ls\nbar.txt foo.txt test.txt\n</code></pre> <p>Here, you can see that we have moved <code>foo.txt</code> over to the current directory.</p> <p><code>mv</code> Overwrites</p> <p>If there is an existing file with the same name, <code>mv</code> will overwrite the existing file without warning. <code>mv</code> comes with a <code>-i</code> flag that interactively asks you if you are sure if you want to overwrite a file.  It is a good idea to always run <code>mv -i</code>. Hit Y to continue overwriting the existing file.  You can look up on the Internet on how to make <code>-i</code> the default using <code>alias</code> command in <code>.bashrc</code>.</p> <p>Use Tab for Name Completion</p> <p>If you have a very long file name, you may use the <code>bash</code> auto-completion feature to reduce typing. For instance, you may type:</p> <pre><code>$ mv t\n</code></pre> <p>and press the Tab key, <code>bash</code> will complete the filename for you if there is only one filename with the prefix \"t\". Otherwise, it will fill up the filename to the point where you need to type in more characters for disambiguation. The Tab key can also complete the name of a command.</p>"},{"location":"unix/essentials.html#rm-remove-files","title":"<code>rm</code>: ReMove files","text":"<p>We can use <code>rm</code> to remove files.  Be careful with this command \u2014 files deleted cannot be restored.  There is no trash or recycled bin like in Mac or Windows.</p> <pre><code>$ ls\nbar.txt foo.txt test.txt\n$ rm foo.txt\n$ ls\nbar.txt test.txt\n</code></pre> <p><code>rm -rf</code></p> <p>While the Unix command line provides lots of flexibility and power, with great power comes great responsibility.  Some commands are extremely dangerous.  <code>rm -rf *</code> is the most famous one.  The notation <code>*</code> refers to all files, and the flag <code>-f</code> means forceful deletion (with no question asked!), and <code>-r</code> means remove recursively everything under the current directory tree.  Accidentally running this command has ruined many lives.  Read more here</p> <p><code>rm</code> comes with a <code>-i</code> flag that interactively asks you if you are sure if you want to delete a file.  It is a good idea to always run <code>rm -i</code>.</p> <pre><code>$ rm -i bar.txt\nrm: remove regular file 'bar.txt'?\n</code></pre> <p>Type <code>y</code> or <code>n</code> to answer yes or no respectively.</p>"},{"location":"unix/essentials.html#cat-catenate-file-content-to-screen","title":"<code>cat</code>: CATenate file content to screen","text":"<p>To quickly take a look at the content of the file, use the <code>cat</code> command.</p> <pre><code>$ cat test.txt\nThis is a test file for learning Unix file management commands.\n</code></pre> <p><code>less</code> is a variant of <code>cat</code> that includes features to read each page leisurely and is useful for long files.</p> <pre><code>$ less test.txt\n</code></pre> <p>In <code>less</code>, use <code>&lt;space&gt;</code> to move down one page, <code>b</code> to move Back up one page, and <code>q</code> to Quit.</p>"},{"location":"unix/essentials.html#man-online-manual","title":"<code>man</code>: Online MANual","text":"<p>An online help facility is available in Unix via the <code>man</code> command (<code>man</code> stands for MANual). To look for more information about any Unix command, for example, <code>ls</code>, type <code>man ls</code>. Type <code>man man</code> and refer to Man Pages to find out more about the facility. To exit <code>man</code>, press <code>q</code>.</p>"},{"location":"unix/essentials.html#file-permission-management","title":"File Permission Management","text":"<p>File permissions determine who can do what to a file.  Typically, you do not need to fiddle with the file permission, but when you need to, it is usually for an important reason, and it is critical to do it right.</p>"},{"location":"unix/essentials.html#the-what-of-file-permissions","title":"The What of File Permissions","text":"<p>Let's look at what you can do to a file first.  Unix file permissions allow control of three actions: <code>r</code> (read), <code>w</code> (write) and <code>x</code> (execute).  These permission settings allow the following different actions to be done for regular files and directories.</p> permission effect on file effect on directory <code>r</code> reading the content of a file read the names of the files in the directory <code>w</code> writing into a file create/delete/rename files in the directory <code>x</code> executing a file access contents and meta-info (size, creation time) of files in the directory <p>These three actions can be controlled independently.</p> <p>The permissions on a file can be expressed in two ways:</p> <ul> <li> <p>using symbolic notation.  For instance,  <code>rwx</code>, <code>r-x</code>, <code>-wx</code>, where a <code>-</code> means that the corresponding permission is not given (in the order of <code>r</code>, <code>w</code>, <code>x</code>).</p> </li> <li> <p>using a numerical notation. This notation uses a digit between 0 and 7, which is computed as a sum of the individual digit representing the permissions: <code>r</code> is represented with 4, <code>w</code> is represented with 2, and <code>x</code> is represented with 1. For instance, <code>r-x</code> has a numerical representation of 5, and <code>-wx</code> has a numerical representation of 3.</p> </li> </ul>"},{"location":"unix/essentials.html#the-who-of-file-permissions","title":"The Who of File Permissions","text":"<p>Unix divides the users into three classes: <code>u</code> is the user who owns the file; <code>g</code> refers to the users in the same group as the user; and <code>o</code> are all the other users.</p> <p>The permissions can be controlled separately for these classes of users.  The permission notation simply concatenates the file permissions of each class of users together, in the order of <code>u</code>, <code>g</code>, and <code>o</code>.</p> <p>For instance, the permission of 644, or <code>rw-r--r--</code>, on a file means that:</p> <ul> <li>the owner can read and write</li> <li>the group users can only read</li> <li>all the other users can only read</li> </ul>"},{"location":"unix/essentials.html#checking-file-permission","title":"Checking file permission","text":"<p>You can view the permission of a file by using the <code>ls -l</code> command (<code>l</code> for long format):</p> <pre><code>$ ls -l test.txt\n-rw-r--r--@ 1 ooiwt  staff  64 Jul 28 09:52 test.txt\n</code></pre> <p>Ignoring the first <code>-</code> and the last <code>@</code>, you can see that the permission of <code>test.txt</code> is 644.</p>"},{"location":"unix/essentials.html#the-chmod-command","title":"The <code>chmod</code> command","text":"<p>You can use <code>chmod</code> command to change the permissions of a file or a directory.</p> <p>For instance,</p> <pre><code>$ chmod 666 test.txt\n$ ls -l test.txt\n-rw-rw-rw-@ 1 ooiwt  staff  64 Jul 28 09:52 test.txt\n</code></pre> <p>would change add the permission <code>w</code> to both group and other users<sup>1</sup>.</p> <p>An alternative way is to just specify the changes.  To remove the permission to write from others, you can run:</p> <pre><code>$ chmod o-w test.txt\n$ ls -l test.txt\n-rw-rw-r--@ 1 ooiwt  staff  64 Jul 28 09:52 test.txt\n</code></pre>"},{"location":"unix/essentials.html#common-scenarios-for-chmod","title":"Common Scenarios for <code>chmod</code>","text":"<p>Here are some scenarios where you might need to use the <code>chmod</code> command:</p> <ul> <li> <p>If you use the SoC Unix server to do your homework, you should prevent the directory that stores your homework from being accessible by other users.  Make sure that your homework directory as the permission of <code>700</code>.</p> </li> <li> <p>If you download a file from the Internet and you do not have the permission to read it, you should do a <code>u+r</code> to give yourself the read permission.</p> </li> <li> <p>A program should have execution permission to run.  If you have a script or an executable file that you can't run, give yourself the execution permission <code>u+x</code>.</p> </li> </ul>"},{"location":"unix/essentials.html#standard-inputoutput","title":"Standard Input/Output","text":""},{"location":"unix/essentials.html#history","title":"History","text":"<p>Two of the design decisions of Unix that lead to its simplicity are the decisions to (i) decouple the physical input/output devices from the programs, allowing programs written for Unix to read from abstract input and output devices; and (ii) make all programs read and write from these abstract input and output devices by default.  Before Unix, the older operating systems often require programmers to painstakingly set up connections to the teletype machines and other devices for reading inputs and printing outputs.   With Unix, programmers can now focus on solving the tasks at hand and let Unix takes care of the input and output.</p> <p>The two abstract devices that Unix provides are called standard input and standard output.  By default, the standard input refers to the keyboard and the standard output is the terminal.</p>"},{"location":"unix/essentials.html#examples-using-cat-and-wc","title":"Examples using <code>cat</code> and <code>wc</code>","text":"<p>Let's look at these concepts closer, by examining some examples.</p> <p>Remember <code>cat</code>?  The <code>cat</code> command takes in a filename and it prints the content of the file to the standard output.</p> <pre><code>$ cat test.txt\nThis is a test file for learning Unix file management commands.\n</code></pre> <p>If no filename is given, <code>cat</code> by default try to read from the standard input.  Try running:</p> <pre><code>$ cat\n</code></pre> <p>You will see that the command is waiting for you to type in something.  Type in anything, as soon as you press Enter, <code>cat</code> is going to read in the text from the standard input, as if it is the content of a file, and then prints the content to the standard output.  You can keep typing, supplying text to <code>cat</code>, or you can type Ctrl+D to send the end-of-input command to <code>cat</code>.</p> <p>Let's look at another command, <code>wc</code>.  <code>wc</code> is a utility that counts the number of lines, words, characters.  If we call <code>wc</code> and supply it a file name, it will count the number of lines, words, and characters in that given file.</p> <pre><code>$ wc test.txt\n       1      11      64 test.txt\n</code></pre> <p>The output means that there is 1 line, 11 words, and 64 characters in the file <code>test.txt</code>.</p> <p>But if you do not pass in any file name, <code>wc</code> is going to read in the text from the standard input, as if it is the content of a file, and prints the three counters to the standard output.  Go ahead and try:</p> <pre><code>$ wc\n</code></pre> <p>You will see that the <code>wc</code> command is waiting for you to type in something.  Type in a few sentences, you can hit Enter for a new line.  When you are done, type Ctrl+D.  <code>wc</code> will count the number of lines, words, and characters for the text that you just entered.</p>"},{"location":"unix/essentials.html#output-redirection","title":"Output Redirection","text":"<p>By defining two abstract input and output devices (or channels), Unix frees the programmers from worrying about where to read the input from and write the output to.  Most of the time, we can write the output of the program to the standard output.  In instances where we need to write the output to another location, we can just redirect the output.</p> <p>The operators <code>&gt;</code> and <code>&gt;&gt;</code> are used to redirect the standard output to a file.  The difference is that <code>&gt;</code> will overwrite the given file, while <code>&gt;&gt;</code> will concatenate into the given file.</p> <p>For example:</p> <pre><code>$ wc test.txt &gt; test.count\n$ cat test.count\n       1      11      64 test.txt\n</code></pre> <p>The first command redirects the output from <code>wc</code> to a file named <code>test.count</code>, so you do not see anything printed to the output anymore.  We can check by running <code>cat</code> on the new file <code>test.count</code> \u2014 indeed the original output from <code>wc</code> is now stored in the file <code>test.count</code>.</p> <p>If we repeat the command <code>wc test.txt &gt; test.count</code> again, you can see that the file has been overwritten with the output from <code>wc</code> again.  But if we replace <code>&gt;</code> with <code>&gt;&gt;</code>, a new line is concatenated into <code>test.count</code>.   So the file now has two lines.</p> <pre><code>$ wc test.txt &gt; test.count\n$ cat test.count\n       1      11      64 test.txt\n$ wc test.txt &gt;&gt; test.count\n$ cat test.count\n       1      11      64 test.txt\n       1      11      64 test.txt\n</code></pre>"},{"location":"unix/essentials.html#input-redirection","title":"Input Redirection","text":"<p>The operator <code>&lt;</code> is used to redirect a file into the standard input. So, instead of reading from the keyboard, we can now read from a file.  Commands such as <code>cat</code> and <code>wc</code> already support from a file directly, so there is no difference in terms of functionality to run the commands by passing in the file name, or by using the <code>&lt;</code> operator.</p> <pre><code>$ wc test.txt\n       1      11      64 test.txt\n$ wc &lt; test.txt\n       1      11      64\n$ cat test.txt\nThis is a test file for learning Unix file management commands.\n$ cat &lt; test.txt\nThis is a test file for learning Unix file management commands.\n</code></pre> <p>Note the slight difference in the output format of the second <code>wc</code> above \u2014 it no longer prints the file name since from <code>wc</code> points of view, it is read from the standard input and not from a file, so it is not aware of the file named <code>test.txt</code></p> <p>In most CS programming assignments, however, to keep things simple, you will be asked to read from the standard input only, so the <code>&lt;</code> is a great time-saver \u2014 you do not have to repeatedly type in the same input data over and over from the keyboard.  You can just save the input data in a file, then redirect it to standard input with the <code>&lt;</code> operator.</p>"},{"location":"unix/essentials.html#other-useful-online-tools","title":"Other Useful Online Tools","text":"<ul> <li>explainshell explain each shell command for you</li> </ul> <ol> <li> <p>Giving write permission to other users is a security risk.  You should not do this unless you know what you are doing.\u00a0\u21a9\u21a9</p> </li> <li> <p>Not exactly true \u2014 since Unix is designed to be flexible, even the root and the home directory can be changed!  But let's not worry about that for now since there is no good reason to do that as a beginner.\u00a0\u21a9</p> </li> </ol>"},{"location":"vim/index.html","title":"Vim","text":"<ul> <li>The Philosophy of Vim</li> <li>Setting up Vim for CS2030S</li> <li>Quick Lessons</li> <li>Vim Tips</li> <li>Color Scheme and Plugins</li> </ul>"},{"location":"vim/cheatsheet.html","title":"VIM Cheat Sheets","text":""},{"location":"vim/cheatsheet.html#cursor-movement","title":"Cursor Movement","text":"<p>In <code>NORMAL</code> mode.</p> Keys Description H \u00a0\u00a0 (or Left) Move cursor to the left (you may use arrow keys if <code>.vimrc</code> is set correctly) J \u00a0\u00a0 (or Down) Move cursor down (you may use arrow keys if <code>.vimrc</code> is set correctly) K \u00a0\u00a0 (or Up) Move cursor up (you may use arrow keys if <code>.vimrc</code> is set correctly) L \u00a0\u00a0 (or Right) Move cursor to the right (you may use arrow keys if <code>.vimrc</code> is set correctly) <code>n</code> H \u00a0\u00a0 (or <code>n</code> Left) Move cursor <code>n</code> steps to the left (you may use arrow keys if <code>.vimrc</code> is set correctly) <code>n</code> J \u00a0\u00a0 (or <code>n</code> Down) Move cursor <code>n</code> steps down (you may use arrow keys if <code>.vimrc</code> is set correctly) <code>n</code> K \u00a0\u00a0 (or <code>n</code> Up) Move cursor <code>n</code> steps up (you may use arrow keys if <code>.vimrc</code> is set correctly) <code>n</code> L \u00a0\u00a0 (or <code>n</code> Right) Move cursor <code>n</code> steps to the right (you may use arrow keys if <code>.vimrc</code> is set correctly) G G Go to the first line Shift + G Go to the last line } Jump to next paragraph { Jump to previous paragraph : <code>n</code> Go to line number <code>n</code>"},{"location":"vim/cheatsheet.html#edit","title":"Edit","text":"<p>In <code>NORMAL</code> mode.</p> Commands Description <code>:e</code> Edit file (i.e., open) <code>:w</code> Write file (i.e., save) <code>:q</code> Quit file (only works if file is unchanged) <code>:q!</code> Force quit (even if file is changed) <code>:wq</code> Write file and quit Keys Description Y Y Yank (i.e., copy) a line D D Delete (i.e., copy) a line P Paste after cursor Shift + P Paste before cursor U Undo Ctrl + R Redo = Auto-indent current line <code>n</code> Y Y Yank (i.e., copy) <code>n</code> lines <code>n</code> D D Delete (i.e., copy) <code>n</code> lines <code>n</code> = = Auto-indent <code>n</code> lines G G = Shift + G Auto-indent all lines <p>The last keys can be split into 3 components:</p> <ol> <li>G G: Go to the first line</li> <li>=: Auto-indent</li> <li>Shift + G: Go to the last line</li> </ol> <p>This reads as (1.) go to the first line, then (2.) auto-indent (3.) until the last line.</p>"},{"location":"vim/cheatsheet.html#search-and-replace","title":"Search and Replace","text":"<p>In <code>NORMAL</code> mode.</p> Commands Description <code>/&lt;pattern&gt;</code> Search for <code>&lt;pattern&gt;</code> <code>?&lt;pattern&gt;</code> Search backward for <code>&lt;pattern&gt;</code> <code>:%s/&lt;old&gt;/&lt;new&gt;/gc</code> Replace all <code>&lt;old&gt;</code> with <code>&lt;new&gt;</code> (this will prompt options) <code>:&lt;sn&gt;,&lt;en&gt;s/&lt;old&gt;/&lt;new&gt;/gc</code> Replace all <code>&lt;old&gt;</code> with <code>&lt;new&gt;</code> in the given line range from <code>&lt;sn&gt;</code> to <code>&lt;en&gt;</code> (this will prompt options) <p>Once a search is performed.</p> Keys Description N Continue search forward Shift + N Continue search backward <p>Options for replace</p> Option Description <code>y</code> Yes, replace the current one <code>n</code> No, skip this one <code>a</code> Yes to all <code>l</code> Yes to just this one <code>q</code> Quit"},{"location":"vim/cheatsheet.html#comment-and-uncomment","title":"Comment and Uncomment","text":"<p>We can quickly comment on a specific range of lines using the replace functionality.  The idea is to replace the beginning of a line with <code>//</code> (i.e., to start a single-line comment).  We need to \"escape\" the <code>/</code> character by writing it as <code>\\/\\/</code>To match the beginning of the line, the character is <code>^</code>.</p> <p>Comment out Lines 4 to 17.</p> <pre><code>:4,17s/^/\\/\\//gc\n</code></pre> <p>We can also quickly uncomment a specific range of lines by replacing <code>//</code> with nothing.</p> <p>Uncomment Lines 4 to 17.</p> <pre><code>:4,17s/\\/\\///gc\n</code></pre> <p>Simply replace <code>4</code> and <code>17</code> with the range that you need.</p>"},{"location":"vim/cheatsheet.html#split-screen","title":"Split Screen","text":""},{"location":"vim/cheatsheet.html#commands","title":"Commands","text":"Keys Description <code>:sp &lt;filename&gt;</code> Open file name <code>&lt;filename&gt;</code> in horizontal split screen <code>:vsp &lt;filename&gt;</code> Open file name <code>&lt;filename&gt;</code> in vertical split screen <code>:e &lt;filename&gt;</code> Open the file name <code>&lt;filename&gt;</code> in the current screen"},{"location":"vim/cheatsheet.html#navigation","title":"Navigation","text":"Keys Description Ctrl + W Ctrl + W Change screen Ctrl + W H Change to the right screen Ctrl + W J Change to the down screen Ctrl + W K Change to the up screen Ctrl + W L Change to the left screen"},{"location":"vim/cheatsheet.html#java","title":"Java","text":"Keys Description <code>:!javac &lt;filename&gt;.java</code> Compile the java file <code>&lt;filename&gt;.java</code> <code>:!java &lt;classname&gt;</code> Run the class <code>&lt;classname&gt;</code> <code>:!jshell &lt;filename&gt; &lt;filename&gt; ...</code> Start JShell with the given <code>&lt;filename&gt;</code>s"},{"location":"vim/operations.html","title":"Vim HOWTO: Common Code Editing Operations","text":""},{"location":"vim/operations.html#vim-as-a-source-code-editor","title":"Vim as a Source Code Editor","text":"<p>A source code editor is more than a text editor.  A source code editor is designed and optimized for common operations performed by a programmer while programming.  In this article, we summarize some common operations that you will likely perform and how you will perform them in Vim.</p>"},{"location":"vim/operations.html#code-browsing","title":"Code Browsing","text":"<p>Reading vs. Writing</p> <p>\u201c.. the ratio of time spent reading versus writing is well over 10 to 1. We are constantly reading old code as part of the effort to write new code.\" </p> <p>\u2015 Robert C. Martin, Clean Code: A Handbook of Agile Software Craftsmanship</p> <p>As a programmer, we spend a significant amount of time reading source code.  This behavior explains why Vim starts in normal mode for reading and optimizes many shortcuts for navigating source code.  </p>"},{"location":"vim/operations.html#navigation-within-a-file","title":"Navigation Within a File","text":"<p>You need to go beyond using arrow keys to move character-by-character or line-by-line for better efficiency and productivity.  Some useful operations are:</p> Operation Cursor Position Forward Backward Move word-by-word Anywhere w b Move page-by-page Anywhere CTRL-f CTRL-b Move block-by-block Anywhere { } A block (or paragraph) is defined as consucutive non-empty lines.  This is useful for instance to navigate method-by-method, provided you have blank lines between two methods Next occurance of word A word * # Useful for looking for where a variable or method is defined/used Matching bracket (, ), [, ], {, }, &lt;, or &gt; % % Jump to the matching opening/closing bracket.  Useful for quickly jumping to the start/end of a code block or to check for balanced brackets. Beginning/End of the file Anywhere G gg Useful for jump to the end of the file (e.g., to append a new method) or to the beginning of the file (e.g., to add <code>import</code> statements) Beginning/End of the line Anywhere 0 $ Useful for jumping to the end of the line to insert comment or to the beginning to comment out the whole line. <p>&lt;count&gt;-&lt;movement&gt;</p> <p>Instead of repeating the commands above \\(k\\) times, you can issue the command \\(k\\) followed by the movement.  For instance, 6w would move forward by six words.  4-CTRL-f would move forward by 4 pages.</p> <p>To jump to a particular line, issue the command <code>:linenumber</code>.  For example, <code>:42</code> would jump to Line 42.</p>"},{"location":"vim/operations.html#navigation-between-files","title":"Navigation Between Files","text":""},{"location":"vim/operations.html#multiple-buffers","title":"Multiple Buffers","text":"<p>Scenario: Suppose you are reading the code about <code>Simulator</code> and you find that it uses a class called <code>Event</code>.  You want to read the definition <code>Event.java</code>.  There are several ways:</p> <ul> <li> <p>Place the cursor under the identifier <code>Event</code>, then type <code>gf</code> (go-to file).  Vim will load the file <code>Event.java</code>.  After you are done, to go back to the previous file, use CTRL-^ (^ refers to go-back UP).</p> </li> <li> <p>Alternatively, you can use the command <code>:e Event.java</code> to tell Vim that you want to edit the file named <code>Event.java</code> now.  </p> </li> </ul>"},{"location":"vim/operations.html#multiple-windows","title":"Multiple Windows","text":"<p>If you want to look at <code>Event.java</code> without closing <code>Simulator.java</code>, you can split the window with <code>:sp Event.java</code> or <code>:vsp Event.java</code> to split the buffer (horizontally and vertically).</p> <p>Use CTRL-w CTRL-w to navigate between windows.</p> <p>You can launch Vim with multiple windows, with </p> <pre><code>vim -O &lt;list of files&gt;\n</code></pre> <p>or </p> <pre><code>vim -o &lt;list of files&gt;\n</code></pre> <p>For example,</p> <p><pre><code>vim -o *.java\n</code></pre> would open all Java files, one in each window.</p>"},{"location":"vim/operations.html#multiple-tabs","title":"Multiple Tabs","text":"<p>Or you can open the file in a new tab with <code>:tabf Event.java</code>.  Use <code>gt</code> to navigate between tabs.</p> <p><pre><code>vim -p *.java\n</code></pre> would open all Java files, one in each tab.</p>"},{"location":"vim/operations.html#looking-for-things","title":"Looking for Things","text":"<p>When reading code, we often need to look for a specific variable, method, or type.  For instance, you might wonder, what a method does, or which line sets a field to <code>null</code>.  In such scenarios, it is useful to ask Vim to search for it, rather than just scrolling through the code and eyeballing it yourself.</p>"},{"location":"vim/operations.html#searching-for-a-string-in-the-current-file","title":"Searching for a String in the Current File","text":"<p>To search for a string, type, in NORMAL mode, <code>/</code> followed by the string you are looking for.  The cursor will jump to the first occurrence of the string after the current cursor.</p> <p>You can use <code>n</code> or <code>N</code> to jump to the next or previous occurrence of the string respectively.</p> <p>Another useful key is <code>#</code> or <code>*</code>, already mentioned above, for searching the current word the cursor is under.</p>"},{"location":"vim/operations.html#searching-for-a-string-across-files","title":"Searching for a String Across Files","text":"<p>Sometimes it is useful to search across all Java files for an identifier.</p> <p>You can do this through the <code>grep</code> command.  For example,</p> <pre><code>:grep Circle *.java\n</code></pre> <p>would search for all <code>Circle</code> occurrences in all the files with the suffix <code>.java</code>.</p> <p>After this, you can type <code>:cn</code> or <code>:cp</code> to jump to the next and previous results, even if it is in different files.</p> <p>If there are too many matches and you only want to go to a specific one, use <code>:copen</code> to open up the list of matches in a separate window, then select the specific match that you wish to jump to.</p>"},{"location":"vim/operations.html#comparing-two-files","title":"Comparing Two Files","text":"<p>You can compare two files with Vim, using the <code>-d</code> flag. For instance,</p> <pre><code>vim -d file1 file2\n</code></pre> <p>would open up two files for line-by-line comparison. This is most useful if you want to compare the output of your program with the expected output and figure out the difference.</p>"},{"location":"vim/operations.html#moving-things-around","title":"Moving Things Around","text":"<p>Often we need to move statements/blocks/methods/classes around, either to fix bugs or to tidy up our code.  We can do that in Vim NORMAL or VISUAL mode.  This often involves two steps: (i) cutting/deleting what you want to move at the source, and (ii) pasting it to the destination.</p>"},{"location":"vim/operations.html#swapping-lines","title":"Swapping lines","text":"<p>Suppose we have two statements that are out of order.  For instance, we might write <pre><code>i = 2 * j;\nint j = 0;\n</code></pre> which does not compile.  We should, of course, declare and initialize <code>j</code> first before using it.  Placing the cursor on the line <code>i = 2 * j</code>, we can perform the two steps above. (i) Type <code>dd</code> to delete the line (essentially move it into the clipboard).  The cursor will move to the line <code>int j = 0</code>.  (ii) Type <code>p</code> to paste it after the current line.</p> <p><code>ddp</code> essentially swaps two lines.</p> <p>You can prefix the command with a number \\(k\\) to delete \\(k\\) lines.</p>"},{"location":"vim/operations.html#reordering-multiple-lines","title":"Reordering Multiple Lines","text":"<p>If you want to cut more lines than you can/willing to count, VISUAL mode is a great way to select the lines to cut.  Place the cursor at the beginning of the line you want to cut.  Press SHIFT-V to enter VISUAL-LINE mode.  Now, use any of the movement commands to move and select the lines you want to cut (remember, if possible you should avoid using arrow keys or <code>j</code> or <code>k</code> to move line-by-line).   Press <code>d</code> to delete.</p> <p>Now navigate to where you want to paste and press <code>p</code>.</p> <p>Note that you can navigate to a different file to paste.  This is useful if you want to move a method from one class to another.</p> <p>Reformatting After Pasting</p> <p>After pasting a block of code, the indentation of the pasted code might be inconsistent.  Make it a habit to use <code>gg=G</code> to reindent your code after pasting.</p>"},{"location":"vim/operations.html#copy-pasting","title":"Copy-Pasting","text":"<p>If you need to copy-paste your code, you should first pause and think about whether you have violated the abstraction principles.</p> <p>If there is a valid reason to copy-paste, then you can use <code>y</code> (stands for yank) for copying text to the clipboard for pasting elsewhere.  <code>y</code> behaves similarly to <code>d</code>:</p> <ul> <li><code>yy</code> would copy the current line</li> <li><code>y</code> in VISUAL mode would copy the selected lines.</li> </ul>"},{"location":"vim/operations.html#commenting-multiple-lines-of-code","title":"Commenting Multiple Lines Of Code","text":"<p>You can edit multiple lines in VISUAL BLOCK mode.  This is useful for commenting and uncommenting multiple lines of code.</p> <p>First, move the cursor at the beginning of a line.  Go into VISUAL BLOCK mode with CTRL-V or CTRL-Q<sup>1</sup>, then select the lines that you want to comment.</p> <p>Type SHIFT-I to insert in VISUAL BLOCK mode, type <code>//</code> and then <code>ESC</code> to go back to NORMAL mode.  The text <code>//</code> would be inserted in front of each line selected.</p> <p>To uncomment, select <code>//</code> on each line that you wish to uncomment, and <code>x</code> to delete them.</p>"},{"location":"vim/operations.html#changing-names","title":"Changing Names","text":""},{"location":"vim/operations.html#changing-the-name-of-one-typevariablemethod-call","title":"Changing the name of one type/variable/method call","text":"<p>Occasionally, we mix up our variable or our method name, and we need to fix it before the code runs correctly or compiles.  Suppose we have</p> <pre><code>double perimeter = circle.getArea();\n</code></pre> <p>and we realize that we should be calling <code>getPerimeter</code> instead.  Instead of using <code>backspace</code> or <code>delete</code> to delete the characters one by one, we can use <code>cw</code> to change the word <code>getArea</code> into <code>getPerimeter</code>.</p> <p>To do so, (i) place the cursor at the beginning of <code>getArea</code>.  Remember to avoid using arrow keys or <code>h</code> or <code>l</code> to move letter-by-letter.  You can use <code>w</code> or <code>b</code> for faster word-by-word navigation.   (ii) type <code>cw</code> to remove the word <code>getArea</code> and enter INSERT mode.  Now type <code>getPerimeter</code> to replace the method name and ESC to return back to NORMAL mode.</p>"},{"location":"vim/operations.html#changing-multiple-names-on-the-same-line","title":"Changing multiple names on the same line","text":"<p>Sometimes we have multiple occurrences that we wish to change on the same line.  Let's say:</p> <pre><code>Shape s = new Shape();\n</code></pre> <p>and we realize that we should be creating a <code>Circle</code> instead of a <code>Shape</code>.</p> <p>One option is to use <code>cw</code> twice.  But we could also use the substitute command, like so.</p> <p>Place the cursor on this line, and type <code>:s/Shape/Circle/gc</code>, and then ENTER.  Here is what it does:</p> <ul> <li><code>:</code> allows us to issue a command to Vim</li> <li><code>s/&lt;what to substitute&gt;/&lt;substitute with this&gt;/</code> tells Vim what we want to replace and replace with what.</li> <li><code>g</code> stands for <code>global</code> and it says that we want to substitute all occurrences </li> <li><code>c</code> is optional, and it tells Vim to confirm every replacement with us.</li> </ul>"},{"location":"vim/operations.html#changing-multiple-occurrences-in-a-block","title":"Changing multiple occurrences in a block","text":"<p>Let's say that we copy the following method from a class <code>LeaveEvent.java</code> to <code>JoinEvent.java</code>:</p> <pre><code>  void updateTime(int now) {\n      if (this.time &gt; 1200) {\n          this.time = now;\n      } else {\n          this.time = 1200;\n      }\n  }\n</code></pre> <p>and we realize that, in <code>JoinEvent</code> the corresponding field is called <code>joinTime</code> instead of just <code>time</code>.  Now we need to rename all occurrences of <code>time</code> within this block to become <code>joinTime</code>.</p> <p>One way to do this is to use the substitute command again.  There are several ways.</p> <p>If there are only a few lines and you can count the size of the scope within which you want to search and replace, you place your cursor at the beginning of the method and issue the command <code>:.,+4s/time/joinTime</code>.  Here <code>.</code> refers to the current line; <code>,</code> is a separator, <code>+4</code> refers to the next four lines.</p> <p>Suppose your cursor is far away and you have the line number turned on.  Let say the method above appears at Lines 125 to 131.  You can issue the command <code>:125,131s/time/joinTime</code>.</p> <p>Alternatively, you can use VISUAL-LINE mode.  Place the cursor at the beginning of the method, and press SHIFT-V.  This enters the VISUAL-LINE mode.  Now, navigate to select the scope within which you want to search and replace (<code>5j</code> or <code>}</code> works in this case), and press <code>:</code>.  You will see that the command prompt is pre-filled with <code>:'&lt;,'&gt;</code> to signify the selected range.  Continue typing <code>s/time/joinTime</code> and ENTER.</p>"},{"location":"vim/operations.html#changing-all-occurrences-in-a-file","title":"Changing all occurrences in a file","text":"<p>Let's say that you have a type in the file <code>Rectangel.java</code>.  You have named your class <code>Rectangel</code> instead of <code>Rectangle</code>, and you want to fix all occurrences of this in the file.  You can use <code>%</code> to signify that the range of substitution is the entire file.</p> <p>The command <code>:%s/Rectangel/Rectangle/g</code> should replace all occurances for you.</p>"},{"location":"vim/operations.html#typing-long-java-names","title":"Typing Long Java Names","text":"<p>It is a good habit to give meaningful names to the variables, methods, and types in our programs.  To avoid cryptic names such as <code>noc</code>, it is recommended that we use English words, such as <code>numOfCustomers</code>.  Such names can get very long.  Even if you are a master in naming and avoid such long names in your own code, you will inevitably use Java libraries with long names.  Having a long name has several disadvantages.  First, it takes more keystrokes to type.  Second, it increases the likelihood of typos. </p> <p>Here are two useful tricks that can save you from typing long names.</p>"},{"location":"vim/operations.html#auto-completion","title":"Auto-completion","text":"<p>You can type CTRL-P or CTRL-N in NORMAL mode to auto-complete a word.  So you only need to type the long name the first time.  Subsequently, type the prefix and auto-complete.</p>"},{"location":"vim/operations.html#abbreviation","title":"Abbreviation","text":"<p>You can setup a temporary abbreviation in your <code>~/.vimrc</code>.  Example <pre><code>ab noc numOfCustomers\n</code></pre></p> <p>After the configuration is read, you only need to type <code>noc</code> in your code and it will be automatically expanded to <code>numOfCustomers</code>.</p>"},{"location":"vim/operations.html#compiling-without-leaving-vim","title":"Compiling without Leaving Vim","text":"<p>During development, we go through many iterations of the edit-compile-test cycles.  It would save time if we could do so without leaving Vim.</p>"},{"location":"vim/operations.html#terminal-mode","title":"TERMINAL mode","text":"<p>It is often useful to split your Vim window to open up a terminal, by the <code>:terminal</code> command.  From the terminal, you can run <code>javac</code> to compile and <code>java</code> to test.  You can either CTRL-w CTRL-w to switch back to edit your code or CTRL-D to close the terminal.</p>"},{"location":"vim/operations.html#invoking-shell-commands","title":"Invoking Shell Commands","text":"<p>You can use <code>:!</code> to run a shell command without the terminal.  So <code>:!javac *.java</code> would let you compile your code without even leaving Vim.</p>"},{"location":"vim/operations.html#fixing-mistakes","title":"Fixing Mistakes","text":""},{"location":"vim/operations.html#undo-and-redo","title":"Undo and Redo","text":"<p><code>u</code> undoes the last action.  Ctrl-R redoes the action. </p> <p>A related command <code>.</code>, which repeats the last action.</p>"},{"location":"vim/operations.html#backup-files","title":"Backup Files","text":"<p>In case, you accidentally wrote over your precious code, or messed up in other ways, the last saved copy of your files can be found under <code>~/.backup</code>.  You can copy it back out.</p>"},{"location":"vim/operations.html#swap-files","title":"Swap Files","text":"<p>Vim automatically saves the files you are editing into temporary swap files, with the extension .swp. These files are hidden, so you don't normally see them when you run ls. (You need to run ls -a to view the hidden files)</p> <p>The swap files are useful if your editing session is disrupted before you save (e.g., the network is disconnected, you accidentally close the terminal, your OS crashes, etc).</p> <p>When you launch vim to edit a file, say, <code>Circle.java</code>. vim will check if a swap file <code>.Circle.java</code>.swp` exists. If it does, vim with display the following</p> <pre><code>Found a swap file by the name \".Circle.java.swp\"\n          owned by: elsa   dated: Sat Aug 21 15:01:04 2021\n         file name: ~elsa/Circle.java\n          modified: no\n         user name: elsa   host name: pe116\n        process ID: 7863 (STILL RUNNING)\nWhile opening file \"Circle.java\"\n             dated: Mon Jul 12 18:38:37 2024\n\n(1) Another program may be editing the same file.  If this is the case,\n    be careful not to end up with two different instances of the same\n    file when making changes.  Quit, or continue with caution.\n(2) An edit session for this file crashed.\n    If this is the case, use \":recover\" or \"vim -r Circle.java\"\n    to recover the changes (see \":help recovery\").\n    If you did this already, delete the swap file \".Circle.java.swp\"\n    to avoid this message.\n\nSwap file \".Circle.java.swp\" already exists!\n[O]pen Read-Only, (E)dit anyway, (R)ecover, (Q)uit, (A)bort:\n</code></pre> <p>The messages above are self-explanatory. Read it carefully. Most of the time, you want to choose \"R\" to recover your edits, so that you can continue editing. Remember to remove the file <code>.Circle.java.swp</code>after you have recovered. Otherwise, vim will prompt you with the above messages every time you edit `Circle.java``.</p> <p>Warning</p> <p>If Circle.java is newer than the state saved in <code>.Circle.java.swp</code>, and you recover from <code>.Circle.java.swp</code>, you will revert to the state of the file as saved in the swap file. This can happen if (i) you edited the file without recovery, or (ii) you recovered the file, and continued editing, but did not remove the <code>.Circle.java.swp</code> file after.  The latest changes to <code>Circle.java</code> would be lost.</p> <ol> <li> <p>If this does not work, it means that your terminal or OS is intercepting the shortcut keys for other purposes.  For instance, CTRL-V might be interpreted as \"paste\" in Windows.  You need to remap the hotkeys either in Vim or your app/OS.\u00a0\u21a9</p> </li> </ol>"},{"location":"vim/philosophy.html","title":"The Philosophy of <code>vim</code>","text":"<p>This article is adapted from the notes of the Unix@Home Workshop  held in August 2020.</p> <p>Learning Objectives</p> <p>Students should</p> <ul> <li>appreciate the usefulness of learning <code>vim</code> and using it as the main source code editor.</li> <li>appreciate the efficiency and philosophy of using <code>vim</code>.</li> <li>have experience navigating around a text buffer and manipulating text in <code>vim</code></li> <li>be aware of how to learn more about using <code>vim</code>.</li> </ul>"},{"location":"vim/philosophy.html#background","title":"Background","text":"<p>To edit our code, we need a proper editor.  Remember that, ideally, we want to keep our hands on the keyboard and keep ourselves \"in the zone\" with only the terminal, the keyboard, and ourselves, so we will use a terminal-based editor: no windows, no mouse, no arrow keys, no function keys.</p> <p>There are only two respectable, widely available text editors in Unix \u2014 <code>vim</code> and <code>emacs</code>.  Which one is better has been an ongoing religious war, but for us in SoC, we use <code>vim</code>.</p> <p>Reading Keyboard Keys</p> <p>Keyboard keys are enclosed in a box like the following letter A.  All keyboard keys are written in uppercase.  You are to press exactly that key without any other key.  So the letter A should give you the lowercase \"a\" character.</p> <p>If a sequence of keys is to be pressed, you will see the keys in successions.  For instance, if you see G G, it means you should press G twice.</p> <p>On the other hand, if multiple keys are to be pressed at the same time, you will see a plus sign (i.e., +) written in between the keys.  For instance, if you see Shift+Z+Z, it means you should press Shift key and Z at the same time.  Since we cannot press two different Z at the same time, the second Z is pressed after your finger has been moved from the first Z.  However, you should still be pressing the Shift key.</p> <p>If the intention is for the Shift key to not be pressed for the second Z, it will be written as Shift+Z Z.</p>"},{"location":"vim/philosophy.html#basic-of-vim","title":"Basic of <code>vim</code>","text":""},{"location":"vim/philosophy.html#minimizing-hand-movements","title":"Minimizing Hand Movements","text":"<p><code>vim</code>, like the shell, aims to minimize hand movements.  Frequently used commands are positioned in convenient places on the keyboard.  Let me give you a few examples.</p> <ul> <li> <p>To exit vim, type Shift+Z+Z.  Notice that this is located in the bottom left corner of your keyboard.  For normal typing, your left hand is supposed to be placed over the keys A S D F, so you just need to move slightly your left pinky to Shift and left ring finger to Z and hit them.</p> </li> <li> <p>To move the cursor, instead of using the arrow keys, <code>vim</code> uses H to move left, L to move right, J to move down, and K to move up.  For normal typing, your right hand is supposed to be placed on J K L ;, so these arrow key alternatives are located very near to where your right hand should be!</p> </li> </ul> <p>I have a few more things to say about using H J K L to replace the arrow keys:</p> <ul> <li> <p>It is not uncommon for applications to re-map other keys for movement.  Many first-person shooting games use W A S D for movement, for the same reason as <code>vim</code> \u2014 it is close to the resting position of the left hand on the keyboard.</p> </li> <li> <p>The use of H J K L for movement is more ubiquitous than you think.  In the Web version of Gmail, Facebook, and Reddit, for instance, you could use J and K to move up and down across posts.</p> </li> </ul>"},{"location":"vim/philosophy.html#multi-modal-editor","title":"Multi-modal Editor","text":"<p><code>vim</code> is a multi-modal editor.  While most other editors make no distinction between reading and editing, <code>vim</code> makes an explicit distinction between the two.  <code>vim</code> has two basic modes:</p> <ul> <li><code>NORMAL</code> mode: where you read, navigate and manipulate the text.</li> <li><code>INSERT</code> mode: where you insert the text</li> </ul> <p>As a programmer, having a separate <code>NORMAL</code> mode makes sense since we spend much time reading and navigating around source code.  Thus, allowing the editing commands to be optimized.</p> <p>In the <code>NORMAL</code> mode, you can use any of these keys I S A O (with or without Shift) to switch to <code>INSERT</code> mode.  To go back to <code>NORMAL</code> mode, press Esc.  The keys I S A O have different meanings, which you will learn later.</p> <p>Note that most of the time you will be in <code>NORMAL</code> mode.  So a habitual <code>vim</code> user would insert some text and immediately switch back to normal mode by hitting Esc.</p>"},{"location":"vim/philosophy.html#tell-vim-what-you-want-to-do-dont-do-it-yourself","title":"Tell <code>vim</code> What You Want To Do; Don't Do It Yourself","text":"<p>In <code>NORMAL</code> mode, you can manipulate text in <code>vim</code> by issuing commands to <code>vim</code>.  These commands are like a programming language.  It is also not unlike the Unix commands, in that each command does a small thing but can be composed together to perform complex text manipulation.</p> <p>Let me give an example here.  Suppose you have a sentence:</p> <pre><code>Wherever there is light, there is also a shadow.\n</code></pre> <p>You want to remove <code>also a</code> from the sentence.</p> <p>What would you do in a typical text editor?  You move your hand away from the keyboard, find your mouse, move your mouse cursor to highlight the text, and then hit Del.  Or you could move the cursor (by mouse or by repeatedly hitting the keyboard) to place the cursor after <code>a</code>, and then press Del six times.</p> <p>In addition to being tedious, this is error-prone.  You might highlight one additional or one less space, or hit Del one too many times.</p> <p>What we are used to doing is performing the action of deleting the words ourselves.  For <code>vim</code>, we do it differently.  We need to look for the word <code>also</code> and delete two words.  This translates to the command / A L S O Enter D 2 W.</p> <ul> <li>/ triggers a search.  This is an almost universal command \u2014 try / on Facebook (web) or on this page.</li> <li>A L S O Enter tells <code>vim</code> what you want to search. After pressing Enter, your cursor should be placed at the beginning of <code>also</code>.</li> <li>D 2 W tell <code>vim</code> to \"delete two words\".</li> </ul> <p>Instead of worrying about the actual actions to perform the deletion, we issue higher-level commands to describe what we want to do.  This is powerful since this is how our brain thinks \u2014 \"I need to insert this here, change this word to that, remove two lines, etc.\"  All these maps into commands in <code>vim</code>.  As a result, once you master <code>vim</code> basics, you can type as fast as you think<sup>1</sup>!</p> <p>A common pattern for <code>vim</code> command consists of three parts:</p> <ol> <li>Place the cursor.</li> <li>Perform an action.</li> <li>Move to the new placement of the cursor.</li> </ol> <p>In the example above, / A L S O Enter places the cursor, D is the action (delete), and 2 W is the movement (move the cursor forward by two words).</p> <p>Another common command that students use is G G = Shift+G.  This command is used to indent the source code in the current file.  G G is the command to place the cursor at the top of the file.  = is the action (indent), and Shift+G is the command to place the cursor on the last line of the file.</p>"},{"location":"vim/philosophy.html#be-a-good-unix-citizen","title":"Be A Good Unix Citizen","text":"<p>Not only do the basic commands <code>vim</code> adhere to the Unix principles of composability, <code>vim</code> plays well with Unix shells, which adds additional power to <code>vim</code>.  For instance, if you want to have the standard output from a command paste into the file you are editing, you can run:</p> <pre><code>:r! &lt;command&gt;\n</code></pre> <p>: triggers the <code>vim</code> command line.  R asks <code>vim</code> to read something and paste it into the current cursor location.  At this point, you can pass in, for instance, another file name.  But here, we enter !, which tells <code>vim</code> to run a shell.  We then pass the <code>command</code> to the shell.  Whatever the command writes to the standard output, will be read and inserted into <code>vim</code>.</p> <p>Want to insert today's date?</p> <pre><code>:r! date\n</code></pre> <p>Want to insert a mini calendar?</p> <pre><code>:r! cal\n</code></pre> <p>Want to insert the list of all JPG pictures?</p> <pre><code>:r! ls *jpg\n</code></pre> <p>You can even pass a chunk of text from <code>vim</code> to the standard input of another program, and replace it with what is printed to the standard output by that program.</p>"},{"location":"vim/philosophy.html#other-reasons-to-learn-vim","title":"Other Reasons To Learn <code>vim</code>","text":"<p>Besides enabling you to type as fast as you think with as few hand movements as possible, there are other reasons to use <code>vim</code>:</p> <ul> <li> <p><code>vim</code> is installed by default in almost any Unix environment.  Imagine if you get called to a client-side to debug a Linux server, and you need to edit something \u2014 you can rest assured that <code>vim</code> is there.</p> </li> <li> <p><code>vim</code> is the only source code editor you need to learn and master.  It works for almost any programming language.  If you use IDE, you have to learn IntelliJ for Java, IDLE for Python, Visual Studio C++ for C++, etc.  This reason is also why VS Code has gained significant popularity in recent years.</p> </li> <li> <p><code>vim</code> is extensible and programmable.  It has been around for almost 30 years, and tons of plugins have been written.  Whatever feature you need, there is likely a native <code>vim</code> command or a <code>vim</code> plugin for that.</p> </li> </ul> <p>The only downside to using <code>vim</code> is that it is terminal-based (some consider it ugly) and it has a steep learning curve.  But, in our experience, students will build up their muscle memory and are comfortable with <code>vim</code> after 2-3 weeks of usage.</p> <p>For CS2030S, there is another practical reason to learn and gain familiarity with <code>vim</code>.  The practical exams are conducted in a sandboxed environment, which you can only access through <code>ssh</code> via a terminal.  You only have a few choices (<code>emacs</code>, <code>micro</code>, <code>vim</code>) and <code>vim</code> is the only reasonable choice. </p> <ol> <li> <p>The book Practical Vim by Drew Neil has the subtitle \"Edit text at the speed of thought\".\u00a0\u21a9</p> </li> </ol>"},{"location":"vim/plugins.html","title":"Vim Extensions on PE Hosts","text":"<p>CS2030S provides a minimal set of vim extensions (i.e., plugins and color schemes) officially.  At the beginning of the semester, students can install the same set of extensions following the vim setup procedure. The same set of official extensions will be made available during the practical exams.</p> <p>Students are free to install any additional color schemes or plugins if they wish.  These additional extensions, however, are not allowed and will not be available during the practical exams.</p> <p>The following are the officially supported vim extensions in CS2030S.  Follow the instructions in our article Setting Up Vim to install them.</p>"},{"location":"vim/plugins.html#color-schemes","title":"Color Schemes","text":"<p>We provided three color schemes in <code>~cs2030s/.vim/colors</code>.</p> <p>The three color schemes are:</p> <ul> <li>gruvbox</li> <li>molokai</li> <li>onedark</li> </ul> <p>You can change your vim color scheme using the <code>:color</code> command.  For instance,</p> <pre><code>:color gruvbox\n</code></pre> <p>You can add the line <code>color gruvbox</code> (without <code>:</code>) to your <code>~/.vimrc</code> so that the color scheme is loaded at the start of every vim session.</p> <p>Some color schemes display differently depending on whether the background is set to <code>dark</code> or <code>light</code></p> <p>Some examples, with <code>set background=dark</code> in <code>~/.vimrc</code>:</p> <p>The Vim default color scheme:</p> <p></p> <p>The molokai (CS2030S default) color scheme:</p> <p></p> <p>The gruvbox color scheme </p> <p></p>"},{"location":"vim/plugins.html#plugins","title":"Plugins","text":"<p>We support two plugins for CS2030S.</p>"},{"location":"vim/plugins.html#airline","title":"Airline","text":"<p>The Airline plugin, which provides an informative status bar in vim.</p>"},{"location":"vim/plugins.html#syntastic","title":"Syntastic","text":"<p>The plugin syntastic automatically checks for syntax and style errors every time a file is saved (when you run <code>:w</code>).</p> <p>The syntastic configuration in the CS2030S <code>~/.vimrc</code> has been made to work with your PE hosts.</p>"},{"location":"vim/quick-lessons.html","title":"Quick <code>vim</code> Lessons","text":"<p>Learning Objectives</p> <p>Students should</p> <ul> <li>have a basic familiarity with <code>vim</code>.</li> </ul> <p>Here is a quick walkthrough to get a taste of <code>vim</code>.</p>"},{"location":"vim/quick-lessons.html#lesson-1-preparation","title":"Lesson 1: Preparation","text":""},{"location":"vim/quick-lessons.html#step-1-download","title":"Step 1: Download","text":"<p>Download the following file for practice using <code>vim</code> in this session.</p> <pre><code>$ cp /opt/course/cs2030s/jfk.txt .\n</code></pre> <p>The file named <code>jfk.txt</code> should be copied to your currentw orking directory.  You can check that the file is created by typing the following</p> <pre><code>$ ls\n</code></pre>"},{"location":"vim/quick-lessons.html#step-2-open","title":"Step 2: Open","text":"<p>Now let's start your first <code>vim</code> session.  Open <code>vim</code> and load the downloaded <code>jfk.txt</code> using the following command</p> <pre><code>$ vim jfk.txt\n</code></pre> <p></p>"},{"location":"vim/quick-lessons.html#lesson-2-navigation","title":"Lesson 2: Navigation","text":""},{"location":"vim/quick-lessons.html#step-1-moving","title":"Step 1: Moving","text":"<p>When you start, you will be in <code>NORMAL</code> mode.  Do not go into the <code>INSERT</code> mode yet.  Try the following exercise to get comfortable with the keys.</p> <ul> <li>Move the cursor around step-by-step backward (H), down (J), forward (K), and up (L).</li> <li>Move the cursor sentence-by-sentence forward ()) and backward (().</li> <li>Move the cursor paragraph-by-paragraph forward (}) and backward ({).</li> <li>Move the cursor page-by-page forward (Ctrl+F) and backward (Ctrl+B).</li> <li>Move the cursor to the beginning of the line with 0.</li> <li>Move the cursor to the end of the line with Shift+4 (i.e., <code>$</code>).</li> <li>Move the cursor to the beginning of the file with G G.</li> <li>Move the cursor to the end of the file with Shift+G (i.e., <code>G</code>).</li> </ul>"},{"location":"vim/quick-lessons.html#step-2-searching","title":"Step 2: Searching","text":"<p>Now try the following steps in <code>NORMAL</code> mode:</p> <ol> <li>Press /.</li> <li>Type in any word (or prefix of a word), we recommend the word <code>the</code>.</li> <li>Press Enter.</li> </ol> <p>After step 2, you should see the following with your command highlighted in a red box.</p> <p></p> <p>This should move the cursor to the beginning of the word.  You can use N and Shift+N to move to the next match and the previous match.</p> <p>When you are comfortable moving around, you can type Shift+Z+Z to exit.</p> <p>Congratulations, you have just completed your first session in <code>vim</code>!</p>"},{"location":"vim/quick-lessons.html#lesson-3-manipulating-text","title":"Lesson 3: Manipulating Text","text":"<p>Now, we are going to open up the same file again and try to manipulate the text.  We are going to stay in the <code>NORMAL</code> mode still.</p> <pre><code>$ vim jfk.txt\n</code></pre>"},{"location":"vim/quick-lessons.html#step-1-deletion","title":"Step 1: Deletion","text":"<p>Deletion is closer to cut.  The deleted characters are stored in a clipboard.  Try the following:</p> <ul> <li>Press 0 D 3 W to move the cursor to the beginning of the line and delete three words.</li> <li>Press U to undo.  This is another lifesaver that you should remember.</li> </ul> <p>In <code>vim</code>, repeating the same command twice usually means applying it to the whole line.  Pairing a command with Shift (or the capital letter version) usually means applying the action until the end of the line.  </p> <ul> <li>Press D D to delete the current line.</li> <li>Press Shift+D to delete from the current cursor until the end of the line.</li> </ul>"},{"location":"vim/quick-lessons.html#step-2-copy-pasting","title":"Step 2: Copy-Pasting","text":"<p>Pasting recovers what was stored in the clipboard.  Try the following:</p> <ul> <li>Press P to paste back what you just deleted.</li> <li>Move the cursor to somewhere else.</li> <li>Press P to paste again.</li> </ul> <p>We can also copy instead of cut (or delete and put into the clipboard).</p> <ul> <li>Press Y Y to copy (or yank) the current line.</li> <li>Move the cursor to somewhere else.</li> <li>Press P to paste the copied line.</li> </ul> <p>Remember that all these commands can be composed using the movement-action-movement pattern.</p> <ul> <li>Press Shift+9 Y Shift+0 to<ul> <li>move to the beginning of the sentence: Shift+9 (i.e., {) </li> <li>copy (i.e., yank): Y</li> <li>until the end of the sentence: Shift+0 (i.e., })</li> </ul> </li> </ul> <p>As you have seen in the D 2 W example, you can precede an action with a number to repeat an action multiple times.</p> <ul> <li>Press Y Y 9 P.<ul> <li>You should be able to understand what just happened!</li> </ul> </li> </ul>"},{"location":"vim/quick-lessons.html#step-3-deleting-a-character","title":"Step 3: Deleting a Character","text":"<p>The X command deletes the current character.</p> <p>Try this exercise: At the end of the file <code>jfk.txt</code>, there are some typos:</p> <pre><code>libertyi. liberty.\n</code></pre> <p>Change <code>libertyi. liberty.</code> to <code>libtery.</code> by positioning the cursor on the second <code>i</code> and deleting it.  Then use Shift+D to delete the extra <code>liberty.</code> at the end of the sentence.</p>"},{"location":"vim/quick-lessons.html#step-4-visual-mode","title":"Step 4: Visual Mode","text":"<p>In addition to the <code>INSERT</code> and <code>NORMAL</code> modes, <code>vim</code> has a third mode, the <code>VISUAL</code> mode.  You can enter the <code>VISUAL</code> mode by hitting V.  Once in visual mode, you can move your cursor to select the text and perform some actions on it (e.g., D or X to delete, Y to yank).</p> <p>Hitting Shift+V will allow you to select line-by-line.</p> <p>The <code>VISUAL</code> mode allows us to pipe the selected text to another Unix command, and replace it with the result of that command.</p> <p>Go ahead and try the following:</p> <ol> <li>Select a paragraph in <code>jfk.txt</code>.</li> <li>Press :.</li> </ol> <p>You will see that</p> <pre><code>:'&lt;,'&gt;\n</code></pre> <p>appears in the last line of the terminal.  At this point, you can type in actions that you want to perform on the selected text.  For instance,</p> <pre><code>:'&lt;,'&gt;w john.txt\n</code></pre> <p>will write it to a file named <code>john.txt</code>.</p> <p>But, let's try the following:</p> <pre><code>:'&lt;,'&gt;!fmt\n</code></pre> <p><code>!fmt</code> tells <code>vim</code> to invoke the shell and run <code>fmt</code>.  <code>fmt</code> is another simple small Unix utility that takes in a text (from standard input) and spews out formatted text in the standard output.  You will see that the width of the text has changed to the default of 65.</p> <p>You can try something that we have seen before.  Select the text again, and hit</p> <pre><code>:'&lt;,'&gt;!wc\n</code></pre> <p>The selected text will be replaced with the output from <code>wc</code>.</p>"},{"location":"vim/quick-lessons.html#step-5-the-command","title":"Step 5: The <code>:</code> command","text":"<p>You have seen examples of <code>:</code> commands for writing to a file or piping selected text to an external command.</p> <p>The <code>:</code> command also enables many actions that you can do in <code>vim</code>.  Here are a few essential yet simple commands.</p> <ul> <li>To jump to a line, hit : followed by the line number.</li> <li>To open another file, hit : and then type in <code>e &lt;filename&gt;</code></li> <li>To find help on a topic, hit : and then type in <code>help &lt;keyword&gt;</code></li> </ul> <p>Other advanced features such as search-and-replace, changing preferences, splitting windows, and opening new tabs, are also accessible from the <code>:</code> command.</p> <p>The <code>:</code> command prompt supports Ctrl+P and Ctrl+N for navigating back and forth your command history, just like <code>bash</code>.  It also supports Tab for auto-completion.</p>"},{"location":"vim/quick-lessons.html#lesson-3-insert-mode","title":"Lesson 3: Insert mode!","text":"<p>Finally, we are going to try inserting some text.  Remember, to use <code>INSERT</code> mode, we always start with the command I A O or S (may pair with Shift) followed by the text that you want to insert, followed by Esc.</p>"},{"location":"vim/quick-lessons.html#step-1-insert","title":"Step 1: Insert","text":"<p>Let's try I (insert).</p> <ol> <li>Place your cursor anywhere.</li> <li>Press I to go into <code>INSERT</code> mode</li> <li>Start typing.</li> <li>When you are done, press Esc.</li> </ol> <p>You just added some text to the file.</p>"},{"location":"vim/quick-lessons.html#step-2-append","title":"Step 2: Append","text":"<p>Now let's try A (append).</p> <ol> <li>Place your cursor anywhere.</li> <li>Press A.</li> <li>Start typing.</li> <li>When you are done, press Esc.</li> </ol> <p>A appends the text to the end of the current line.</p>"},{"location":"vim/quick-lessons.html#step-3-open","title":"Step 3: Open","text":"<p>Now let's try O (open).</p> <ol> <li>Place your cursor anywhere.</li> <li>Press O.</li> <li>Start typing.</li> <li>When you are done, press Esc.</li> </ol> <p>O opens up a new line for your text.</p>"},{"location":"vim/quick-lessons.html#step-4-substitute","title":"Step 4: Substitute","text":"<p>Now let's try O (open).</p> <ol> <li>Place your cursor anywhere.</li> <li>Press S.</li> <li>Start typing.</li> <li>When you are done, press Esc.</li> </ol> <p>S substitute the current character with your text.</p>"},{"location":"vim/quick-lessons.html#step-5-shift","title":"Step 5: Shift","text":"<p>Now try it with Shift and see the difference in behavior.</p>"},{"location":"vim/quick-lessons.html#learning-more","title":"Learning More","text":"<p>You can run <code>vimtutor</code> to learn more about <code>vim</code>.  Check out the tips that we have collected for CS2030S, or watch the various tutorials online.  Here are some interesting ones are:</p> <ul> <li>Vim Genius: A game that goes together with <code>vimtutor</code></li> <li>Learn vim Progressively.</li> <li>Vim: Precision Editing at the Speed of Thought: A talk by Drew Neil</li> <li>Vim Adventure: An adventure game for learning <code>vim</code></li> <li>Vim Casts: Videos and articles for teaching <code>vim</code></li> <li>Vim Video Tutorials by Derek Wyatt</li> <li>Vim Awesome: Directory of plugins.</li> </ul> <p>You can search the Web for \"best vim tutorials\" to find many other resources to get you started with the editor.  You can run <code>vimtutor</code> to learn more about <code>vim</code>.</p>"},{"location":"vim/setup.html","title":"Setting Up <code>vim</code> on PE Hosts","text":""},{"location":"vim/setup.html#vim-configuration","title":"<code>vim</code> Configuration","text":"<p>Like many other Unix programs, you can configure your preferences by creating an <code>rc</code> (run commands) file in your home directory.  These <code>rc</code> files will be read by the corresponding programs and executed line-by-line as if the text is entered into the program through a keyboard.  You can view an <code>rc</code> file as a script that will be executed automatically whenever a program starts.</p> <p>For <code>vim</code>, the <code>rc</code> file is called <code>.vimrc</code>.  The dot (i.e., <code>.</code>) in the front of the file name carries a special meaning in Unix.  It means that this file is hidden \u2014 you won't see it when you <code>ls</code>.  Hiding the run command files prevent your home directory from being cluttered.  To tell <code>ls</code> to show the hidden files, use the <code>-a</code> flag</p> <pre><code>$ ls -a\n</code></pre> <p>We have created a <code>.vimrc</code> file, with CS2030S defaults, for your use.  This is the basis upon which you can build your own configuration. </p> <p>To copy this file to your home directory on the PE nodes,</p> <pre><code>$ cp /opt/course/cs2030s/.vimrc ~\n</code></pre> <p>You can ask <code>vim</code> to automatically back up the files that you edit.  This has been a lifesaver for me on multiple occasions.</p> <p>The default <code>.vimrc</code> contains the following two lines:</p> <pre><code>set backup\nset backupdir=~/.backup\n</code></pre> <p>This causes <code>vim</code> to save the previous version of every file you edited in a backup directory at location <code>~/.backup</code>.  You need to create this directory, however, by</p> <pre><code>$ mkdir -p ~/.backup\n</code></pre> <p>Now, if you made changes to a file that you regretted, or if you accidentally deleted a file, you can check under <code>~/.backup</code> to see if the backup can save you.</p>"},{"location":"vim/setup.html#recovering-from-backup","title":"Recovering from Backup","text":"<p>To recover the file from the backup folder, you can copy the file using</p> <pre><code>$ cp ~/.backup/&lt;filename&gt; &lt;destination&gt;/&lt;filename&gt;\n</code></pre>"},{"location":"vim/setup.html#vim-extensions","title":"<code>vim</code> Extensions","text":"<p>CS2030S provides a minimal set of <code>vim</code> extensions by default for your programming exercises and practical exams.  See the article on <code>vim</code> extensions for details.  </p> <p>Additional <code>vim</code> extensions are installed under <code>~/.vim</code>.  To install these \"official\" CS2030S <code>vim</code> extensions, you can copy the <code>.vim</code> from cs2030s's home directory to your home directory.  On the PE host, run:</p> <pre><code>mkdir -p ~/.vim\ncp -r /opt/course/cs2030s/.vim/* ~/.vim\n</code></pre> <p>You can test out the different color schemes according to the instructions to check if you have set up the extensions correctly.  The default CS2030S <code>.vimrc</code> uses the <code>molokai</code> color schemes.</p>"},{"location":"vim/tips.html","title":"Vim Tips","text":"<p>I collected some tips on <code>vim</code> that I find helpful for students. </p> <p>Prerequisite</p> <p>You have gone through the basic quick lessons and have set up your vim in your PE account.</p> <p>Learning Objectives</p> <p>Students should</p> <ul> <li>be able to compare files (e.g., input/output matching for correctness).</li> <li>be able to recover from <code>.swp</code> file in <code>vim</code>.</li> </ul>"},{"location":"vim/tips.html#1-useful-configuration","title":"1. Useful Configuration","text":""},{"location":"vim/tips.html#showing-line-numbers","title":"Showing Line Numbers","text":"<p>If you prefer to show the line number on every line in <code>vim</code>, add</p> <pre><code>set number\n</code></pre> <p>to your <code>~/.vimrc</code>.</p>"},{"location":"vim/tips.html#2-navigation","title":"2. Navigation","text":""},{"location":"vim/tips.html#faster-navigation","title":"Faster Navigation","text":"<p>If you find yourselves typing too many HJKL to navigate around your code, check out the following shortcuts to navigate around:</p> <p>To move word-by-word:</p> <ul> <li>W jump to the beginning of the next word</li> <li>B ump to the beginning of the previous word (reverse of <code>w</code>)</li> <li>E jump to the end of the word (or next word when pressed again)</li> </ul> <p>To search:</p> <ul> <li>F char: search forward in the line and sit on the next matching char</li> <li>T char:  search forward in the line and sit on one space before the matching char</li> </ul> <p>0 would move you to the beginning of the line, but when coding, it is sometimes useful to jump to the first non-blank character instead.  To do so, use Shift+6 (i.e., <code>^</code>).</p> <p>In coding, we have many pairs of <code>[]</code>, <code>{}</code>, <code>()</code> and <code>&lt;&gt;</code>.  You can use Shift+5 (i.e., <code>%</code>) jump between matching parentheses.</p>"},{"location":"vim/tips.html#jump-to-a-line","title":"Jump to a Line","text":"<p>If the compiler tells you there is an error on Line \\(x\\), you can issue <code>:&lt;x&gt;</code> to jump to Line \\(x\\).  For instance, <code>:40</code> will go to Line 40.</p>"},{"location":"vim/tips.html#3-editing-operations","title":"3. Editing Operations","text":""},{"location":"vim/tips.html#undo-and-redo","title":"Undo and Redo","text":"<p>Since we are on the topic of correcting mistakes, U in command mode undo your changes.  Prefix it with a number \\(n\\) to undo \\(n\\) times.  If you want to undo your undo, Ctrl+R will redo.</p>"},{"location":"vim/tips.html#navigation-editing","title":"Navigation + Editing","text":"<p><code>vim</code> is powerful because you can combine operations with navigation.  For instance C to change, D to delete, Y to yank (copy).  Since W is the navigation command to move over the current word, combining them we get:</p> <ul> <li>CW change the current word (delete the current word and enter insert mode)</li> <li>DW delete the current word</li> <li>YW yank the current word (copy word into buffer)</li> </ul> <p>Can you guess what each of these does:</p> <ul> <li>DFShift+0 </li> <li>DFShift+0 </li> <li>CShift+4</li> <li>Y0</li> </ul> <p>If you repeat the operation C, D, and Y, it applies to the whole line, so:</p> <ul> <li>CC change the whole line</li> <li>DD delete the whole line</li> <li>YY yank the whole line</li> </ul> <p>You can add a number before an operation to specify how many times you want to repeat an operation.  So 5DD  deletes 5 lines, 5DW deletes 5 words, etc.</p> <p>See the article Operator, the True Power of <code>Vim</code> for more details.</p>"},{"location":"vim/tips.html#swapping-lines","title":"Swapping Lines","text":"<p>Sometimes you want to swap the order of two lines of code, in command mode, DDP will do the trick.  DD deletes the current line, P paste it after the current line, in effect swapping the order of the two lines.</p>"},{"location":"vim/tips.html#commenting-blocks-of-code","title":"Commenting blocks of code","text":"<p>Sometimes we need to comment out a whole block of code in C for testing purposes. There are several ways to do it in <code>vim</code>:</p> <ul> <li>Place the cursor on the first line of the block of code you want to comment on.</li> <li>0 to jump to the beginning of the line</li> <li> Ctrl+V enter visual block mode (if your terminal intercepts Ctrl+V as paste, try Ctrl+Q). </li> <li>Use the arrow key to select the block of code you want to comment on.</li> <li>Shift+I to insert at the beginning of the line (here, since we already selected the block, we will insert at the beginning of every selected)</li> <li>// to insert the C/Java comment character (you will see it inserted in the current line, but don't worry)</li> <li>Esc to escape from the visual code.</li> </ul> <p>To uncomment,</p> <ul> <li>Place the cursor on the first line of the block of code you want to comment.</li> <li>0 to jump to the beginning of the line</li> <li>Ctrl+V enter block visual mode</li> <li>Use the arrow key to select the columns of text containing <code>//</code></li> <li>X to delete them</li> </ul>"},{"location":"vim/tips.html#4-other-useful-commands","title":"4. Other Useful Commands","text":""},{"location":"vim/tips.html#search-and-replace-in-vim","title":"Search and Replace in <code>vim</code>","text":"<pre><code>:%s/oldWord/newWord/gc\n</code></pre> <p><code>:</code> enters the command mode.  <code>%</code> means apply to the whole document, <code>s</code> means substitute, <code>g</code> means global (otherwise, only the first occurrence of each line is replaced). <code>c</code> is optional \u2014 adding it cause <code>vim</code> to confirm with you before each replacement  </p>"},{"location":"vim/tips.html#shell-command","title":"Shell Command","text":"<p>If you need to issue a shell command quickly, you don't have to exit <code>vim</code>, run the command, and launch <code>vim</code> again.  You can use <code>!</code>,</p> <pre><code>:!&lt;command&gt;\n</code></pre> <p>will issue the command to shell.  E.g.,</p> <pre><code>:!ls\n</code></pre> <p>You can use this to compile your current file, without exiting <code>vim</code>.</p> <pre><code>:!make\n</code></pre> <p><code>make</code> is a builtin command for <code>vim</code>, so you can also simply run</p> <pre><code>:make\n</code></pre>"},{"location":"vim/tips.html#terminal","title":"Terminal","text":"<p>You can open an interactive shell from within <code>vim</code> with:</p> <pre><code>:terminal\n</code></pre> <p>This command splits the window and add a terminal, within which you can compile or run your code.</p>"},{"location":"vim/tips.html#abbreviation","title":"Abbreviation","text":"<p>You can use the command <code>ab</code> to abbreviate frequently typed commands.  E.g., in your <code>~/.vimrc</code>,</p> <pre><code>ab sop System.out.println\n</code></pre> <p>Now, when you type <code>sop</code>, it will be expanded into <code>System.out.println</code></p>"},{"location":"vim/tips.html#auto-completion","title":"Auto-Completion","text":"<p>You can use Ctrl+P or Ctrl+N to auto-complete.  By default, the autocomplete dictionary is based on the text in your current editing buffers.  This is a very useful keystroke saver for long function names and variable names.</p>"},{"location":"vim/tips.html#auto-indent-the-whole-file","title":"Auto-Indent the Whole File","text":"<p>You can GG=Shift+G in command mode (i.e., type out <code>gg=G</code>) to auto-indent the whole file.  GG is the command to go to the beginning of the file.  = is the command to indent.  Shift+G is the command to go to the end of the file.</p>"},{"location":"vim/tips.html#split-vims-viewport","title":"Split <code>vim</code>'s Viewport","text":"<ul> <li><code>:sp file.c</code> splits the <code>vim</code> window horizontally</li> <li><code>:vsp file.c</code> splits the <code>vim</code> window vertically</li> <li>Ctrl+WCtrl+W moves between the different <code>vim</code> viewports</li> </ul> <p>Alternatively, run <code>vim -O file1 file2</code> to immediately open both files in two different viewpoints.</p>"},{"location":"vim/tips.html#compare-two-files","title":"Compare two files","text":"<p>You can compare two files with <code>vim</code>, using the <code>-d</code> flag.  For instance,</p> <p><code>vim -d file1 file2</code></p> <p>would open up two files for line-by-line comparison.  This is most useful if you want to compare the output of your program with the expected output.</p>"},{"location":"vim/tips.html#5-recovery-files","title":"5. Recovery Files","text":"<p>Vim automatically saves the files you are editing into temporary swap files, with the extension <code>.swp</code>.  These files are hidden, so you don't normally see them when you run <code>ls</code>.  (You need to run <code>ls -a</code> to view the hidden files)</p> <p>The swap files are useful if your editing session is disrupted before you save (e.g., the network is disconnected, you accidentally close the terminal, your OS crashes, etc).</p> <p>When you launch <code>vim</code> to edit a file, say, <code>foo.c</code>.  <code>vim</code> will check if a swap file <code>.foo.c.swp</code> exist.  If it does, <code>vim</code> with display the following</p> <pre><code>Found a swap file by the name \".foo.c.swp\"\n          owned by: elsa   dated: Sat Aug 21 15:01:04 2021\n         file name: ~elsa/foo.c\n          modified: no\n         user name: elsa   host name: pe116\n        process ID: 7863 (STILL RUNNING)\nWhile opening file \"foo.c\"\n             dated: Mon Jul 12 18:38:37 2021\n\n(1) Another program may be editing the same file.  If this is the case,\n    be careful not to end up with two different instances of the same\n    file when making changes.  Quit, or continue with caution.\n(2) An edit session for this file crashed.\n    If this is the case, use \":recover\" or \"vim -r a.c\"\n    to recover the changes (see \":help recovery\").\n    If you did this already, delete the swap file \".a.c.swp\"\n    to avoid this message.\n\nSwap file \".a.c.swp\" already exists!\n[O]pen Read-Only, (E)dit anyway, (R)ecover, (Q)uit, (A)bort:\n</code></pre> <p>The messages above are self-explanatory.  Read it carefully.  Most of the time, you want to choose \"R\" to recover your edits, so that you can continue editing.  Remember to remove the file <code>.foo.c.swp</code> after you have recovered.  Otherwise, <code>vim</code> will prompt you the above messages every time you edit <code>foo.c</code>.</p> <p>Warning</p> <p>If <code>foo.c</code> is newer than the state saved in <code>.foo.c.swp</code>, and you recover from <code>.foo.c.swp</code>, you will revert to the state of the file as saved in the swap file.  This can happen if (i) you edit the file without recovery, or (ii) you recover the file, continue editing, but did not remove the <code>.foo.c.swp</code> file after.</p>"}]}